//Tree Shade - Startup Javascript for Adobe Bridge
//dulajun@gmail.com
//Tel.: +966508018243

var tsRootFolderPath = null;
var tsPreviousRootPath = null;
var tsUserTask = "Scanning";
var tsVersionNumber = "9.3.6";
var tsClientID = "";
var tsUserID = null;
var tsUserName = "";
var tsUserEmail = "";
var tsUserImage = null;
var tsInitializeDone = false;
var tsRecentNewFromPath = "BBB";
var tsTemplatesPath = "CCC";
var tsChangeTemplate = "";
var tsIsStaticIDs = false;
var tsWorkshopPath = "";
var tsPagesPath = "";
var tsDataPath = "";
var tsVersionsPath = "";
var tsFinalPDFPath = "";
var tsVersionsPDFPath = "";
var tsVersionsPages = "";
var tsCloudPaths = new Array;
var tsTrashPath = "";
var tsPrefixID;
var tsSettingFile;
var tsUserSettingFile;
var tsTaskStage = 0;
var tsMainInterval = 197;
var tsAmbushingStep = 0;
var tsScanningStep = 0;
var tsFakeModifiedStep = 7;
var tsPhysicalPDFStep = 17;
var tsAlertPathChangedStep = 4;
var tsOnlineInterval = 600000;
var tsDownloadingStep = 0;
var tsMessagesScanStep = 0;
var tsRandomTimeTaskStep = 0;
var tsMessagesCleanStep = 5260;
var tsMessagesStep = 54;
var tsCopyToStep = 11;
var tsGrowingInterval = 1;
var tsFoldersChanged = new Array;
var tsSuspectedFolders = new Array;
var tsLoadedFolders = new Array;
var tsToBeSelectedList = new Array;
var tsChangeList = [0];
var tsLastSelected = null;
var tsBeforeLastSelectedFullPath = null;
var tsBeforeLastSelectedSize = null;
var tsPickedFilesListWithSubs = new Array;
var tsToBeSelectedThumbnail = null;
var tsIDTimePathStepIsUserOldPathList = new Array;
var tsOldModifiedFileIDList = new Array;
var tsPhysicalPDFList = new Array;
var tsDownloadingList = new Array;
var tsLoadStage = 0;
var tsSendingBoxesStep = 0;
var tsSendingBoxesSpan = 2;
var tsProducingWorkSheetSteps = 4670;
var tsIsToRestart = 0;
var tsIsWideScanning = false;
var tsIsWideScanningUltimate = false;
var tsAbandonedDocCounter = 0;
var tsNewFromRemoteTargetFolder = null;

var CSExtensionList = new Array;
var growingFolders = new Array;
var isOddStage = false;
var suspectedOdd = new Array;
var suspectedEven = new Array;
var isBlackSide = false;
var tsIsPhysicalFinished = false;
var isNoDeleteTSQueries = true;
var openToEditStep = 0;
var scopeChangedStep = 0;
var scopesChangingAlerted = false;
var tsLoadedPreviousDate = new Date().getTime();
var previousLoadedThumbnail;
var closingRequested = false;
var tsChangeRootRequested = false;
var okNowYouCanQuit = false;
var tsInitializeAlerts = false;
var tsInitializeStep = 4;
var quitRequestTime = null;
var tsMainTaskID;
var tsIsMacOS = false;
var tsWorkingTimeOn = true;
var tsWorkingOn = 0;
var tsWorkingTimeStep = Math.floor (new Date ().getMinutes ()/5);
var tsCheckSenderStep = 0;
var tsCheckSendersSpan = 30;
var tsIsMessagesStoped = false;
var tsIsStartPDFExporting = false;
var tsNewCollaborators = new Array;
var tsIsScanningStopped = 2;
var tsOldRecord = "";
var startScanAtZero = 4;
//
var sendersList = new Array;
var recipientsList = new Array;
var InDesignLoadList = new Array;
var InDesignCheckInList = new Array;
var tsAlertPDFPreviewList = new Array;
var tsAlertPDFPreviewStep = 0;
var tsReopenAfterRenameList = new Array;
var tsChangeAfterCloseList = new Array;
var tsLiveSnippetCheckInList = new Array;
var tsAutoCheckInFilesList = new Array;
var tsAutoCheckInFilesStep = 0;
var tsAutoCheckInFilesStepWide = 50;
var openToEditList = new Array;
var insideIDsList = new Array;
var tsScanningQueue = new Array;
var tsOrdersList = new Array;
var tsGroupedOrdersList = new Array;
var onlineCollaborators = new Array;
var emptyFoldersList = new Array;
emptyFoldersList.push (new Array); //emptyFoldersList[0] tsWorkshopPath List
emptyFoldersList.push (new Array); //emptyFoldersList[1] non tsWorkshopPath List
var emptyFoldersStep = 0;
var tsCheckedInThumbnailsList = new Array;
var tsPathChangedThumbList = new Array;
var tsDownloadingThumbList = new Array;
var tsUploadThumbnailsList = new Array;
var tsCopyToList = new Array;
var tsVersionsToWorkshopList = new Array;
var tsVersionsToWorkshopStep = 0;
var tsLinksLoadList = new Array;
tsLinksLoadList.push (new Array); //tsLinksLoadList[0] waiting list before check list
tsLinksLoadList.push (new Array); //tsLinksLoadList[1] to be checked and to be requested list
tsLinksLoadList.push (new Array); //tsLinksLoadList[2] requested list  
var tsConsiderSwapList = new Array;
var tsConsiderSwapStep = 0;
var tsLinksLoadStep = 0;
var tsScopesList;
var tsRootsList;
var tsDialogsCheckList = new Array;
var cleanningIndex = 0;
var isAlertedToRestart = false;
var thumbnailList = new Array;
var thumbnailVersionList = new Array;
var newVersionDigitsFileIDTriple = null;
var thumbnailWaitingSteps = 100;
var isThereMessages = false;
var tsIsSendingDone = true;
var tsIsVersionsOutputToWorkshop = false;
var tsIsSwitchWithInDesign = false;
var tsIsIgnoreVersionOwner = false;
var tsIsRespondToManuallyDeleted = false;
var tsVersionsOutputZero = ""; //"NO_ZERO" no zero output, "WITH_ZERO" zero output, "ONLY_ZERO" only zero output
var tsTreeShadeThumb = "/.TREESHADE/.THUMB/";
var isNewMessage = false;
var isSelectionChangedByUser = true;
var tsSelectionChangedByUserDate = new Date().getTime();
var lastSwitchingTime = new Date().getTime();
var tsTextEditorOpened = false;
var tsEditText = null;
var tsUserKeyDate = new Date ().getTime ();
var tsUserKeyValue = "";
var mainLoop = ["\\", "|", "/", "-"];
var mainLoopIndex = 0;
var tsDynamicSnippetTag = "::";
var tsChangeShortcuts = new Array;

var treeShadeNamespace = "http://ns.dulajun.com/treeshade/";
var treeShadePrefix = "ts:";

onPref = function (event) {
    return { handled: false };
}

onOpenFolder = function (event) {
    if (event.object instanceof Thumbnail && event.type == "open") {
        var containerThumbnail = event.object;
        if (event.object instanceof Thumbnail) {
            containerThumbnail = event.object;
        }
        else {
            containerThumbnail = event.object.thumbnail;
        }
        if (!tsIsWideScanningUltimate)
            startScanAtZero = 5;
        if (containerThumbnail.container) {
            if (tsLoadStage == 2) {
                if (containerThumbnail.spec.fsName) { //Without Replace
                    if (tsToBeSelectedThumbnail) {
                        isSelectionChangedByUser = false;
                        app.document.deselectAll ();
                        app.document.select (tsToBeSelectedThumbnail);
                        var dotIndex = File.decode (tsToBeSelectedThumbnail.spec.name).lastIndexOf (".");
                        if (dotIndex > 0) {
                            if (File.decode (tsToBeSelectedThumbnail.spec.name).slice (dotIndex) == ".mp3") {
                                app.document.deselectAll ();
                                app.document.select (tsToBeSelectedThumbnail);
                            }
                        }
                        //tsToBeSelectedThumbnail = null;
                        isSelectionChangedByUser = true;
                    }
                    else if (tsToBeSelectedList.length > 0) {
                        isSelectionChangedByUser = false;
                        app.document.deselectAll ();
                        var toBeSelectedFiles = containerThumbnail.spec.getFiles (isAnyOfThese);
                        for (var q = 0; q < toBeSelectedFiles.length; q++) {
                            if (toBeSelectedFiles[q] instanceof File) {
                                if (toBeSelectedFiles[q].exists) {
                                    app.document.select (new Thumbnail (toBeSelectedFiles[q]));
                                }
                            }
                        }
                        isSelectionChangedByUser = true;
                    }
                }
            }
            else if (tsLoadStage == 1) {
                tsLoadStage++;
            }
            else {
            }
            if ((containerThumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath != "") {
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 0.4;
                }
            }
            else if ((containerThumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 1.5;
                }
            }
            else if ((containerThumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "") {
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 2.5;
                }
            }
            else if ((containerThumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "") {
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 3.5;
                }
            }
            else if ((containerThumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "") {
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 4.5;
                }
            }
            else if ((containerThumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath != "") {
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 5.5;
                }
            }
            else if (containerThumbnail.spec.fsName.replace(/\\/g, '/') == tsRootFolderPath + "/Workflow/Collaborators/New") {
                var newCollaborators = Folder (tsRootFolderPath + "/Workflow/Collaborators/New").getFiles (isAcceptedFile);
                if (newCollaborators.length == 1) {
                    var collaboratorInfo = tsGetUserInfo (newCollaborators[0][0]);
                    alert ("This Collaborator '" + newCollaborators[0][1]  + "' lacks for separated shared folder to make synchronizing more efficient. Please create new folder inside 'Dialogs' and share it with him. And told him to put it also inside 'Dialogs' as you. His email '" + newCollaborators[0][2] + "'.");
                }
                else if (newCollaborators.length > 1) {
                    alert ("These collaborators lack for separated shared folders to make synchronizing more efficient.\nPlease double click each one for more information.");
                }
            }      
        }
        else {
            if (isJpgOrPngFile (containerThumbnail.spec)) {
                var targetFile = containerThumbnail.spec;
                if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsPagesPath + "/") == 0 || targetFile.fsName.replace(/\\/g, '/').indexOf (tsRootFolderPath + "/Workflow/Queries/") == 0) {
                    var relativePath;
                    var subPages;
                    if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsRootFolderPath + "/Workflow/Queries/") == 0) {
                        relativePath = targetFile.fsName.replace(/\\/g, '/').replace (tsRootFolderPath + "/Workflow/Queries/", "");
                        relativePath = relativePath.slice (relativePath.indexOf ("/"));
                        relativePath = relativePath.slice (1);
                        subPages = relativePath.slice (0, relativePath.indexOf ("/"));
                        relativePath = relativePath.slice (relativePath.indexOf ("/"));
                    }
                    else if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsPagesPath + "/") == 0) {
                        relativePath = targetFile.fsName.replace(/\\/g, '/').replace (tsPagesPath, "");
                        relativePath = relativePath.slice (1);
                        subPages = relativePath.slice (0, relativePath.indexOf ("/"));
                        relativePath = relativePath.slice (relativePath.indexOf ("/"));
                    }
                    if (relativePath) {
                        var docPath;
                        if (subPages == "Workshop")
                            docPath = (tsWorkshopPath + relativePath).slice (0, (tsWorkshopPath + relativePath).lastIndexOf ("/"));
                        else
                            docPath = (tsVersionsPath + relativePath).slice (0, (tsVersionsPath + relativePath).lastIndexOf ("/"));
                        if (File (docPath).exists) {
                            var pageNumber = relativePath.slice (relativePath.lastIndexOf ("/") + 1);
                            pageNumber = pageNumber.slice (0, pageNumber.lastIndexOf ("."));
                            pageNumber = removeLeftZeros (pageNumber);
                            var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                            var talkInDesign = new BridgeTalk;
                            talkInDesign.target = targetInDesign;
                            talkInDesign.onResult = function (returnBtObj)
                            { setInDesignScript (returnBtObj.body); }
                            talkInDesign.body = "var doc = app.open(new File ('" + docPath + "')" + ", true, " + (subPages == "Workshop"? "OpenOptions.OPEN_ORIGINAL" : "OpenOptions.OPEN_COPY") + "); if (doc) {doc.layoutWindows[0].activePage = doc.pages.itemByName ('" + pageNumber + "');} app.activate ();";
                            talkInDesign.send ();
                            function setInDesignScript (theBody) {
    
                            }
                            return {handled:true};
                        } 
                    }
                }
                else if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsRootFolderPath + "/Workflow/Scopes/Active/") == 0) {
                    var scopeIndex = -1;
                    var selectedScopeID = tsGetScopeID (targetFile);
                    if (selectedScopeID) {
                        for (var sc = 0; sc < tsScopesList.length; sc++) {
                            if (tsScopesList[sc][0] == selectedScopeID) {
                                scopeIndex = sc;
                                break;
                            } 
                        }
                    }
                    if (scopeIndex >= 0) {
                        var scopeFolder = tsScopesList[scopeIndex][1][5].parent;
                        app.document.thumbnail = new Thumbnail (scopeFolder);    
                        return {handled:true};                    
                    }
                }
                else if (targetFile.parent.fsName.replace(/\\/g, '/').indexOf ("/Workflow/Collaborators/") != -1) {
                    var imageInfo = tsGetUserInfo (targetFile);
                    if (imageInfo) {
                        var collaboratorID = imageInfo[0];
                        if (collaboratorID) {
                            var recipientIndex = tsGetRecipientIndex (collaboratorID);
                            if (recipientIndex != -1) {
                                if (recipientsList[recipientIndex][3] == "Dialog") {
                                    app.document.thumbnail = new Thumbnail (recipientsList[recipientIndex][1].parent);    
                                }
                                else if (recipientsList[recipientIndex][3] == "Pair") {
                                    var thisCollaboratorInfo = tsGetUserInfo (targetFile);
                                    alert ("This Collaborator '" + thisCollaboratorInfo[1]  + "' lacks for separated shared folder to make synchronizing more efficient. Please create new folder inside 'Dialogs' and share it with him. And told him to put it also inside 'Dialogs' as you. His email '" + thisCollaboratorInfo[2] + "'.");
                                }
                            }
                        }            
                    }
                    return {handled:true};
                }
            }
            if (tsIsShade (containerThumbnail.spec)) {
                var targetFile = containerThumbnail.spec;
                if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
                    if (targetFile.name[0] == '-') {
                        var dateName = new Date().getTime();
                        dateName = dateName.toString ();
                        var labelFolderBrowse = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);
                        labelFolderBrowse.create ();
                        var allSubFolders = targetFile.parent.getFiles (isAcceptedFolder);
                        var isBrowse = false;
                        for (var a = 0; a < allSubFolders.length; a++) {
                            var labelFile = allSubFolders[a].getFiles (tsIsLabelFile);
                            if (labelFile.length == 1) {
                                var shortcutFile = new File (labelFolderBrowse.fsName.replace(/\\/g, '/') + "/" + File.decode (labelFile[0].name).slice (2));
                                if (!shortcutFile.exists) {
                                    shortcutFile.createAlias (labelFile[0]);
                                    isBrowse = true;
                                }
                            }
                            else if (labelFile.length > 0) {
                                alert ("There is duplicated label in this folder:\n" + allSubFolders[a].fsName.replace(/\\/g, '/'));
                            }
                            else {
                                
                            }
                        }
                        if (isBrowse) {
                            app.document.thumbnail = new Thumbnail (labelFolderBrowse);
                        }
                        else {
                            var folderThumbnail = new Thumbnail (targetFile.parent);
                            folderThumbnail.open ();
                            if (targetFile.parent.fsName.replace(/\\/g, '/') != tsWorkshopPath) {
                                var nextParent = targetFile.parent.parent;
                                if (nextParent.fsName.replace(/\\/g, '/') != tsWorkshopPath) {
                                    while (nextParent.parent.fsName.replace(/\\/g, '/') != tsWorkshopPath) {
                                        var localLock = new File (nextParent.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
                                        if (localLock.exists) {
                                            localLock.remove ();
                                        }
                                        nextParent = nextParent.parent;
                                        if (!nextParent) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        var confirmResult = confirm ("It's just shade! Do you want to load the actual file?");
                        if (confirmResult) {
                            var fileID = tsGetID (targetFile);
                            if (fileID) {
                                var currentVersionDigitsFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                                var currentVersionDigits = readFile (currentVersionDigitsFile);
                                if (currentVersionDigits) {
                                    currentVersionDigits = currentVersionDigits.split (":")[0];
                                    var currentVersionFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + currentVersionDigits + " " + File.decode (targetFile.name));
                                    var isAlreadyExist = false;
                                    if (currentVersionFile.exists) {
                                        if (currentVersionFile.length >= 128) {
                                            isAlreadyExist = true;
                                        }
                                    }
                                    if (!isAlreadyExist) {
                                        tsLoadVersionFile (currentVersionFile, fileID, true);
                                    }
                                }
                            }
                        }
                    }
                }
                else if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
                    if (tsIsShade (targetFile)) {
                        var confirmResult = confirm ("It's just shade! Do you want to load the actual file?");
                        if (confirmResult) {
                            var fileID = tsGetID (targetFile);
                            if (fileID) {
                                tsLoadVersionFile (targetFile, fileID, true);
                            }
                        }
                    }
                }
                return {handled:true};
            }
            else {
                if (containerThumbnail.spec.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "") {
                    var targetFile = containerThumbnail.spec;
                    var fileID = tsGetID (targetFile);
                    if (!fileID) {
                        return {handled:false};
                    }
                    var docDotID = fileID.replace (/\//g,"\.");
                    docDotID = docDotID.slice (1);
                    var isToCheckOut = false;
                    var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                    var currentVersion = readFile (currentRecordFile);
                    if (currentVersion) {
                        currentVersion = currentVersion.split (":")[0];
                    }
                    var isCurrentVersion = (targetFile.name.indexOf ("ver" + currentVersion) == 0);
                    if (isInDesignFile (targetFile)) {
                        var openedMarkFile = new File (tsDataPath + "/Opened Documents/" + docDotID);
                        if (!openedMarkFile.exists) {
                            if (isCurrentVersion) {
                                isToCheckOut = confirm ("Do you want to undo the modifications?\n" + "'" + File.decode (targetFile.name) + "'");
                            }
                            else {
                                isToCheckOut = confirm ("Do you want to set this version as Current?\n" + "'" + File.decode (targetFile.name) + "'");
                            }
                        }
                    }
                    else {
                        if (isCurrentVersion) {
                            isToCheckOut = confirm ("Do you want to undo the modifications?\n" + "'" + File.decode (targetFile.name) + "'");
                        }
                        else {
                            isToCheckOut = confirm ("Do you want to set this version as Current?\n" + "'" + File.decode (targetFile.name) + "'");
                        }
                    } 
                    if (isToCheckOut) {
                        var workshopFile = new File (targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1).replace (tsVersionsPath, tsWorkshopPath) + targetFile.fsName.replace(/\\/g, '/').slice (targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 7));
                        var versionTime = null;
                        var isModified = false;
                        if (currentVersion) {
                            var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/Modifying Time");
                            versionTime = readFile (versionTimeFile);
                            if (versionTime) {
                                var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/V/" + versionTime + "/UnderEditingByOther");
                                if (underEditingByOtherFile.exists) {
                                    isModified = true;
                                }
                            }
                        }
                        if (isModified) {
                            tsCheckOut (targetFile, false);
                            if (isCurrentVersion) {
                                alert ("Your modification - if there - is undone, And don't modify again it's under editing by another collaborator!\n" + "'" + File.decode (targetFile.name) + "'");
                            }
                            else {
                                alert ("It's set as Current version, but it's under editing by another collaborator! Don't modify.\n" + "'" + File.decode (targetFile.name) + "'");
                            }
                            return {handled:true};
                        }                            
                        else {
                            var isUnderEditingByMe = false;
                            if (versionTime && workshopFile.exists) {
                                var actualModified = tsGetActualModified (workshopFile.modified.getTime (), fileID);
                                if (actualModified > parseInt (versionTime, 10)) {
                                    isUnderEditingByMe = true;
                                }
                            }
                            if (isUnderEditingByMe) {
                                if (isCurrentVersion) {
                                    tsCheckOut (targetFile, false);
                                    tsGoToTree ();
                                }
                                else {
                                    alert ("Check in the file because there is a modification, or undo it. then try again!\n" + "'" + File.decode (targetFile.name) + "'");
                                }
                                return {handled:true};
                            }
                            else {
                                if (isCurrentVersion) {
                                    alert ("There is no modification to undo!\n" + "'" + File.decode (targetFile.name) + "'");
                                }
                                else {
                                    tsCheckOut (targetFile, false);
                                    tsGoToTree ();
                                }
                                return {handled:true};
                            }
                        }
                    }
                    else {
                        if (isInDesignFile (targetFile)) {
                            var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                            var talkInDesign = new BridgeTalk;
                            talkInDesign.target = targetInDesign;
                            talkInDesign.onResult = function (returnBtObj)
                            { setInDesignScript (returnBtObj.body); }
                            talkInDesign.body = "var doc = app.open(new File ('" + targetFile.fsName.replace(/\\/g, '/') + "')" + ", true, " + "OpenOptions.OPEN_COPY" + "); app.activate ();";
                            talkInDesign.send ();
                            function setInDesignScript (theBody) {
    
                            }
                        }
                        else {
                            return {handled:false};
                        }
                    }
                    return {handled:true};
                }
                else if (containerThumbnail.spec.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath != "") {
                    var isInMessages = (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsRootFolderPath + "/Workflow/Messages/") == 0? true : false;
                    if (isInMessages) {
                        tsToBeSelectedThumbnail = containerThumbnail;
                        tsLoadStage = 1;
                        app.document.thumbnail = containerThumbnail.parent;
                        return {handled:true};
                    }
                    else {
                        var isToOpenOnlineForm = false;
                        var isKeyFile = (File.decode (containerThumbnail.spec.name).indexOf ("ts_key") != -1);
                        if (isKeyFile) {
                            isToOpenOnlineForm = confirm ("Open online form?");
                        }
                        if (isToOpenOnlineForm) {
                            var absolutePath = containerThumbnail.spec.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                            var hostname = readFile (File (tsRootFolderPath + "/.Data/HOSTNAME.txt"));
                            if (hostname) {
                                if (absolutePath == "") {
                                    absolutePath = "/";
                                }
                                var keyFlag = File.decode (containerThumbnail.spec.name).match (/ts_key(_\w+)*/)[0];
                                keyFlag = keyFlag.split ("_");
                                var passValue = "";
                                if (keyFlag.length > 3) {
                                    passValue = "?pass=" + keyFlag[3];
                                }
                                var url = "https://" + hostname + absolutePath + passValue;

                                var htmlFile = new File(tsRootFolderPath + "/.Data/redirect.html");
                                var html = '<!DOCTYPE html><html><head><meta charset="UTF-8"></head>' +
                                        '<body onload="window.location.href=\'' + url + '\'">' +
                                        'Redirecting...<br><a href="' + url + '">Click here if not redirected</a>' +
                                        '</body></html>';
                                writeFile (htmlFile, html);
                                var toOpenThumbnail = new Thumbnail (htmlFile);
                                toOpenThumbnail.open ();
                            }
                            return {handled:true};
                        }
                        else {
                            var isPairedOpened = false;
                            var pairedFolderName = tsGetPureName (File.decode (containerThumbnail.spec.name), false);
                            var expectedFolder = new Folder (containerThumbnail.spec.parent.fsName.replace(/\\/g, '/') + "/" + pairedFolderName);
                            if (expectedFolder.exists) {
                                var isToOpenPaired = confirm ("Open Paired Folder?");
                                if (isToOpenPaired) {
                                    isPairedOpened = openPairedFolder (containerThumbnail.spec, false, false);
                                }
                            }
                            if (isPairedOpened) {
                                return {handled:true};
                            }
                            else {
                                if (tsIsLiveSnippetFile (containerThumbnail.spec)) {
                                    var livesnippetFile = new File (containerThumbnail.spec.fsName.replace(/\\/g, '/'));
                                    var promptMes = "";
                                    var theSnippetContent = readFile (livesnippetFile);
                                    var isDynamicSnippet = false;
                                    if (theSnippetContent.indexOf (tsDynamicSnippetTag) == 0) {
                                        isDynamicSnippet = true;
                                    }
                                    if (!isDynamicSnippet) {
                                        promptMes = [File.decode (livesnippetFile.name) + " Content:"];
                                    }
                                    else {
                                        promptMes = [File.decode (livesnippetFile.name) + " Content:",
                                                    "",
                                                    "::Path:Method:Separator",
                                                    "",
                                                    "Path (or table formula or style name):",
                                                    "//: Root of Tree Shade path.",
                                                    "./: Snippet parent folder path. add dots for parent of parent...",
                                                    "<.>: Snippet parent folder name. add dots for parent of parent...",
                                                    "To reference to the document instead of the snippet file write like this '.$/' or '<.$>'...",
                                                    "Also use these tags with path:",
                                                    "<File_Branch>, <File_Name>, <File_Display>, <Original_File_Name>, <Previous_File_Name>,",
                                                    "<Container_File_Branch>, <Container_File_Name>, <File_Level>, <Doc_Name>, <Doc_Order>, <Page_Num>,",
                                                    "<Applied_Section_Prefix>, <Applied_Section_Marker>, <Master_Prefix>, <Master_Name>, <Master_Full_Name>,",
                                                    "<Para_Order>, <Para_First>, <Para_Before>, <Para_This>, <Para_After>, <Para_Style>, <Char_Style>,",
                                                    "<Col_Head>, <Col_Num>, <Row_Head>, <Row_Num>, <Name_At>, <Shift1>.",
                                                    "The target number comes after <Name_At> but before <Shift1>.",
                                                    "<Remove_If_Empty> To remove the paragraph, text frame, row or column if there is no text in the live snippet.",
                                                    "After the style name write <Based_On> to add the style if not exist, then the base style if there is.",
                                                    "Use <File_Name_Separator_NewSeparatorOrIndex> like <SN_ _1> will take first word.",
                                                    "Dynamic Table Formula:",
                                                    "'Sum', 'Subtract', 'Divide', 'Multiply', 'Average', 'Count', or 'Join'.",
                                                    "For an example <Sum (<Col_Num>, 1)(<Col_Num>, <Row_Num> - 1)> This will get the sum of all cells above.",
                                                    "You could abbreviate any one like <FB> instead of <File_Branch>.",
                                                    "",
                                                    "The following also accepts abbreviation and used for date, time and random code:",
                                                    "<Day_Seconds>, <Day_Minutes>, <Day_Hours>, <Weekday_Order>, <Weekday_Name>, <Weekday_Abbreviation>,",
                                                    "<Month_Date>, <Month_Order>, <Month_Name>, <Month_Abbreviation>, <Year_Full>,",
                                                    "<Year_Abbreviation>, <Time_Decimal>, <Time_Hexadecimal>, <Time_Shortest>,",
                                                    "<Random_Style_Long> Where 'Style' a combination of symbols 'a' for small letters,",
                                                    "'A' capital letters, 'h' small hexadecimal, 'H' large hexadecimal and '1' for numbers.",
                                                    "For example <Random_1A_8> means random 8 characters consists of capital letters and numbers",
                                                    "",
                                                    "Method:",
                                                    "'Snippets', 'Place', 'Names' or 'Repeat', 'Key', 'Data'.",
                                                    "The target style or action: 'Font', 'Style', 'Size', 'Color', 'Justification', 'characterDirection',",
                                                    "'paragraphDirection', 'Para', 'Char', 'Obj', 'Height', 'Width', 'Area', 'Rotate', 'Shear', 'Short',",
                                                    "'Long', 'Merge', 'Cell', 'Row', 'Column' or 'Table'.",
                                                    "Write 'Inner' or 'Outer' with method like 'Inner Table' to target the table(s) inside the snippet.",
                                                    "",
                                                    "Separator:",
                                                    "'Frames', 'Table', 'Rows', 'Columns', 'Colon' or any text letters.",
                                                    "Example: '.$/<PN>/*.png:Place:|'",
                                                    "This will place all the png files in the folder beside the document that",
                                                    "its name as the page number. These PNGs will separated by '|' character."];
                                    }
                                    if (theSnippetContent == "no_text") {
                                        theSnippetContent = "";
                                    }
                                    var newContent = tsGetText (promptMes, theSnippetContent, true); //!isDynamicSnippet || theSnippetContent.search (/\n/) != -1
                                    if (newContent != null) {
                                        if (newContent == "" && !isDynamicSnippet) {
                                            newContent = "no_text";
                                        }
                                        livesnippetFile.encoding = "UTF8";
                                        writeFile (livesnippetFile, newContent);
                                        var digitsFileIDTriple = getWorkshopVersionInfo (livesnippetFile, null);
                                        if (digitsFileIDTriple)
                                            tsCheckIn (livesnippetFile, digitsFileIDTriple, false, true, true, true, false, true, null);
                                    }
                                    return {handled:true};
                                }
                                else {
                                    var isExist = false;
                                    for (var c = openToEditList.length - 1; c >= 0; c--) {
                                        if (openToEditList[c][1].fsName.replace(/\\/g, '/') == containerThumbnail.spec.fsName.replace(/\\/g, '/')) {
                                            isExist = true;
                                            break;
                                        }
                                    }
                                    if (!isExist) {
                                        var openToEditItem = new Array;
                                        openToEditItem.push (-1);
                                        openToEditItem.push (containerThumbnail.spec);
                                        openToEditItem.push (containerThumbnail.spec.modified.getTime ());
                                        openToEditList.push (openToEditItem);
                                    }
                                }
                            }
                        }
                    }
                }
                else if (File.decode (containerThumbnail.spec.name) == "^ Open me to browse new messages.mp3") {
                    var now = new Date ();
                    var month = now.getMonth () + 1;
                    var day = now.getDate ();
                    month = month > 9? month.toString () : "0" + month.toString ();
                    day = day > 9? day.toString () : "0" + day.toString ();
                    var dayName;
                    switch (now.getDay ()) {
                        case 0:
                            dayName = "Sunday";
                            break;
                        case 1:
                            dayName = "Monday";
                            break;
                        case 2:
                            dayName = "Tuesday";
                            break;
                        case 3:
                            dayName = "Wednesday";
                            break;
                        case 4:
                            dayName = "Thursday";
                            break;
                        case 5:
                            dayName = "Friday";
                            break;
                        case 6:
                            dayName = "Saturday";
                            break;
                    }
                    var targetMessagesFolder = new Folder (tsRootFolderPath + "/Workflow/Messages/" + now.getFullYear() + "." + month + "/" + day + "." + dayName);
                    if (targetMessagesFolder.exists) {
                        app.document.thumbnail = new Thumbnail (targetMessagesFolder);
                        isNewMessage = false;
                    }
                    return {handled:true};
                }
            }
        }
    }
}

function removeLeftZeros (targetString) {
    /**///$.writeln ($.line);
    var resultString = targetString;
    while (resultString.charCodeAt (0) == 48) {
        if (resultString.length > 1)
            resultString = resultString.slice (1);
        else
            break;
    }
    return resultString;
}

onLoaded = function(event) {
    /**///$.writeln ($.line);
    if (event.object instanceof Document && event.type == "create") {
        buildNavbar (event.object);
    }
    if (event.object instanceof Document && event.type == "selectionsChanged") {
        if (isSelectionChangedByUser && event.object.selections.length != 0) {
            if (app.document.selections.length == 1) {
                if (app.document.selections[0].spec) {
                    if (app.document.selections[0].spec.fsName) { //Without Replace
                        if (app.document.selections[0].container) {
                        }
                        else if (app.document.selections[0].spec.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0 && isAcceptedFile (app.document.selections[0].spec) && isAcceptedFolder (app.document.selections[0].spec.parent)) {
                            if (tsBeforeLastSelectedFullPath != app.document.selections[0].spec.fsName.replace(/\\/g, '/')) {
                                if (tsBeforeLastSelectedFullPath && !isCSFile (app.document.selections[0].spec)) {
                                    var currentIDFile = new File (app.document.selections[0].spec.parent.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + File.decode (app.document.selections[0].spec.name));
                                    if (!currentIDFile.exists) {
                                        var beforeWorkshopFile = new File (tsBeforeLastSelectedFullPath);
                                        if (!beforeWorkshopFile.exists && tsBeforeLastSelectedSize == app.document.selections[0].spec.length) {
                                            if (beforeWorkshopFile.parent.fsName.replace(/\\/g, '/') == app.document.selections[0].spec.parent.fsName.replace(/\\/g, '/') && beforeWorkshopFile.name.split('.').pop() == app.document.selections[0].spec.name.split('.').pop()) {
                                                var beforeIDFile = new File (beforeWorkshopFile.parent.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + File.decode (beforeWorkshopFile.name));
                                                if (beforeIDFile.exists) {
                                                    beforeIDFile.copy (currentIDFile);
                                                    beforeIDFile.remove ();
                                                    //Paired Folder
                                                    var pairedFolderName = tsGetPureName (File.decode (beforeWorkshopFile.name), false);
                                                    var expectedFolder = new Folder (beforeWorkshopFile.parent.fsName.replace(/\\/g, '/') + "/" + pairedFolderName);
                                                    var desPureName = tsGetPureName (File.decode (app.document.selections[0].spec.name), false);
                                                    if (expectedFolder.exists && pairedFolderName != desPureName) {
                                                        var desFolder = new Folder (app.document.selections[0].spec.parent.fsName.replace(/\\/g, '/') + "/" + desPureName);
                                                        var filesList = new Array;
                                                        retrieveFilesList (expectedFolder, filesList, false, []);
                                                        if (filesList.length > 0) {
                                                            for (var fl = 0; fl < filesList.length; fl++) {
                                                                var pairedDesFullPath = desFolder.fsName.replace(/\\/g, '/') + filesList[fl].fsName.replace(/\\/g, '/').replace (expectedFolder.fsName.replace(/\\/g, '/'), "");
                                                                tsChangeFile (filesList[fl], File (pairedDesFullPath), false, 2, false);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                tsBeforeLastSelectedFullPath = app.document.selections[0].spec.fsName.replace(/\\/g, '/');
                                tsBeforeLastSelectedSize = app.document.selections[0].spec.length;
                            }
                            tsLastSelected = app.document.selections[0].spec;
                            labelWorkshopFile (app.document.selections[0].spec, [null], false);
                        }
                    }
                }
            }
            tsSelectionChangedByUserDate = new Date().getTime();
            tsToBeSelectedList = new Array;
            tsToBeSelectedThumbnail = null;
            tsLoadStage = 0;
        }
    }
    if(event.object instanceof Document && event.type == "loaded") 
    { 
        var currentDate = new Date().getTime();
        if (previousLoadedThumbnail != event.object.thumbnail || (currentDate - tsLoadedPreviousDate) > 500) {
            if (tsLoadStage == 2) {
                if (event.object.thumbnail.spec.fsName) { //Without Replace
                    if (tsToBeSelectedThumbnail) {
                        isSelectionChangedByUser = false;
                        app.document.deselectAll ();
                        app.document.select (tsToBeSelectedThumbnail);
                        //tsToBeSelectedThumbnail = null;
                        isSelectionChangedByUser = true;
                    }
                    else if (tsToBeSelectedList.length > 0) {
                        isSelectionChangedByUser = false;
                        app.document.deselectAll ();
                        var toBeSelectedFiles = event.object.thumbnail.spec.getFiles (isAnyOfThese);
                        for (var q = 0; q < toBeSelectedFiles.length; q++) {
                            app.document.select (new Thumbnail (toBeSelectedFiles[q]));
                        }
                        isSelectionChangedByUser = true;
                    }
                }
            }
            else if (tsLoadStage == 1) {
                tsLoadStage++;
            }
            else {
            }
            if (!tsIsWideScanningUltimate)
                startScanAtZero = 5;
            if (File.decode (event.object.thumbnail.spec.name).search(/ver\d\d /i) == 0) {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Document Pages";
                }
                if (app.document.navbars.filesystem.bottom) {
                    if (!app.document.navbars.filesystem.bottom.outLid) {
                        app.document.navbars.filesystem.bottom.outLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.25, 0.25, 0.25, 1]);
                    }
                    app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.outLid;
                    app.document.navbars.filesystem.bottom.visible = false;
                    app.document.navbars.filesystem.bottom.visible = true;
                }
            }
            else if (File.decode (event.object.thumbnail.spec.name).indexOf ("untitled folder") == 0) {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "UNTITLED";
                }
                if (app.document.navbars.filesystem.bottom) {
                    if (!app.document.navbars.filesystem.bottom.outLid) {
                        app.document.navbars.filesystem.bottom.outLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.25, 0.25, 0.25, 1]);
                    }
                    app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.outLid;
                    app.document.navbars.filesystem.bottom.visible = false;
                    app.document.navbars.filesystem.bottom.visible = true;
                }
            }
            else if (File.decode (event.object.thumbnail.spec.name)[0] == '.') {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "DON'T MODIFY";
                }
                if (app.document.navbars.filesystem.bottom) {
                    if (!app.document.navbars.filesystem.bottom.redLid) {
                        app.document.navbars.filesystem.bottom.redLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [1, 0, 0, 1]);
                    }
                    app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.redLid;
                    app.document.navbars.filesystem.bottom.visible = false;
                    app.document.navbars.filesystem.bottom.visible = true;
                }
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath) == 0 && tsWorkshopPath != "") {
                var isUpdated = false;
                
                //removing freezing
                var localLock = new File (event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
                if (localLock.exists) {
                    localLock.remove ();
                }
            
                var absolutePath = event.object.thumbnail.spec.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                if (absolutePath.length > 0) {
                    absolutePath = absolutePath.slice (1);
                    absolutePath = absolutePath + "/";
                    var lockFile = new File (tsWorkshopPath + "/" + absolutePath.slice (0, absolutePath.indexOf ("/")) + "/| Browse in Bridge to Resume Scanning");
                    lockFile.remove ();
                }
            
                //tsScanningQueue

                tsAddToScanningQueue ([event.object.thumbnail.spec.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "")]); //Ful path array

                var shotFile = new File ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/shotDate").replace (tsWorkshopPath, tsDataPath + "/Shots"));
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "UPDATED.";
                    if (!app.document.navbars.filesystem.bottom.workshopLid) {
                        app.document.navbars.filesystem.bottom.workshopLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.36, 0.89, 0.4, 1]);
                    }
                    app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.workshopLid;
                    app.document.navbars.filesystem.bottom.visible = false;
                    app.document.navbars.filesystem.bottom.visible = true;
                }
                if (shotFile.exists) {
                    if (event.object.thumbnail.spec.exists) {
                        if (shotFile.modified.getTime () > event.object.thumbnail.spec.modified.getTime ()) {
                            if (app.document.navbars.filesystem.top.waitOK) {
                                isUpdated = true;
                            }
                        }
                    }
                }
                if (!isUpdated) {
                    if (app.document.navbars.filesystem.top.waitOK) {
                        var foldersChangedIndex = -1;
                        for (var fc = 0; fc < tsFoldersChanged.length; fc++) {
                            if (tsFoldersChanged[fc] == event.object.thumbnail.spec.fsName.replace(/\\/g, '/')) {
                                foldersChangedIndex = fc;
                                break;
                            }
                        }
                        if (foldersChangedIndex != 0) {
                            if (foldersChangedIndex > 0)
                                tsFoldersChanged.splice (foldersChangedIndex, 1);
                            tsFoldersChanged.unshift (event.object.thumbnail.spec.fsName.replace(/\\/g, '/'));
                        }
                        app.document.navbars.filesystem.top.waitOK.text = "Wait...";
                        if (!app.document.navbars.filesystem.bottom.redLid) {
                            app.document.navbars.filesystem.bottom.redLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [1, 0, 0, 1]);
                        }
                        app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.redLid;
                        app.document.navbars.filesystem.bottom.visible = false;
                        app.document.navbars.filesystem.bottom.visible = true;
                    }
                }
                if (labelTreeItems (event.object.thumbnail.spec)) {
                    app.document.refresh ();
                }                    
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "") {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Versions.";
                }
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 2.5;
                }
                if (!app.document.navbars.filesystem.bottom.redLid) {
                    app.document.navbars.filesystem.bottom.redLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [1, 0, 0, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.redLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
                if (labelVersions (event.object.thumbnail.spec)) {
                    app.document.refresh ();
                }
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath) == 0 && tsFinalPDFPath != "") {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Final PDF.";
                }
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 3.5;
                }
                if (!app.document.navbars.filesystem.bottom.finalLid) {
                    app.document.navbars.filesystem.bottom.finalLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.7, 0, 0.96, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.finalLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
                if (labelFinalPDF (event.object.thumbnail.spec)) {
                    app.document.refresh ();
                }
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath) == 0 && tsVersionsPDFPath != "") {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Versions PDFs.";
                }
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 4.5;
                }
                if (!app.document.navbars.filesystem.bottom.versionPDFLid) {
                    app.document.navbars.filesystem.bottom.versionPDFLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [1, 0.6, 0, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.versionPDFLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
                if (labelPrevPDF (event.object.thumbnail.spec)) {
                    app.document.refresh ();
                }
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath) == 0 && tsTrashPath != "") {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Trash.";
                }
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 5.5;
                }
                if (!app.document.navbars.filesystem.bottom.trashLid) {
                    app.document.navbars.filesystem.bottom.trashLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0, 0, 0, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.trashLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath) == 0 && tsPagesPath != "") {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Pages.";
                }
                if (app.document.navbars.filesystem.top.locationSlider) {
                    app.document.navbars.filesystem.top.locationSlider.value = 1.5;
                }
                if (!app.document.navbars.filesystem.bottom.pagesLid) {
                    app.document.navbars.filesystem.bottom.pagesLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [1, 1, 0, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.pagesLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
            }
            else if ((event.object.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsRootFolderPath + "/Workflow") == 0 && tsWorkshopPath != "") {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Workflow";
                }
                if (!app.document.navbars.filesystem.bottom.workflowLid) {
                    app.document.navbars.filesystem.bottom.workflowLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.15, 0.66, 1, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.workflowLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
                if (File.decode (event.object.thumbnail.spec.name) == "Need To Be Checked In") {
                    produceNeedToBeCheckedIn ();
                }
            }
            else if (event.object.thumbnail.spec.fsName.replace(/\\/g, '/') == "") {
                var shadeThumb = [null];
                for (var sf = 0; sf < event.object.thumbnail.children.length; sf++) {
                    var searchedFile = event.object.thumbnail.children[sf].spec;
                    if (searchedFile instanceof File) {
                        if (tsIsShade (searchedFile)) {
                            if (searchedFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
                                labelWorkshopFile (searchedFile, shadeThumb, false);
                            }
                            else if (searchedFile.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
                                labelVersionFile (searchedFile, false);
                            }
                        }
                    }
                }
            }
            else {
                if (app.document.navbars.filesystem.top.waitOK) {
                    app.document.navbars.filesystem.top.waitOK.text = "Out.";
                    app.document.navbars.filesystem.top.locationSlider.value = 0;
                }
                if (!app.document.navbars.filesystem.bottom.outLid) {
                    app.document.navbars.filesystem.bottom.outLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.25, 0.25, 0.25, 1]);
                }
                app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.outLid;
                app.document.navbars.filesystem.bottom.visible = false;
                app.document.navbars.filesystem.bottom.visible = true;
            }
        }
        tsLoadedPreviousDate = currentDate;
        previousLoadedThumbnail = event.object.thumbnail;
        return {handled:false}; 
    }
}

function tsAddToScanningQueue (fullPathArray) {
    for (var fpa = 0; fpa < fullPathArray.length; fpa++) {
        var folderAbsulutePath = fullPathArray[fpa];
        for (var sq = tsScanningQueue.length - 1; sq >= 0; sq--) {
            if (tsScanningQueue[sq] == folderAbsulutePath) {
                tsScanningQueue.splice (sq, 1);
                break;
            }
        }
        tsScanningQueue.push (folderAbsulutePath);
    }
    if (tsScanningQueue.length > 20) {
        tsScanningQueue.splice (0, tsScanningQueue.length - 20);
    }
}

function labelVersionFile (targetFile, isThumbnailsLoaded) {
    var isToLoadAgain = false;
    var workshopFile = null;
    var fileID = null;
    if (isCSFile (targetFile)) {
        fileID = tsGetID (targetFile);
    }
    else {
        workshopFile = new File (targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1).replace (tsVersionsPath, tsWorkshopPath) + targetFile.fsName.replace(/\\/g, '/').slice (targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 7));
        if (workshopFile.exists)
            fileID = tsGetID (workshopFile);
        else 
            return false;
    }
    if (fileID) {
        var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
        var currentDigits = null;
        var isFinal = false;
        var currentContent = readFile (currentRecordFile);
        if (currentContent) {
            currentContent = currentContent.split (":");
            currentDigits = currentContent[0];
            isFinal = currentContent[1] == "F"? true : false;
        }
        var fileDigits = File.decode (targetFile.name).slice (3, 5);
        var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + fileDigits + "/Modifying Time");
        var versionTime = readFile (versionTimeFile);
        var fileThumbnail = new Thumbnail (targetFile);
        if (currentDigits == fileDigits) {
            var actualModified = null;
            if (!workshopFile) {
                workshopFile = new File (targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1).replace (tsVersionsPath, tsWorkshopPath) + targetFile.fsName.replace(/\\/g, '/').slice (targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 7));
                if (workshopFile.exists) {
                    actualModified = tsGetActualModified (workshopFile.modified.getTime (), fileID);
                }
            }
            else {
                actualModified = tsGetActualModified (workshopFile.modified.getTime (), fileID);
            }
            if (actualModified) {
                if (actualModified > parseInt (versionTime, 10)) {
                    if (fileThumbnail.label == "" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Modified By Another Collaborator") {
                        fileThumbnail.label = "Need To Be Checked In";
                        fileThumbnail.refresh ();
                        isToLoadAgain = true;
                    }
                    return isToLoadAgain;
                } 
            }
            if (isFinal) {
                if (fileThumbnail.label == "" || fileThumbnail.label == "Current" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Modified By Another Collaborator") {
                    fileThumbnail.label = "Final";
                    fileThumbnail.refresh ();
                    isToLoadAgain = true;
                }
                return isToLoadAgain;
            }
            if (fileThumbnail.label == "" || fileThumbnail.label == "Final" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Modified By Another Collaborator") {
                fileThumbnail.label = "Current";
                fileThumbnail.refresh ();
                isToLoadAgain = true;
            }
        }
        else {
            if (fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Modified By Another Collaborator") {
                fileThumbnail.label = "";
                fileThumbnail.refresh ();
                isToLoadAgain = true;
            }
        }
        if (!isThumbnailsLoaded) {
            if (versionTime) {
                var thumbFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + fileDigits + "/V/" + versionTime + "/Thumbnail.jpg");
                if (tsIsShade (targetFile)) {
                    if (thumbFile.exists) {
                        var source = new BitmapData (thumbFile);
                        var blackColor = new Color ("black");
                        var triangleRange = source.height < source.width? Math.round (source.height /8) : Math.round (source.width /8);
                        for (var yy = 0; yy < triangleRange; yy++) {
                            for (var xx = 0; xx < (triangleRange - yy); xx++) {
                                source.setPixel (xx, yy, blackColor);
                            }
                        }
                        fileThumbnail.core.quickMetadata.width = source.width;
                        fileThumbnail.core.quickMetadata.height = source.height;
                        fileThumbnail.core.icon.bitmap = source;
                        fileThumbnail.core.fullsize.fullsize = source;
                        fileThumbnail.core.thumbnail.thumbnail = source;
                        fileThumbnail.core.preview.preview = source;
                        fileThumbnail.refresh ();
                    }
                }
                else if (thumbFile.exists) {
                    if (tsGetMetadata (thumbFile, "TS_THUMB_FABRICATED")) {
                        var source = new BitmapData (thumbFile);
                        var greenColor = new Color ("green");
                        var triangleRange = source.height < source.width? Math.round (source.height /8) : Math.round (source.width /8);
                        for (var yy = source.height - 1; yy > (source.height - triangleRange); yy--) {
                            for (var xx = 0; xx < (triangleRange - (source.height - yy )); xx++) {
                                source.setPixel(xx, yy, greenColor);
                            }
                        }
                        fileThumbnail.core.quickMetadata.width = source.width;
                        fileThumbnail.core.quickMetadata.height = source.height;
                        fileThumbnail.core.icon.bitmap = source;
                        fileThumbnail.core.fullsize.fullsize = source;
                        fileThumbnail.core.thumbnail.thumbnail = source;
                        fileThumbnail.core.preview.preview = source;
                        fileThumbnail.refresh ();
                    }
                }
            }
        }
    }
    return isToLoadAgain;
}

function labelWorkshopFile (targetFile, shadeThumb, isThumbnailsLoaded) {
    var isLabelChanged = false;
    var fileID = tsGetID (targetFile);
    if (fileID) {
        var isToSkip = false;
        for (var om = 0; om < tsOldModifiedFileIDList.length; om++) {
            if (tsOldModifiedFileIDList[om][2] == fileID) {
                isToSkip = true;
                break;
            }
        }
        if (isToSkip)
            return isLabelChanged;
        var fileThumbnail = new Thumbnail (targetFile);
        var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
        var currentVersion = readFile (currentRecordFile);
        var versionTime = null;
        var isModified = false;
        if (currentVersion) {
            currentVersion = currentVersion.split (":")[0];
            var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/Modifying Time");
            versionTime = readFile (versionTimeFile);
            if (versionTime) {
                var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/V/" + versionTime + "/UnderEditingByOther");
                if (underEditingByOtherFile.exists) {
                    isModified = true;
                }
            }
        }
        if (!isThumbnailsLoaded) {
            var thumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
            if (!thumbFile.exists && tsIsLiveSnippetFile (targetFile)) {
                tsThumbFromPageLocation (targetFile, fileID);
                thumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
            }
            if (thumbFile.exists) {
                var thumbMarkColor = tsIsShade (targetFile)? "Black" : "Green";
                var fabricatedThumb = tsGetMetadata (thumbFile, "TS_THUMB_FABRICATED");
                if (fabricatedThumb || thumbMarkColor == "Black") {
                    if (fabricatedThumb != "ASSIGNED") {
                        var pageThumbFile = new File (tsPagesPath + "/Workshop" + fabricatedThumb);
                        if (!pageThumbFile.exists || pageThumbFile.modified.getTime () > thumbFile.modified.getTime ()) {
                            tsThumbFromPageLocation (targetFile, fileID);
                            thumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
                        }
                    }
                    var source = new BitmapData (thumbFile);
                    var triangleRange = source.height < source.width? Math.round (source.height /8) : Math.round (source.width /8);
                    if (fabricatedThumb) {
                        for (var yy = source.height - 1; yy > (source.height - triangleRange); yy--) {
                            for (var xx = 0; xx < (triangleRange - (source.height - yy )); xx++) {
                                source.setPixel(xx, yy, thumbMarkColor);
                            }
                        }
                    }
                    else if (thumbMarkColor == "Black") {
                        for (var yy = 0; yy < triangleRange; yy++) {
                            for (var xx = 0; xx < (triangleRange - yy); xx++) {
                                source.setPixel(xx, yy, thumbMarkColor);
                            }
                        }
                    }
                    fileThumbnail.core.quickMetadata.width = source.width;
                    fileThumbnail.core.quickMetadata.height = source.height;
                    fileThumbnail.core.icon.bitmap = source;
                    fileThumbnail.core.fullsize.fullsize = source;
                    fileThumbnail.core.thumbnail.thumbnail = source;
                    fileThumbnail.core.preview.preview = source;
                    fileThumbnail.refresh ();
                }
            }
        }
        if (app.version[0] == '6') {
            if (!tsIsShade (targetFile)) {
                if (isInDesignFile (targetFile)) {
                    var docDotID = fileID.replace (/\//g,"\.");
                    docDotID = docDotID.slice (1);
                    var openedMarkFile = new File (tsDataPath + "/Opened Documents/" + docDotID);
                    if (openedMarkFile.exists) {
                        return isLabelChanged;
                    }
                }
            }
        }
        if (isModified) {
            if (fileThumbnail.label == "Placed" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "" || fileThumbnail.label == "Need To Be Checked In") {
                var oldDate = fileThumbnail.spec.modified.getTime ();
                fileThumbnail.label = "Modified By Another Collaborator";
                fileThumbnail.refresh ();
                isLabelChanged = true;
                if (!tsIsShade (fileThumbnail.spec) && isCSFile (fileThumbnail.spec))
                    tsMarkFakeModified (oldDate, fileThumbnail.spec, fileID);
            }
        }                            
        else {
            var isUnderEditingByMe = false;
            if (versionTime) {
                var actualModified = tsGetActualModified (fileThumbnail.spec.modified.getTime (), fileID);
                if (actualModified > parseInt (versionTime, 10)) {
                    isUnderEditingByMe = true;
                }
            }
            if (isUnderEditingByMe) {
                if (fileThumbnail.label == "Placed" || fileThumbnail.label == "" || fileThumbnail.label == "Final" || fileThumbnail.label == "Modified By Another Collaborator" || fileThumbnail.label == "Current") {
                    fileThumbnail.label = "Need To Be Checked In";
                    fileThumbnail.refresh ();
                    isLabelChanged = true;
                }
            }
            else {
                var placesFolder = new Folder (tsDataPath + "/IDs" + fileID + "/Workshop/Places");
                var isPlaced = false;
                if (placesFolder.exists) {
                    var placesFiles = placesFolder.getFiles (isUnhiddenFile);
                    if (placesFiles.length > 0)
                        isPlaced = true;
                }
                if (isPlaced) {
                    if (fileThumbnail.label == "" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Need To Be Checked In"  || fileThumbnail.label == "Modified By Another Collaborator") {
                        var oldDate = fileThumbnail.spec.modified.getTime ();
                        fileThumbnail.label = "Placed";
                        fileThumbnail.refresh ();
                        isLabelChanged = true;
                        if (!tsIsShade (fileThumbnail.spec) && isCSFile (fileThumbnail.spec))
                            tsMarkFakeModified (oldDate, fileThumbnail.spec, fileID);
                    }
                }
                else if (fileThumbnail.label == "Placed" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Modified By Another Collaborator") {
                        var oldDate = fileThumbnail.spec.modified.getTime ();
                        fileThumbnail.label = "";
                        fileThumbnail.refresh ();
                        isLabelChanged = true;
                        if (!tsIsShade (fileThumbnail.spec) && isCSFile (fileThumbnail.spec))
                            tsMarkFakeModified (oldDate, fileThumbnail.spec, fileID);
                }
            }  
        }
    }
    return isLabelChanged;
}

function labelFinalPDF (targetFolder) {
    /**///$.writeln ($.line);
    var isToLoadAgain = false;
    if (!targetFolder instanceof Folder)
    return false;
    if (!targetFolder.exists)
        return false;
    allFiles = targetFolder.getFiles ("*.pdf");
    for (var c = 0; c < allFiles.length; c++) {
        var fileThumbnail = new Thumbnail (allFiles[c]);
        if (fileThumbnail.label == "") {
            var fileFullPath = allFiles[c].fsName.replace(/\\/g, '/').replace (tsFinalPDFPath, tsWorkshopPath);
            fileFullPath = fileFullPath.slice (0, fileFullPath.length - 4) + ".indd";
            var workshopFile = new File (fileFullPath);
            var isModified = false;
            if (workshopFile.exists) {
                if (allFiles[c].modified.getTime () < workshopFile.modified.getTime ())
                    isModified = true;
            }
            if (isModified) {
                if (fileThumbnail.label == "") {
                    fileThumbnail.label = "Need To Be Checked In";
                    fileThumbnail.refresh ();
                    isToLoadAgain = true;
                }
            } 
        }
    }
    return isToLoadAgain;
}

function labelPrevPDF (targetFolder) {
    /**///$.writeln ($.line);
    var isToLoadAgain = false;
    if (!targetFolder instanceof Folder)
    return false;
    if (!targetFolder.exists)
        return false;

    allFiles = targetFolder.getFiles ("*.pdf");
    for (var c = 0; c < allFiles.length; c++) {
        var fileID = tsGetID (allFiles[c]);
        if (fileID) {
            var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
            var currentDigits = null;
            var isFinal = false;
            var currentContent = readFile (currentRecordFile);
            if (currentContent) {
                currentContent = currentContent.split (":");
                currentDigits = currentContent[0];
                isFinal = currentContent[1] == "F"? true : false;
            }
            var fileDigits = File.decode (allFiles[c].name).slice (3, 5);
            var fileThumbnail = new Thumbnail (allFiles[c]);
            if (currentDigits == fileDigits) {
                var workshopFile = new File (allFiles[c].parent.fsName.replace(/\\/g, '/').replace (tsVersionsPDFPath, tsWorkshopPath) + "/" + File.decode (allFiles[c].name).slice (6, File.decode (allFiles[c].name).lastIndexOf (".")) + ".indd");
                if (workshopFile.exists) {
                    var actualModified = tsGetActualModified (workshopFile.modified.getTime (), fileID);
                    var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + fileDigits + "/Modifying Time");
                    var versionTime = readFile (versionTimeFile);
                    if (actualModified > parseInt (versionTime, 10)) {
                        if (fileThumbnail.label == "" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Modified By Another Collaborator") {
                            fileThumbnail.label = "Need To Be Checked In";
                            fileThumbnail.refresh ();
                            isToLoadAgain = true;
                        }
                        continue;
                    } 
                }
                if (isFinal) {
                    if (fileThumbnail.label == "" || fileThumbnail.label == "Current" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Modified By Another Collaborator") {
                        fileThumbnail.label = "Final";
                        fileThumbnail.refresh ();
                        isToLoadAgain = true;
                    }
                    continue;
                }
                if (fileThumbnail.label == "" || fileThumbnail.label == "Final" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Modified By Another Collaborator") {
                    fileThumbnail.label = "Current";
                    fileThumbnail.refresh ();
                    isToLoadAgain = true;
                }
            }
            else {
                if (fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Need To Be Checked In" || fileThumbnail.label == "Modified By Another Collaborator") {
                    fileThumbnail.label = "";
                    fileThumbnail.refresh ();
                    isToLoadAgain = true;
                }
            }
        }
    }
    return isToLoadAgain;
}

function labelVersions (targetFolder) {
    /**///$.writeln ($.line);
    var isToLoadAgain = false;
    if (!targetFolder instanceof Folder)
    return false;
    if (!targetFolder.exists)
        return false;
    var allFiles = targetFolder.getFiles (isUnhiddenFile);
    var isThumbnailsLoaded = false;
    var folderIndex = -1;
    for (var th = 0; th < thumbnailVersionList.length; th++) {
        if (thumbnailVersionList[th][0] == targetFolder.fsName.replace(/\\/g, '/')) {
            if (thumbnailVersionList[th][1] == allFiles.length) {
                isThumbnailsLoaded = true;
            }
            folderIndex = th;
            break;
        }
    }
    if (!isThumbnailsLoaded) {
        if (folderIndex = -1) {
            var thumbnailVersionListItem = new Array;
            thumbnailVersionListItem.push (targetFolder.fsName.replace(/\\/g, '/'));
            thumbnailVersionListItem.push (allFiles.length);
            thumbnailVersionList.push (thumbnailVersionListItem);
        }
        else {
            thumbnailVersionList[folderIndex][1] = allFiles.length;
        }
    }        
    isThumbnailsLoaded = false; // to load thumbnails much
    for (var c = 0; c < allFiles.length; c++) {
        isToLoadAgain = labelVersionFile (allFiles[c], isThumbnailsLoaded);
    }
    return isToLoadAgain;
}

function labelTreeItems (targetFolder) {
    /**///$.writeln ($.line);
    var isToLoadAgain = false;
    if (!targetFolder instanceof Folder)
    return false;
    if (!targetFolder.exists)
        return false;
    if (tsIsVersionsOutputToWorkshop) {
        var allPDFVerFiles = targetFolder.getFiles (isPDFVerFile);
        for (var apvf = 0; apvf < allPDFVerFiles.length; apvf++) {
            var pdfVerThumb = new Thumbnail (allPDFVerFiles[apvf]);
            if (pdfVerThumb.label == "Need To Be Checked In") {
                pdfVerThumb.label = "";
                pdfVerThumb.refresh ();
            }
        }
    }
    var allFiles = targetFolder.getFiles (isAcceptedFile);
    var isThumbnailsLoaded = false;
    var folderIndex = -1;
    for (var th = 0; th < thumbnailList.length; th++) {
        if (thumbnailList[th][0] == targetFolder.fsName.replace(/\\/g, '/')) {
            if (thumbnailList[th][1] == allFiles.length) {
                isThumbnailsLoaded = true;
            }
            folderIndex = th;
            break;
        }
    }
    if (!isThumbnailsLoaded) {
        if (folderIndex = -1) {
            var thumbnailListItem = new Array;
            thumbnailListItem.push (targetFolder.fsName.replace(/\\/g, '/'));
            thumbnailListItem.push (allFiles.length);
            thumbnailList.push (thumbnailListItem);
        }
        else {
            thumbnailList[folderIndex][1] = allFiles.length;
        }
    }
    isThumbnailsLoaded = false; //To load thumbnails much
    var shadeThumb = [null];
    for (var c = 0; c < allFiles.length; c++) {
        isToLoadAgain = labelWorkshopFile (allFiles[c], shadeThumb, isThumbnailsLoaded);
    }
    return isToLoadAgain;
}

function tsGetActualModified (modified, fileID) {
    /**///$.writeln ($.line);
    var fakeDateFile = new File (tsDataPath + "/IDs" + fileID + "/Workshop/FakeDate");
    if (fakeDateFile.exists) {
        var fakeDate = readFile (fakeDateFile);
        if (modified.toString () == fakeDate) {
            var beforeFakeFile = new File (tsDataPath + "/IDs" + fileID + "/Workshop/BeforeFake");
            var beforeFakeDate = readFile (beforeFakeFile);
            if (beforeFakeDate) {
                return parseInt (beforeFakeDate, 10);
            }
            else {
                return modified;
            }
        }
        else {
            fakeDateFile.remove ();
            var beforeFakeFile = new File (tsDataPath + "/IDs" + fileID + "/Workshop/BeforeFake");
            beforeFakeFile.remove ();
            return modified;
        }
    }
    else
        return modified;
}

function tsGetText (theLabelArr, theOldText, isMultiLine) {
    /*
    Code for Import https://scriptui.joonas.me — (Triple click to select): 
    {"activeId":0,"items":{"item-0":{"id":0,"type":"Dialog","parentId":false,"style":{"text":"Import Multiple PDF pages","preferredSize":[0,0],"margins":16,"orientation":"column","spacing":10,"alignChildren":["left","top"],"varName":null,"windowType":"Dialog","creationProps":{"su1PanelCoordinates":false,"maximizeButton":false,"minimizeButton":false,"independent":false,"closeButton":true,"borderless":false,"resizeable":false},"enabled":true}},"item-1":{"id":1,"type":"Panel","parentId":20,"style":{"text":"Page Selection","preferredSize":[0,99],"margins":10,"orientation":"column","spacing":10,"alignChildren":["left","top"],"alignment":null,"varName":null,"creationProps":{"borderStyle":"etched","su1PanelCoordinates":false},"enabled":true}},"item-3":{"id":3,"type":"EditText","parentId":6,"style":{"text":"1","preferredSize":[600,0],"alignment":null,"varName":null,"helpTip":null,"softWrap":false,"creationProps":{"noecho":false,"readonly":false,"multiline":false,"scrollable":false,"borderless":false,"enterKeySignalsOnChange":false},"enabled":true,"justify":"left"}},"item-4":{"id":4,"type":"StaticText","parentId":1,"style":{"text":"To edit long text use\n<a href = 'http://docs.google.com/?action=newdoc'>Google New Document</a>","justify":"left","preferredSize":[0,0],"alignment":null,"varName":null,"helpTip":null,"softWrap":true,"creationProps":{"truncate":"none","multiline":true,"scrolling":false},"enabled":true}},"item-6":{"id":6,"type":"Group","parentId":1,"style":{"preferredSize":[0,0],"margins":0,"orientation":"row","spacing":10,"alignChildren":["left","center"],"alignment":null,"varName":null,"enabled":true}},"item-20":{"id":20,"type":"Group","parentId":0,"style":{"preferredSize":[0,0],"margins":0,"orientation":"column","spacing":10,"alignChildren":["fill","top"],"alignment":null,"varName":null,"enabled":true}},"item-36":{"id":36,"type":"Group","parentId":0,"style":{"preferredSize":[0,0],"margins":0,"orientation":"row","spacing":10,"alignChildren":["left","top"],"alignment":null,"varName":null,"enabled":true}},"item-37":{"id":37,"type":"Button","parentId":36,"style":{"text":"OK","justify":"center","preferredSize":[0,0],"alignment":null,"varName":"ok","helpTip":null,"enabled":true}},"item-38":{"id":38,"type":"Button","parentId":36,"style":{"text":"Cancel","justify":"center","preferredSize":[0,0],"alignment":null,"varName":"cancel","helpTip":null,"enabled":true}}},"order":[0,20,1,6,3,4,36,37,38],"settings":{"importJSON":true,"indentSize":false,"cepExport":false,"includeCSSJS":true,"functionWrapper":false,"compactCode":false,"showDialog":true,"itemReferenceList":"None"}}
    */ 

    // DIALOG
    // ======
    var dialog = new Window("dialog"); 
        dialog.text = "Tree Shade"; 
        dialog.orientation = "column"; 
        dialog.alignChildren = ["left","top"]; 
        dialog.spacing = 10; 
        dialog.margins = 16; 

    // GROUP1
    // ======
    var group1 = dialog.add("group", undefined, {name: "group1"}); 
        group1.orientation = "column"; 
        group1.alignChildren = ["fill","top"]; 
        group1.spacing = 10; 
        group1.margins = 0; 
    var staticText = group1.add('edittext {properties: {name: "edittext1", readonly: true, multiline: true, scrollable: true}}');
    staticText.preferredSize.width = 600; 
    staticText.preferredSize.height = (15 * theLabelArr.length) + 10;
    if (staticText.preferredSize.height > 200) {
        staticText.preferredSize.height = 200;
    }
    for (var tla = 0; tla < theLabelArr.length; tla++) {
        staticText.text += theLabelArr[tla];
        if (tla < theLabelArr.length - 1) {
            staticText.text += "\n";
        }
    }
    if (isMultiLine) {
        tsEditText = group1.add('edittext {properties: {name: "tsEditText", multiline: true, scrollable: true}}');
        tsEditText.preferredSize.width = 600;
        tsEditText.preferredSize.height = 100;
    }
    else {
        tsEditText = group1.add('edittext {properties: {name: "tsEditText"}}');
        tsEditText.preferredSize.width = 600;
    }
    tsEditText.text = theOldText; 
    tsEditText.addEventListener ('focus', edtActivate, false);
    function edtActivate () {
        if (tsTextEditorOpened) {
            //app.document.chooseMenuItem("mondo/command/paste");
        }
        else {
            //app.document.chooseMenuItem("mondo/command/selectAll");
        }
    }

    // GROUP2
    // ======
    var group2 = dialog.add("group", undefined, {name: "group2"}); 
    group2.orientation = "row"; 
    group2.alignChildren = ["fill","top"]; 
    group2.spacing = 10; 
    group2.margins = 0; 

    var group3 = group2.add("group", undefined, {name: "group3"}); 
    group3.orientation = "column"; 
    group3.alignChildren = ["left","top"]; 
    group3.spacing = 10; 
    group3.margins = 0; 
    if (isMultiLine) {
        var button0 = group3.add("button", undefined, undefined, {name: "button0"}); 
        button0.text = "Text Editor"; 
        button0.onClick = function() {
            var textEditorFile = new File (tsDataPath + "/Text Editor.htm");
            if (textEditorFile) {
                //app.document.chooseMenuItem("mondo/command/copy");
                var toOpenThumbnail = new Thumbnail (textEditorFile);
                toOpenThumbnail.open ();
                tsTextEditorOpened = true;
            }
        };
    }
    dialog.addEventListener ('focus', dlgActivate, false);
    function dlgActivate () {
        if (tsTextEditorOpened) {
            tsTextEditorOpened = false;
        }
        else {
            
        }
        tsEditText.active = true;
    }

    var group4 = group2.add("group", undefined, {name: "group4"}); 
    group4.orientation = "column"; 
    group4.alignChildren = ["fill","top"]; 
    group4.spacing = 10;
    group4.margins = 0;

    var group5 = group4.add("group", undefined, {name: "group5"}); 
    group5.orientation = "row"; 
    group5.alignChildren = ["right","top"]; 
    group5.spacing = 10;
    group5.margins = 0;

    var statictext2 = group5.add("statictext", undefined, "", {name: "statictext2"});
    statictext2.preferredSize.width = 230;
    var button1 = group5.add("button", undefined, undefined, {name: "button1"}); 
    button1.text = "Cancel"; 
    button1.onClick = function() {
        this.parent.parent.parent.parent.close(null);
    };

    var button2 = group5.add("button", undefined, undefined, {name: "button2"}); 
    if (isMultiLine) {
        button2.text = "OKAY";
    }
    else {
        button2.text = "OK";
    }
    button2.preferredSize.width = 100;
    button2.onClick = function() {
        this.parent.parent.parent.parent.close(1);
    }; 

    var showResult = dialog.show();
    if (showResult == 1) {
        return tsEditText.text;
    }
    else {
        return null;
    }
}

function tsGetOption(theLabelArr, theBtnArr) {
    var dialog = new Window("dialog"); 
    dialog.text = "Tree Shade"; 
    dialog.orientation = "column"; 
    dialog.alignChildren = ["left", "top"]; 
    dialog.spacing = 10; 
    dialog.margins = 16; 

    var group1 = dialog.add("group"); 
    group1.orientation = "column"; 
    group1.alignChildren = ["fill", "top"]; 
    group1.spacing = 10; 
    group1.margins = 0; 

    var staticText = group1.add('edittext', undefined, '', { readonly: true, multiline: true, scrollable: true });
    staticText.preferredSize.width = 600; 
    staticText.preferredSize.height = Math.min(200, (15 * theLabelArr.length) + 10);
    staticText.text = theLabelArr.join("\n");

    var group2 = dialog.add("group"); 
    group2.orientation = "row"; 
    group2.alignChildren = ["fill", "top"]; 
    group2.spacing = 10; 
    group2.margins = 0; 

    var buttonIndex = 0; // Default to 0 if no button is clicked

    for (var i = 0; i < theBtnArr.length; i++) {
        (function(index) {
            var button = group2.add("button", undefined, theBtnArr[index]);
            button.onClick = function() {
                buttonIndex = index + 1; // Return 1-based index
                dialog.close();
            };
        })(i);
    }

    dialog.show();
    return buttonIndex; 
}

function tsMarkFakeModified (oldDate, file, fileID) {
    /**///$.writeln ($.line);
    for (var c = tsOldModifiedFileIDList.length - 1; c >= 0; c--) {
        if (tsOldModifiedFileIDList[c][2] == fileID) {
            tsOldModifiedFileIDList.splice (c, 1);
            break;
        }
    }
    //oldModified_File_ID
    //oldModified_File_ID[0] old date
    //oldModified_File_ID[1] file object
    //oldModified_File_ID[2] file ID
    //oldModified_File_ID[3] counter
    var oldModified_File_ID = new Array;
    oldModified_File_ID.push (oldDate);
    oldModified_File_ID.push (file);
    oldModified_File_ID.push (fileID);
    oldModified_File_ID.push (0);
    tsOldModifiedFileIDList.push (oldModified_File_ID);
    return true;
}

function tsIsNeedCheckIn (targetFile, fileID) {
    if (!fileID) {
        fileID = tsGetID (targetFile);
    }
    if (!fileID) {
        return false;
    }
    if (fileID) {
        var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
        var currentVersion = readFile (currentRecordFile);
        var isToSkip = false;
        for (var om = 0; om < tsOldModifiedFileIDList.length; om++) {
            if (tsOldModifiedFileIDList[om][2] == fileID) {
                isToSkip = true;
                break;
            }
        }
        if (isToSkip) {
            if (!currentVersion) {
                return "new";
            }
            return false;
        }

        var versionTime = null;
        if (currentVersion) {
            currentVersion = currentVersion.split (":")[0];
            var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/Modifying Time");
            versionTime = readFile (versionTimeFile);
            if (versionTime) {
                var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/V/" + versionTime + "/UnderEditingByOther");
                if (underEditingByOtherFile.exists) {
                    return false;
                }
            }
        }
        if (versionTime) {
            var actualModified = tsGetActualModified (targetFile.modified.getTime (), fileID);
            if (actualModified > parseInt (versionTime, 10)) {
                return versionTime;
            }
        }
        else {
            return "new";
        }
    }
    return false;
}

function addToTreeEmptyFoldersList (newTreeEmptyPath) {
    if (newTreeEmptyPath == "")
        return false;
    var isExist = false;
    for (var eft = 0; eft < emptyFoldersList[0].length; eft++) {
        if (newTreeEmptyPath == emptyFoldersList[0][eft]) {
            isExist = true;
            break;
        }
    }
    if (!isExist) {
        emptyFoldersList[0].push (newTreeEmptyPath);
        return true;
    }
    return false;
}

function addToNonTreeEmptyFoldersList (newNonTreeEmptyPath) {
    var isExist = false;
    for (var efn = 0; efn < emptyFoldersList[1].length; efn++) {
        if (newNonTreeEmptyPath == emptyFoldersList[1][efn]) {
            isExist = true;
            break;
        }
    }
    if (!isExist) {
        emptyFoldersList[1].push (newNonTreeEmptyPath);
        return true;
    }
    return false;
}

onClosingApp = function(event) {
    /**///$.writeln ($.line);
    if(event.object instanceof App && event.type == "close") {  
        closingRequested = true; 
        if (okNowYouCanQuit) {
            return { handled: false};
        }
        else {
            return { handled: true};
        }
    }
}

function main () { 
    /**///$.writeln ($.line);
    if ($.os.indexOf ("Macintosh OS") == 0)
        tsIsMacOS = true;

    tsClientID = Folder.desktop.parent.fsName.replace(/\\/g, '/').slice (Folder.desktop.parent.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    if (tsClientID == "OneDrive") {
        tsClientID = Folder.desktop.parent.parent.fsName.replace(/\\/g, '/').slice (Folder.desktop.parent.parent.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    }
    tsMainTaskID = app.scheduleTask ("tsMainTask();", tsMainInterval, true);
    app.eventHandlers.push({handler: onClosingApp});
    app.eventHandlers.push({handler: onPref});
    app.eventHandlers.push({handler: onLoaded});
    app.eventHandlers.push({handler: onOpenFolder});
}

function tsFillZerosIfAllDigits (digits, digitsCount) {
    /**///$.writeln ($.line);
    for (var d = 0; d < digits.length; d++) {
        if (digits.charCodeAt (d) < 48 || digits.charCodeAt (d) > 57)
            return digits;
    }
	while (digits.length < digitsCount)
		digits = "0" + digits;
	return digits;
}

function tsFillZeros (number, digitsCount) {
	var digits = number.toString();
	while (digits.length < digitsCount)
		digits = "0" + digits;
	return digits;
}

function moveSelectedToTrash () {
    /**///$.writeln ($.line);
    if (tsTrashPath == "") {
        alert ("Set the trash path from Bridge Preferences in Tree Shade page.");
        return false;
    }
    if (!Folder (tsTrashPath).exists) {
        alert ("Couldn't reach the trash folder.");
        return false;
    }
    if (confirm ("Cancel Moving to Trash?"))
        return false;
    var trashRequests = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        trashRequests.push (app.document.selections[c]);
    }
    var usedFilesList = new Array;
    var unusedFilesList = new Array;
    var InDesignTwinList = new Array;
    var folders = new Array;
    for (var t = 0; t < trashRequests.length; t++) {
        getInDesignFiles (trashRequests[t].spec, InDesignTwinList);
        if (trashRequests[t].container) {
            folders.push (trashRequests[t].spec);
        }
    }
    for (var i = trashRequests.length - 1; i >= 0; i--) {
        var folderParent = trashRequests[i].spec.parent;
        var treeOrVersionOrOut;
        if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath != "")
            treeOrVersionOrOut = 1;
        else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "")
            treeOrVersionOrOut = 2;
        else
            treeOrVersionOrOut = 3;
        getUsedFiles (trashRequests[i].spec, InDesignTwinList, usedFilesList, unusedFilesList, treeOrVersionOrOut);
    }
    var isAll = true;
    if (usedFilesList.length > 0) {
        var message = "";
        var answer = -1;
        if (trashRequests.length == 1 && !trashRequests[0].container) {
            message = "This file is placed in documnets' pages. Are you sure you want to delete?";
            answer = confirm (message);
        }
        else {
            message = ["These files are used in documents:"];
            message.push ("");
            for (var u = 0; u < usedFilesList.length; u++) {
                var baseFolder;
                switch (usedFilesList[u][1]) {
                    case 1:
                        baseFolder = "..." + tsWorkshopPath.slice (tsWorkshopPath.lastIndexOf ("/"));
                        message.push (baseFolder + usedFilesList[u][0].fsName.replace(/\\/g, '/').replace(tsWorkshopPath, ""));
                        break;
                    case 2:
                        baseFolder = "..." + tsVersionsPath.slice (tsVersionsPath.lastIndexOf ("/"));
                        message.push (baseFolder + usedFilesList[u][0].fsName.replace(/\\/g, '/').replace(tsVersionsPath, ""));
                        break;
                    default:
                        baseFolder = "";
                        message.push (baseFolder + usedFilesList[u][0].fsName.replace(/\\/g, '/'));
                        break;
                }
            }
        }
        if (answer == -1) {
            var btnArr = [
                "Trash All",
                "Trash Only Unused",
                "Cancel"
            ];
            answer = tsGetOption (message, btnArr);
            if (answer == 2)
                isAll = false;
            else if (answer != 1)
                return false;
        }
        else {
            if (!answer) {
                return false;
            }
        }
    }
    var isWithPairedArrayCell = [null];
    for (var t = 0; t < unusedFilesList.length; t++) {
        tsMoveToTrash (unusedFilesList[t][0], unusedFilesList[t][1], null, true, null, isWithPairedArrayCell);
    }
    if (isAll) {
        for (var m = 0; m < usedFilesList.length; m++) {
            tsMoveToTrash (usedFilesList[m][0], usedFilesList[m][1], null, true, null, isWithPairedArrayCell);
        }
    }
    for (var v = 0; v < folders.length; v++) {
        var treeOrVersionOrOut;
        if ((folders[v].fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath != "")
            treeOrVersionOrOut = 1;
        else if ((folders[v].fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "")
            treeOrVersionOrOut = 2;
        else
            treeOrVersionOrOut = 3;
        if (treeOrVersionOrOut == 1) {
            addToTreeEmptyFoldersList (folders[v].fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""));
        }
        else if (treeOrVersionOrOut == 2) {
            if (tsFinalPDFPath != "")
                addToNonTreeEmptyFoldersList (folders[v].fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsFinalPDFPath));
            if (tsPagesPath != "")
                addToNonTreeEmptyFoldersList (folders[v].fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages));
            if (tsVersionsPDFPath != "")
                addToNonTreeEmptyFoldersList (folders[v].fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPDFPath));
        }
        else
            addToNonTreeEmptyFoldersList (folders[v].fsName.replace(/\\/g, '/'));
    }
}

function tsMoveToTrash (folderOrFile , treeOrVersionOrOut, directPath, isUser, fileID, isWithPairedPara) { //treeOrVersionOrOut : 1, 2, 3
    /**///$.writeln ($.line);
    var isWithPaired = false;
    if (isWithPairedPara instanceof Array) {
        isWithPaired = isWithPairedPara[0];
    }
    else {
        isWithPaired = isWithPairedPara;
    }
    if (folderOrFile instanceof Folder) {
        var allFolders = folderOrFile.getFiles (isUnhiddenFolder);
        for (var f = 0; f < allFolders.length; f++) {
            tsMoveToTrash (allFolders[f], treeOrVersionOrOut, directPath, isUser, fileID, false);
        }
        var allFiles = folderOrFile.getFiles (isAcceptedFile);
        for (var c = 0; c < allFiles.length; c++) {
            tsMoveToTrash (allFiles[c], treeOrVersionOrOut, directPath, isUser, fileID, false);
        }
    }
    else {
        if (folderOrFile.exists) {
            folderOrFile.readonly = false;
            if (!fileID) {
                fileID = tsGetID (folderOrFile);
            }
        }
        if (!fileID) {
            var shadeFile = new File (folderOrFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsDataPath + "/Shades"));
            if (shadeFile.exists) {
                fileID = tsGetID (shadeFile);
            }
        }
        var baseFolder = "";
        var relativePath = folderOrFile.parent.fsName.replace(/\\/g, '/');
        var fileName = File.decode (folderOrFile.name);
        var fileExtension = fileName.lastIndexOf (".") != -1? fileName.slice (fileName.lastIndexOf (".")) : "";
        var absoluteName = fileName.lastIndexOf (".") != -1? fileName.slice (0, fileName.lastIndexOf (".")) : fileName;
        if (treeOrVersionOrOut == 1) {
            //Paired Folder
            if (isWithPaired !== false) {
                var pairedFolderName = tsGetPureName (File.decode (folderOrFile.name), false);
                var expectedFolder = new Folder (folderOrFile.parent.fsName.replace(/\\/g, '/') + "/" + pairedFolderName);
                if (expectedFolder.exists) {
                    if (isWithPaired == null && isWithPairedPara instanceof Array) {
                        isWithPairedPara[0] = confirm ("Move the Paired Folder to trash?");
                        isWithPaired = isWithPairedPara[0];
                    }
                    if (isWithPaired) {
                        var filesList = new Array;
                        retrieveFilesList (expectedFolder, filesList, false, []);
                        if (filesList.length > 0) {
                            for (var fl = 0; fl < filesList.length; fl++) {
                                tsMoveToTrash (filesList[fl] , treeOrVersionOrOut, ":TRASH", isUser, null, false);
                            }
                        }
                    }
                }
            }
            baseFolder = tsWorkshopPath.slice (tsWorkshopPath.lastIndexOf ("/"));
            relativePath = relativePath.replace (tsWorkshopPath, "");
            if (fileID) {                    
                //check 
                for (var ap = tsIDTimePathStepIsUserOldPathList.length - 1; ap >= 0; ap--) {
                    if (tsIDTimePathStepIsUserOldPathList[ap][0] == fileID) {
                        return false;
                    }
                }
                
                var newTime = new Date ().getTime ();
                if (!directPath) {
                    directPath = ":TRASH";
                }
                var IDTimePathStepIsUserOldPath = new Array;
                IDTimePathStepIsUserOldPath.push (fileID);
                IDTimePathStepIsUserOldPath.push (newTime);
                IDTimePathStepIsUserOldPath.push (directPath);
                IDTimePathStepIsUserOldPath.push (-1);
                IDTimePathStepIsUserOldPath.push (isUser);
                IDTimePathStepIsUserOldPath.push (relativePath + "/" + fileName);
                tsIDTimePathStepIsUserOldPathList.push (IDTimePathStepIsUserOldPath);
                tsChangePath (fileID, directPath, newTime);
                if (fileExtension == ".indd") {
                    removeLinksRelations (fileID, null);
                }
            }
            //move Tree file
            var idThumbFile = new File (tsWorkshopPath + relativePath + tsGetTreeShadeThumb (fileName) + fileName + ".jpg");
            if (idThumbFile.exists) {
                idThumbFile.remove ();                    
            }
            if (folderOrFile.exists) {
                if (tsIsShade (folderOrFile)) {
                    folderOrFile.readonly = false;
                    folderOrFile.remove ();
                }
                else {
                    var obstacleFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + fileExtension);
                    var d = 0;
                    while (obstacleFile.exists) {
                        d++;
                        obstacleFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + d + fileExtension);
                    }
                    var dStr = "";
                    if (d != 0) {
                        dStr = d.toString ();
                        var toRenameFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + fileExtension);
                        toRenameFile.rename (absoluteName + dStr + fileExtension);
                    }
                    var destinationFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + fileExtension);
                    if (!destinationFile.parent.exists)
                        destinationFile.parent.create ();
                    if (!isCSFile (folderOrFile)) {
                        var idFile = new File (folderOrFile.parent.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + File.decode (folderOrFile.name));
                        var destinationIdFile = File (tsTrashPath + baseFolder + relativePath + "/.TREESHADE/" + absoluteName + dStr + fileExtension);
                        if (!destinationIdFile.parent.exists)
                            destinationIdFile.parent.create ();
                        idFile.copy (destinationIdFile);
                    }
                    try {
                        var fileThumbnail = new Thumbnail (folderOrFile);
                        fileThumbnail.moveTo (destinationFile.parent);
                    }
                    catch (e) {
                        return false;
                    }
                }
            }
            addToTreeEmptyFoldersList (relativePath);
            
            //move Versions files
            if (tsVersionsPath != "") {
                var versionsParentFolder = new Folder (tsVersionsPath + relativePath);
                var versionsFiles = versionsParentFolder.getFiles ("ver?? " + fileName);
                baseFolder = tsVersionsPath.slice (tsVersionsPath.lastIndexOf ("/"));
                for (var v = 0; v < versionsFiles.length; v++) {
                    versionsFiles[v].readonly = false;
                    if (tsIsShade (versionsFiles[v])) {
                        versionsFiles[v].remove ();
                    }
                    else {
                        var versionPrefix = File.decode (versionsFiles[v].name).slice (0, 5);
                        destinationFile = new File (tsTrashPath + baseFolder + relativePath + "/" + versionPrefix + " " + absoluteName + fileExtension);
                        obstacleFile = new File (tsTrashPath + baseFolder + relativePath + "/" + versionPrefix + " " + absoluteName + fileExtension);
                        d = 0;
                        while (obstacleFile.exists) {
                            d++;
                            obstacleFile = new File (tsTrashPath + baseFolder + relativePath + "/" + versionPrefix + " " + absoluteName + d + fileExtension);
                        }
                        if (d != 0) {
                            File (tsTrashPath + baseFolder + relativePath + "/" + versionPrefix + " " + absoluteName + fileExtension).rename (File.decode (obstacleFile.name));
                        }
                        var versionThumbnail = new Thumbnail (versionsFiles[v]);
                        if (!destinationFile.parent.exists)
                            destinationFile.parent.create ();
                        try {
                            versionThumbnail.moveTo (destinationFile.parent);
                        }
                        catch (e) {}
                    }
                }
            }
            if (fileExtension == ".indd") {
                if (fileExtension == ".indd" && fileID) {
                    removeLinksRelations (fileID, null);
                }
                //move FinalPDF files
                if (tsFinalPDFPath != "") {
                    baseFolder = tsFinalPDFPath.slice (tsFinalPDFPath.lastIndexOf ("/"));
                    var finalPDFFile = new File (tsFinalPDFPath + relativePath + "/" + absoluteName + ".pdf");
                    if (finalPDFFile.exists) {
                        finalPDFFile.readonly = false;
                        finalPDFFile.remove ();
                    }
                }
                //move Preview files
                if (tsVersionsPDFPath != "") {
                    var previewsParentFolder = new Folder (tsVersionsPDFPath + relativePath);
                    var previewsFiles = previewsParentFolder.getFiles ("ver?? " + absoluteName + ".pdf");
                    for (var p = 0; p < previewsFiles.length; p++) {
                        previewsFiles[p].readonly = false;
                        previewsFiles[p].remove ();
                    }
                }
                //move Pages files
                if (tsPagesPath != "") {
                    var pagesParentFolder = new Folder (tsVersionsPages + relativePath);
                    var pagesFolders = pagesParentFolder.getFiles ("ver?? " + absoluteName);
                    for (var p = 0; p < pagesFolders.length; p++) {
                        deleteForcelyFolders (pagesFolders[p], true);
                    }
                    var workingPagesFolder = new Folder (tsPagesPath + "/Workshop" + relativePath + "/" + absoluteName + fileExtension);
                    deleteForcelyFolders (workingPagesFolder, true);
                }
            }
        }
        else if (treeOrVersionOrOut == 2) {
            baseFolder = tsVersionsPath.slice (tsVersionsPath.lastIndexOf ("/"));
            relativePath = relativePath.replace (tsVersionsPath, "");
            //cancel if current version
            if (fileID) {
                var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                var currentContent = readFile (currentRecordFile);
                if (currentContent) {
                    currentContent = currentContent.split (":")[0];
                }
                if (currentContent == absoluteName.slice (3, 5))
                    return false;
            }          
            //move version file
            if (folderOrFile.exists) {
                var destinationFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + fileExtension);
                var obstacleFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + fileExtension);
                var d = 0;
                while (obstacleFile.exists) {
                    d++;
                    obstacleFile = new File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + d + fileExtension);
                }
                if (d != 0) {
                    File (tsTrashPath + baseFolder + relativePath + "/" + absoluteName + fileExtension).rename (File.decode (obstacleFile.name));
                }
                if (!destinationFile.parent.exists)
                    destinationFile.parent.create ();
                var fileThumbnail = new Thumbnail (folderOrFile);
                fileThumbnail.moveTo (destinationFile.parent);
            }

            var versionPrefix = fileName.slice (0, 5);
            if (fileExtension == ".indd") {
                removeLinksRelations (fileID, versionPrefix);

                //move preview files
                if (tsVersionsPDFPath != "") {
                    //baseFolder = tsVersionsPDFPath.slice (tsVersionsPDFPath.lastIndexOf ("/"));
                    var previewFile = new File (tsVersionsPDFPath + relativePath + "/" + absoluteName + ".pdf");
                    if (previewFile.exists) {
                        previewFile.remove ();
                        addToNonTreeEmptyFoldersList (tsVersionsPDFPath + relativePath);
                    }
                }
            
                //move versions pages
                if (tsPagesPath != "") {
                    var pagesFolder = new Folder (tsVersionsPages + relativePath + "/" + absoluteName);
                    if (pagesFolder.exists) { 
                        var allpagesFiles = pagesFolder.getFiles ();
                        for (var i = 0; i < allpagesFiles.length; i++) {
                            allpagesFiles[i].remove ();
                        }
                        addToNonTreeEmptyFoldersList (tsVersionsPages + relativePath);
                    }
                }
            }
        }
        else if (treeOrVersionOrOut == 3 && folderOrFile.exists) {
            var destinationFile = new File (tsTrashPath + relativePath + "/" + absoluteName + fileExtension);
            var obstacleFile = new File (tsTrashPath + relativePath + "/" + absoluteName + fileExtension);
            var d = 0;
            while (obstacleFile.exists) {
                d++;
                obstacleFile = new File (tsTrashPath + relativePath + "/" + absoluteName + d + fileExtension);
            }
            if (d != 0) {
                File (tsTrashPath + relativePath + "/" + absoluteName + fileExtension).rename (File.decode (obstacleFile.name));
            }
            if (!destinationFile.parent.exists)
                destinationFile.parent.create ();
            var fileThumbnail = new Thumbnail (folderOrFile);
            fileThumbnail.moveTo (destinationFile.parent);   
            addToNonTreeEmptyFoldersList (relativePath);
        }
    }
}

function tsGetPureName (pureName, isToRemoveID) {
    if (pureName.indexOf (".") != -1) {
        pureName = pureName.slice (0, pureName.lastIndexOf ("."));
    }
    var testName = pureName;
    testName = pureName.replace (/\s*\[[^\]]*\]\s*/g, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    testName = pureName.replace (/(\s?)(ts)(_\w+)+/g, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    if (isToRemoveID) {
        testName = pureName.replace (/^ID[A-Z0-9]+\s*/, "");
        if (testName == '') {
            return pureName;
        }
        else {
            pureName = testName;
        }
    }
    testName = pureName.replace (/^-\s*/, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    return pureName;
}

function getPackageLinks (fileID, versionPrefix, versionTime) {
    /**///$.writeln ($.line);
    var versionLinksReportFile = new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/V/" + versionTime + "/LinksReport");    
    var versionFullDotID = fileID.replace (/\//g,"\.");
    versionFullDotID = versionFullDotID.slice (1);
    versionFullDotID = versionFullDotID + "." + versionPrefix + "." + versionTime;
    var linksReportFileContent = readFile (versionLinksReportFile);
    var linksReportList = new Array;
    if (linksReportFileContent) {
        linksReportList = linksReportFileContent.split ("\n");
    }
    var packageLinks = "";
    if (linksReportList.length > 0) {   
        packageLinks = linksReportList[0];
        for (var p = 1; p < linksReportList.length; p++) {
            var docVerRefFile = new File (tsDataPath + "/IDs" + linksReportList[p] + "/Places/" + versionFullDotID);
            var linkPages = readFile (docVerRefFile);
            linkPages = linkPages.split ("\n");
            linkPages = linkPages.join (":");
            packageLinks += "\n" + linksReportList[p] + ":" + linkPages;
        }
    }
    return packageLinks;
}

function tsCheckInLinksRelations (fileID, versionPrefix, currentTime, linksReportList) {
    /**///$.writeln ($.line);
    var packageLinks = tsUserID;
    var docID = fileID.replace (/\//g,"\.");
    docID = docID.slice (1);
    linksReportList.splice (0, 1);
    var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/Modifying Time");
    var versionTime = readFile (versionTimeFile);
    var versionLinksReportFile = new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/V/" + versionTime + "/LinksReport");
    var versionLinksReportFileContent = readFile (versionLinksReportFile);
    var versionLinksReportList = new Array;
    if (versionLinksReportFileContent) {
        versionLinksReportList = versionLinksReportFileContent.split ("\n");
        versionLinksReportList.splice (0, 1);
    }
    //remove old links from places folders
    for (var e = versionLinksReportList.length-1; e >= 0; e--) {
        var docVerRefFile = new File (tsDataPath + "/IDs" + versionLinksReportList[e] + "/Places/" + docID + "." + versionPrefix + "." + versionTime);
        docVerRefFile.remove ();
    }
    var newVersionLinksReportContent = tsUserID;
    //marking new links on places folders
    for (var p = 0; p < linksReportList.length; p++) {
        var linkVersionRecordFile = new File (tsDataPath + "/IDs" + linksReportList[p] + "/CV");
        var linkVersion = readFile (linkVersionRecordFile);
        linkVersion = !linkVersion? "01" : linkVersion.split (":")[0];
        newVersionLinksReportContent += "\n" + linksReportList[p] + "/ver" + linkVersion;
        var docVerRefFile = new File (tsDataPath + "/IDs" + linksReportList[p] + "/ver" + linkVersion + "/Places/" + docID + "." + versionPrefix + "." + currentTime);
        var docRefFile = new File (tsDataPath + "/IDs" + linksReportList[p] + "/Workshop/Places/" + docID);
        var linkPages = readFile (docRefFile);
        linkPages = linkPages.split ("\n");
        linkPages = linkPages.join (":");
        packageLinks += "\n" + linksReportList[p] + "/ver" + linkVersion + ":" + linkPages;
        if (!docVerRefFile.parent.exists)
            docVerRefFile.parent.create ();
        docRefFile.copy (docVerRefFile);
    }
    var newVersionLinksReportFile = new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/V/" + currentTime + "/LinksReport");
    if (!newVersionLinksReportFile.parent.exists)
        newVersionLinksReportFile.parent.create ();
    writeFile (versionLinksReportFile, newVersionLinksReportContent);
    return packageLinks;
}

function removeLinksRelations (fileID, versionPrefix) {
    /**///$.writeln ($.line);
    var linksReportFile;
    var versionTime;
    if (!versionPrefix) {
        linksReportFile = new File (tsDataPath + "/IDs" + fileID + "/Workshop/LinksReport");
    }
    else {
        versionTime = readFile (new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/Modifying Time"));
        linksReportFile = new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/V/" + versionTime + "/LinksReport");
    }
    var linksReportFileContent = readFile (linksReportFile);
    if (!linksReportFileContent)
        return false;
    var linksReportLines = linksReportFileContent.split ("\n");
    linksReportFile.remove ();
    var docID = fileID.replace (/\//g,"\.");
    if (versionPrefix)
        docID = docID + "." + versionPrefix + "." + versionTime;
    docID = docID.slice (1);
    if (versionPrefix) {
        for (var i = 1; i < linksReportLines.length; i++) {
            var docReferenceFile = new File (tsDataPath + "/IDs" + linksReportLines[i] + "/Places/" + docID);
            docReferenceFile.remove ();
        }
    }
    else {
        for (var i = 1; i < linksReportLines.length; i++) {
            var docReferenceFile = new File (tsDataPath + "/IDs" + linksReportLines[i] + "/Workshop/Places/" + docID);
            docReferenceFile.remove ();
        }
    }
}

function getInDesignFiles (targetFolderOrFile, FileIDTwinList) {
    /**///$.writeln ($.line);
    if (targetFolderOrFile instanceof Folder) {
        var allFoldersAndFiles = targetFolderOrFile.getFiles (isInDesignOrAcceptedFolder);
        for (var c = 0; c < allFoldersAndFiles.length; c++) {
            getInDesignFiles (allFoldersAndFiles[c], FileIDTwinList);
        }
    }
    else {
        if (isInDesignFile (targetFolderOrFile)) {
            var fileID = tsGetID (targetFolderOrFile);
            if (fileID) {
                var docID = fileID.replace (/\//g,"\.");
                docID = docID.slice (1);
                if (File.decode (targetFolderOrFile.name).slice (0, 3) == "ver")
                    docID += "." + File.decode (targetFolderOrFile.name).slice (0, 5);
                var FileIDTwin = new Array;
                FileIDTwin.push (targetFolderOrFile);
                FileIDTwin.push (docID);
                FileIDTwinList.push (FileIDTwin);
                return true;
            }
        }
    }
    return false;
}

function getUsedFiles (targetFolderOrFile, InDesignTwinList, usedFilesList, unusedFilesList, treeOrVersionOrOut) {
    /**///$.writeln ($.line);
    if (targetFolderOrFile instanceof Folder) {
        var allFoldersAndFiles = targetFolderOrFile.getFiles (isAcceptedFileOrFolder);
        for (var c = 0; c < allFoldersAndFiles.length; c++) {
            getUsedFiles (allFoldersAndFiles[c], InDesignTwinList, usedFilesList, unusedFilesList, treeOrVersionOrOut);
        }
    }
    else {
        if (treeOrVersionOrOut != 3) {
            var fileID = tsGetID (targetFolderOrFile);
            if (fileID) {
                var placesFolder;
                if (treeOrVersionOrOut == 1) {
                    placesFolder = new Folder (tsDataPath + "/IDs" + fileID + "/Workshop/Places");
                }
                else {
                    placesFolder = new Folder (tsDataPath + "/IDs" + fileID + "/" + File.decode (targetFolderOrFile.name).slice (0, 5) + "/Places");
                }
                if (placesFolder.exists) {
                    var placesFiles = placesFolder.getFiles (isUnhiddenFile);
                    if (placesFiles.length > 0) {
                        for (var p = 0; p < placesFiles.length; p++) {
                            var isTrashed = false;
                            for (var i = 0; i < InDesignTwinList.length; i++) {
                                var comparedStr;
                                if (treeOrVersionOrOut == 1) {
                                    comparedStr  = File.decode (placesFiles[p].name);
                                }
                                else {
                                    comparedStr  = File.decode (placesFiles[p].name).slice (0, File.decode (placesFiles[p].name).lastIndexOf ("."));
                                }
                                if (comparedStr == InDesignTwinList[i][1]) {
                                    isTrashed = true;
                                    break;
                                }
                            }
                            if (!isTrashed) {
                                var tempTwin = new Array;
                                tempTwin.push (targetFolderOrFile);
                                tempTwin.push (treeOrVersionOrOut);
                                usedFilesList.push (tempTwin);
                                return true;
                            }
                        }
                    }
                }
            }
        }
        var tempTwin = new Array;
        tempTwin.push (targetFolderOrFile);
        tempTwin.push (treeOrVersionOrOut);
        unusedFilesList.push (tempTwin);
    }
    return false;
}

function tsGetRecipientIndex (collaboratorID) {
    var recipientIndex = -1;
    for (var ic = recipientsList.length - 1; ic >= 0; ic--) {
        if (collaboratorID == recipientsList[ic][0]) {
            recipientIndex = ic;
            break;
        }
    }
    return recipientIndex;
}

function loadSelectedHandler () {
    /**///$.writeln ($.line);
    var filesList = new Array;
    var selectedLabelIDPair = null;
    if (app.document.selections.length == 1) {
        if (app.document.selections[0].container) {
            if ((app.document.selections[0].spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath) != 0) {
                return false;
            }
            selectedLabelIDPair = tsGetLabel (app.document.selections[0].spec, true, true);
        }
    }
    if (!selectedLabelIDPair) {
        for (var c = 0; c < app.document.selections.length; c++) {
            retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
        }
    }

    if (filesList.length == 1 || selectedLabelIDPair) {
        var IDsList = new Array;
        var labelID = null;
        if (selectedLabelIDPair) {
            labelID = selectedLabelIDPair[1];
            retrieveFilesList (app.document.selections[0].spec, filesList, false, []);
            for (var fl = 0; fl < filesList.length; fl++) {
                var listFileID = tsGetID (filesList[fl]);
                if (listFileID) {
                    IDsList.push (listFileID);
                }
            }
        }
        else if (File.decode (filesList[0].name)[0] == '-') {
            var labelID = tsGetID (filesList[0]);
            if (!labelID) {
                labelID = tsUpdateFileState (filesList[0], -2, -1);
            }
            if (!labelID)
                return false;
            tsRetrieveLabelIDsList (filesList[0], IDsList);
        }
        if (labelID) {
            labelDotID = labelID.replace (/\//g,"\.");
            labelDotID = labelDotID.slice (1);
            var justShade = false;
            var pickCollaboratorMsg = "Select collaborator to forcely load folder.";
            if (selectedLabelIDPair) {
                justShade = confirm ("Load just shades (placeholdrs)?");
                pickCollaboratorMsg = "Select collaborator to forcely load the folder and it's sub folders.";
            }
            var collaboratorID = tsConfirmToPickCollaborator (null, pickCollaboratorMsg);
            if (!collaboratorID) {
                return false;
            }
            var recipientIndex = tsGetRecipientIndex (collaboratorID);
            if (recipientIndex == -1) {
                return false;
            }
            var withSubMark = (selectedLabelIDPair)? "YES_SUB" : "NO_SUB";
            var isShadeMark = justShade? "YES_SHADE" : "NO_SHADE";
            tsIsSendingDone = false;
            var sendingBoxesItem = new Array;
            sendingBoxesItem.push ("IRequest");
            sendingBoxesItem.push (labelDotID);
            sendingBoxesItem.push ("C" + ":" + withSubMark + ":" + isShadeMark + "," + IDsList.join (","));
            recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
            return true;
        }
        else if (!tsIsShade (filesList[0])) {
            var fileID = tsGetID (filesList[0]);
            var isToGetFeedback = confirm ("Do you want to check synchronizing by getting auto messages from collaborators?");
            if (isToGetFeedback) {
                var currentVersionDigitsFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                var currentVersionDigits = readFile (currentVersionDigitsFile);
                if (currentVersionDigits) {
                    currentVersionDigits = currentVersionDigits.split (":")[0];
                    var requiredFiles = Folder (tsDataPath + "/IDs" + fileID + "/Required").getFiles (isUnhiddenFile);
                    for (var m = 0; m < requiredFiles.length; m++) {
                        var recipientIndex = tsGetRecipientIndex (File.decode (requiredFiles[m].name));
                        if (recipientIndex != -1) {
                            tsIsSendingDone = false;
                            var sendingBoxesItem = new Array;
                            sendingBoxesItem.push ("HaveYou");
                            sendingBoxesItem.push ("Check");
                            sendingBoxesItem.push (fileID + "." + currentVersionDigits);
                            recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                        }
                    }
                }
            }
            else {
                var collaboratorID = tsConfirmToPickCollaborator (null, "Select collaborator to load the file from.");
                if (collaboratorID) {
                    tsLoadFile (fileID, null, collaboratorID, true);
                }
            }
            return true;
        }
    }
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    var currentVersionDigitsFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                    var currentVersionDigits = readFile (currentVersionDigitsFile);
                    if (currentVersionDigits) {
                        currentVersionDigits = currentVersionDigits.split (":")[0];
                        var currentVersionFile = new File (filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + currentVersionDigits + " " + File.decode (filesList[r].name));
                        var isAlreadyExist = false;
                        if (currentVersionFile.exists) {
                            if (!tsIsShade (currentVersionFile)) {
                                isAlreadyExist = true;
                            }
                        }
                        else {
                            if (!currentVersionFile.parent.exists)
                                currentVersionFile.parent.create ();
                            writeFile (currentVersionFile, "TS_ID:" + fileID);
                        }
                        if (!isAlreadyExist) {
                            tsLoadVersionFile (currentVersionFile, fileID, true);
                        }
                    }
                    else {
                        var creatorFile = new File (tsDataPath + "/IDs" + fileID + "/Creator");
                        var creatorName = readFile (creatorFile);
                        if (creatorName) {
                            tsLoadFile (fileID, null, creatorName, true);
                        }
                        else {
                            var collaboratorID = tsConfirmToPickCollaborator (null, "Select collaborator to load the file from.");
                            if (collaboratorID) {
                                tsLoadFile (fileID, null, collaboratorID, true);
                            }                            
                        }
                    }
                }
            }
        }
        else if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            if (tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    tsLoadVersionFile (filesList[r], fileID, true);
                }
            }
        }
    }
}

function tsConfirmToPickCollaborator (confirmMsg, pickMsg) {
    var goAhead = true;
    if (confirmMsg) {
        goAhead = confirm (confirmMsg);
    }
    var collaboratorID = null;
    if (goAhead) {
        var collaboratorsFolder = Folder (tsRootFolderPath + "/Workflow/Collaborators/Active");
        var collaboratorFile = collaboratorsFolder.openDlg (pickMsg, "*", false);
        if (collaboratorFile) {
            if (collaboratorFile.parent.fsName.replace(/\\/g, '/').toLowerCase() == (tsRootFolderPath + "/Workflow/Collaborators/Active").toLowerCase()) {
                if (collaboratorFile.alias)
                    collaboratorFile = collaboratorFile.resolve();
                var imageInfo = tsGetUserInfo (collaboratorFile);
                if (!imageInfo) {
                    alert ("The collaborator image Tree Shade ID is corrupted."); 
                    return collaboratorID;
                }
                var collaboratorID = imageInfo[0];
                return collaboratorID;
            }
        }
    }
    return false;
}

function setLabelFolderHandler () {
    /**///$.writeln ($.line);
    var targetFolder;
    if (app.document.selections.length == 1) {
        if (app.document.selections[0].container) {
            targetFolder = app.document.selections[0].spec;
        }
    }
    if (!targetFolder) {
        var result = confirm ("Create new folder?");
        if (result) {
            var folderName = prompt ("Folder Name:", "");
            if (folderName) {
                targetFolder = new Folder (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/" + folderName);
                targetFolder.create ();
            }
        }
        else {
            targetFolder = app.document.thumbnail.spec;
        }
    }

    var defaultValue = "";
    var extension = "";
    var oldLabelFile = targetFolder.getFiles (tsIsLabelFile);
    if (oldLabelFile.length > 0) {
        var from = 1;
        if (File.decode (oldLabelFile[0].name).length > 1) {
            if (File.decode (oldLabelFile[0].name)[1] == " ")
                from = 2;
        }
        defaultValue = File.decode (oldLabelFile[0].name).slice (from, File.decode (oldLabelFile[0].name).lastIndexOf ("."));
        if (File.decode (oldLabelFile[0].name).indexOf (".") > 0)
            extension = File.decode (oldLabelFile[0].name).slice (File.decode (oldLabelFile[0].name).lastIndexOf ("."));
    }
    var inputText = prompt ("Folder Label:", defaultValue);
    if (inputText) {
        var changedLabelFile;
        if (oldLabelFile.length > 0) {
            changedLabelFile = oldLabelFile[0];
            changedLabelFile.rename ("- " + inputText + extension);
            tsUpdateFileState (changedLabelFile, -2, -1);
        }
        else {
            if (inputText != "") {
                changedLabelFile = new File (targetFolder.fsName.replace(/\\/g, '/') + "/- " + inputText);
                tsBuildID (changedLabelFile, new Date().getTime (), null);
            }
            app.document.thumbnail = new Thumbnail (targetFolder);
        }
    }
}

function startEditingSelectedHandler () {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    isItLiveSnippets = true;
    isLiveSnippetsActual = true;
    for (var ls = 0; ls < filesList.length; ls++) {
        if (!tsIsLiveSnippetFile (filesList[ls])) {
            isItLiveSnippets = false;
            break;
        }
        if (tsIsShade (filesList[ls])) {
            isLiveSnippetsActual = false;
        }
    }
    if (isItLiveSnippets) {
        if (!isLiveSnippetsActual) {
            alert ("Please load actual files and try again.");
            return false;
        }
        var newContentsList = tsGetNewLiveSnippetsContents (filesList, filesList[0].parent.parent.fsName.replace(/\\/g, '/'));
        if (!newContentsList)
            return false;
        for (var nc = 0; nc < newContentsList.length; nc++) {
            writeFile (filesList[nc], newContentsList[nc]);
        }
        return true;
    }
    var isToOpen = (filesList.length == 1)? true : false;
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (!tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    tsStartEditing (filesList[r], fileID, isToOpen, null);
                }
            }
        }
    }
}

function tsGetNewLiveSnippetsContents (targetFilesList, rootFolderPath) {
    var newContentsList = new Array;
    for (var fl = 0; fl < targetFilesList.length; fl++) {
        var fileDisplay = File.decode (targetFilesList[fl].name).slice (0, File.decode (targetFilesList[fl].name).lastIndexOf ("."));
        if (rootFolderPath) {
            fileDisplay = (targetFilesList[fl].parent.fsName.replace(/\\/g, '/') + "/").replace (rootFolderPath + "/", "") + fileDisplay;
        }
        var newContent = prompt (fileDisplay, readFile (targetFilesList[fl]));
        if (newContent == null) {
            return false;
        }
        newContentsList.push (newContent);
    }
    return newContentsList;
}

function cancelEditingSelectedHandler () {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    var isInfoUser = filesList.length == 1? true : false;
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (!tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    tsCancelEditing (filesList[r], fileID, null, isInfoUser, true);
                }
            }
        }
    }
}

function wideScanningHandler () {
    /**///$.writeln ($.line);
    if (tsIsWideScanning) {
        tsIsWideScanning = false;
        tsIsWideScanningUltimate = false;
        tsIsScanningStopped = 2;
    }
    else {
        tsIsWideScanning = true;
        tsIsWideScanningUltimate = confirm ("Ultimate Wide Scanning?");
        if (tsIsWideScanningUltimate) {
            tsIsScanningStopped = 1;
        }
    }
}

function staticIDsHandler () {
    tsIsStaticIDs = !tsIsStaticIDs;
    if (tsIsStaticIDs) {
        alert ("Now the file will get the destination ID after overridding. Don't use this option when using 'Batch Rename' for sorting.");
    }
    else {
        alert ("Now the file will get the source ID after overridding. Use this option when using 'Batch Rename' for sorting.");
    }
}

function versionsOutputHandler () {
    var versionsOutputToWorkshopFile = new File (tsDataPath + "/Versions Output to Workshop Mark");
    if (!tsIsVersionsOutputToWorkshop) {
        var versionsOutputZero = "NO_ZERO";
        if (confirm ("Make ZERO version as current?")) {
            if (confirm ("Only keep ZERO version as current?")) {
                versionsOutputZero = "ONLY_ZERO";
            }
            else {
                versionsOutputZero = "WITH_ZERO";
            }
        }
        writeFile (versionsOutputToWorkshopFile, versionsOutputZero);
    }
    else {
        versionsOutputToWorkshopFile.remove ();
    }
    tsChangeRootRequested = true;
}

function switchWithInDesignHandler () {
    var switchWithInDesignFile = new File (tsDataPath + "/Switch With InDesign Mark");
    if (!tsIsSwitchWithInDesign) {
        writeFile (switchWithInDesignFile, "Tree Shade Mark");
    }
    else {
        switchWithInDesignFile.remove ();
    }
    tsChangeRootRequested = true;
}

function ignoreVersionOwnerHandler () {
    var ignoreVersionOwnerFile = new File (tsDataPath + "/Ignore Version Owner Mark");
    if (!tsIsIgnoreVersionOwner) {
        writeFile (ignoreVersionOwnerFile, "Tree Shade Mark");
    }
    else {
        ignoreVersionOwnerFile.remove ();
    }
    tsChangeRootRequested = true;
}

function respondToManuallyDeletedHandler () {
    var respondToManuallyDeletedFile = new File (tsDataPath + "/Respond To Manually Deleted Mark");
    if (!tsIsRespondToManuallyDeleted) {
        writeFile (respondToManuallyDeletedFile, "TREE_SHADE_MARK");
        tsIsRespondToManuallyDeleted = true;
    }
    else {
        respondToManuallyDeletedFile.remove ();
        tsIsRespondToManuallyDeleted = false;
    }
}

function stopScanningHandler () {
    /**///$.writeln ($.line);
    for (var c = 0; c < app.document.selections.length; c++) {
        if (app.document.selections[c].container) {
            if (app.document.selections[c].spec.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
                var lockFile = new File (app.document.selections[c].spec.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
                if (!lockFile.exists) {
                    writeFile (lockFile, "TS");
                }
            }
        }
    }
}

function scanHandler () {
    /**///$.writeln ($.line);
    var folders = new Array;
    var filesCount = 0;
    for (var c = 0; c < app.document.selections.length; c++) {
        if (app.document.selections[c].container) {
            folders.push (app.document.selections[c].spec);
        }
        else if (isAcceptedFile (app.document.selections[c].spec)) {
            filesCount++;
            var shadeFile = new File (app.document.selections[c].spec.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsDataPath + "/Shades"));
            shadeFile.remove();
            tsUpdateFileState (app.document.selections[c].spec, -2, -1);
        }
    }
    if (folders.length == 0 && filesCount == 0) {
        folders.push (app.document.thumbnail.spec);
    }
    if (folders.length > 0) {
        //var isToRefreshPaths = confirm ("Do you want to refresh paths and update records?");
        for (var f = 0; f < folders.length; f++) {
            if (folders[f].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
                if (isAcceptedFolder (folders[f])) {
                    addToFoldersChanged (folders[f], true, false);
                }
            }
        }  
    }
}

function addToFoldersChanged (targetFolder, isWithSub, isToRemoveShades) {
    if (isWithSub) {
        var allSub = targetFolder.getFiles (isAcceptedFolder);
        for (var as = 0; as < allSub.length; as++) {
            addToFoldersChanged (allSub[as], true, isToRemoveShades);
        }
    }
    if (isToRemoveShades) {
        var shadeFolder = new Folder (targetFolder.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsDataPath + "/Shades"));
        if (shadeFolder.exists) {
            var allShades = shadeFolder.getFiles (isUnhiddenFile);
            for (var as = 0; as < allShades.length; as++)
                allShades[as].remove();
        }
    }
    for (var fc = 0; fc < tsFoldersChanged.length; fc++) {
        if (tsFoldersChanged[fc] == targetFolder.fsName.replace(/\\/g, '/')) {
            tsFoldersChanged.splice (fc, 1);
            break;
        }
    }
    tsFoldersChanged.unshift (targetFolder.fsName.replace(/\\/g, '/'));
}

function tsSolveDateTime (toBeSolvedPhrase) {
    //DS <Day_Seconds>
    //DM <Day_Minutes>
    //DH <Day_Hours>
    //WO <Weekday_Order>
    //WN <Weekday_Name>
    //WA <Weekday_Abbreviation>
    //MD <Month_Date>
    //MO <Month_Order>
    //MN <Month_Name>
    //MA <Month_Abbreviation>
    //YF <Year_Full>
    //YA <Year_Abbreviation>
    //TN <Time_Numbers>
    //TH <Time_Hexadecimal>
    //TM <Time_Minimum>

    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Day_Seconds>|\{Day_Seconds\}/gi, "<DS>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Day_Minutes>|\{Day_Minutes\}/gi, "<DM>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Day_Hours>|\{Day_Hours\}/gi, "<DH>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Weekday_Order>|\{Weekday_Order\}/gi, "<WO>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Weekday_Name>|\{Weekday_Name\}/gi, "<WN>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Weekday_Abbreviation>|\{Weekday_Abbreviation\}/gi, "<WA>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Month_Date>|\{Month_Date\}/gi, "<MD>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Month_Order>|\{Month_Order\}/gi, "<MO>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Month_Name>|\{Month_Name\}/gi, "<MN>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Month_Abbreviation>|\{Month_Abbreviation\}/gi, "<MA>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Year_Full>|\{Year_Full\}/gi, "<YF>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Year_Abbreviation>|\{Year_Abbreviation\}/gi, "<YA>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Time_Numbers>|\{Time_Numbers\}/gi, "<TN>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Time_Hexadecimal>|\{Time_Hexadecimal\}/gi, "<TH>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Time_Minimum>|\{Time_Minimum\}/gi, "<TM>");

    toBeSolvedPhrase = toBeSolvedPhrase.replace (/\{(DS|DM|DH|WO|WN|WA|MD|MO|MN|MA|YF|YA|TN|TH|TM)\}/gi, "<$1>");

    var matches = toBeSolvedPhrase.match (/<(DS|DM|DH|WO|WN|WA|MD|MO|MN|MA|YF|YA|TN|TH|TM)>/gi);
    var theDate = new Date();
    if (matches) {
        for (var i = 0; i < matches.length; i++) {
            var currentMatch = matches[i];
            var twoCapital = currentMatch.slice(1, 3).toUpperCase();
            switch (twoCapital) {
                case "DS":
                    var daySeconds = tsFillZeros(theDate.getSeconds(), 2);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, daySeconds);
                    break;
                case "DM":
                    var dayMinutes = tsFillZeros(theDate.getMinutes(), 2);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, dayMinutes);
                    break;
                case "DH":
                    var dayHours = tsFillZeros(theDate.getHours(), 2);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, dayHours);
                    break;
                case "WO":
                    var weekdayOrder = (theDate.getDay() + 1).toString();
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, weekdayOrder);
                    break;
                case "WN":
                    var weekdayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                    var weekdayName = weekdayNames[theDate.getDay()];
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, weekdayName);
                    break;
                case "WA":
                    var weekdayAbbs = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                    var weekdayAbb = weekdayAbbs[theDate.getDay()];
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, weekdayAbb);
                    break;
                case "MD":
                    var monthDate = tsFillZeros(theDate.getDate(), 2);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, monthDate);
                    break;
                case "MO":
                    var monthOrder = tsFillZeros(theDate.getMonth() + 1, 2);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, monthOrder);
                    break;
                case "MN":
                    var monthsNames = ["January", "February", "March", "April", "May", "June",
                                    "July", "August", "September", "October", "November", "December"];
                    var monthName = monthsNames[theDate.getMonth()];
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, monthName);
                    break;
                case "MA":
                    var monthNameAbbs = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
                                        "Aug", "Sep", "Oct", "Nov", "Dec"];
                    var monthNameAbb = monthNameAbbs[theDate.getMonth()];
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, monthNameAbb);
                    break;
                case "YF":
                    var yearFull = theDate.getFullYear().toString();
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, yearFull);
                    break;
                case "YA":
                    var yearAbb = theDate.getFullYear().toString().slice(2);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, yearAbb);
                    break;
                case "TN":
                    var timeNumbers = theDate.getTime().toString();
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, timeNumbers);
                    break;
                case "TH":
                    var timeHexa = theDate.getTime().toString(16);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, timeHexa);
                    break;
                case "TM":
                    var timeShort = theDate.getTime().toString(36);
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, timeShort);
                    break;
                default:
                    toBeSolvedPhrase = toBeSolvedPhrase.replace(currentMatch, "");
            }
        }
    }
    return toBeSolvedPhrase;
}

function tsSolveRandom (toBeSolvedPhrase, exceptionChar) {
    //R <Random_Style_Long>
    //Use in Style 'a' small letters, 'A' capital letters, 'h' small hexadecimal, 'H' large hexadecimal, '1' numbers

    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<Random_([^<>]+)>/gi, "<R_$1");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/<R>/gi, "<R_A1_5>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/\{Random_([^\{\}]+)\}/gi, "<R_$1");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/\{R\}/gi, "<R_A1_5>");
    toBeSolvedPhrase = toBeSolvedPhrase.replace(/\{R_([^\{\}]+)\}/gi, "<R_$1>");

    var matches = toBeSolvedPhrase.match (/<R_[^<>]*>/gi);
    if (matches) {
        for (var mts = 0; mts < matches.length; mts++) {
            var currentMatch = matches[mts];
            var randomPhrases = currentMatch.slice (3, -1).split ("_");
            var capital = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            var small = "abcdefghijklmnopqrstuvwxyz";
            var numbers = "0123456789";
            var capitalHexa = "0123456789ABCDEF";
            var smallHexa = "0123456789abcdef";
            var combination = "";
            var theLong = 5;
            if (randomPhrases.length > 0) {
                if (exceptionChar && randomPhrases[0].indexOf (exceptionChar) == -1) {
                    continue;
                }
                if (randomPhrases[0].indexOf ('A') != -1) {
                    combination += capital;
                }
                if (randomPhrases[0].indexOf ('a') != -1) {
                    combination += small;
                }
                if (randomPhrases[0].indexOf ('1') != -1) {
                    combination += numbers;
                }
                if (randomPhrases[0].indexOf ('H') != -1) {
                    combination += capitalHexa;
                }
                if (randomPhrases[0].indexOf ('h') != -1) {
                    combination += smallHexa;
                }
            }
            if (randomPhrases.length > 1) {
                var longGet = parseInt (randomPhrases[1], 10);
                if (longGet && longGet > 0) {
                    theLong = longGet;
                }
            }
            var randomCode = tsMakeRandom (theLong, combination);
            toBeSolvedPhrase = toBeSolvedPhrase.replace (currentMatch, randomCode);
        }
    }
    return toBeSolvedPhrase;
}

function tsMakeRandom (length, characters) {
    var result = '';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++ ) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
   return result;
}

function autoCheckInAddHandler () {
    /**///$.writeln ($.line); 

    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    var autoCheckInFilesFolder  = new Folder (tsRootFolderPath + "/Workflow/Auto Check In Files");
    if (!autoCheckInFilesFolder.exists) {
        autoCheckInFilesFolder.create ();
    }
    for (var r = filesList.length - 1; r >= 0; r--) {
        if (filesList[r].parent.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath) != 0) {
            filesList.splice (r, 1);
        }
    }
    var relationReferencePath = "./*.indd";
    var sourceDeterminer = "";
    var whenCheckInCode  = "CPDM";
    var isToRepeatSame = null;
    for (r = 0; r < filesList.length; r++) {
        if (r > 0 && isToRepeatSame == null) {
            isToRepeatSame = true;
        }
        var fileID = tsGetID (filesList[r]);
        if (fileID) {
            var autoCheckInMarkFile = new File (tsDataPath + "/IDs" + fileID + "/Auto Check In Mark");
            if (isToRepeatSame != true) {
                var autoCheckInMarkContent = readEncodedFile (autoCheckInMarkFile);
                if (autoCheckInMarkContent) {
                    var autoCheckInMarkContentSplit = autoCheckInMarkContent.split ("\n");
                    if (autoCheckInMarkContentSplit.length > 3) {
                        relationReferencePath = autoCheckInMarkContentSplit[1];
                        sourceDeterminer = autoCheckInMarkContentSplit[2];
                        whenCheckInCode = autoCheckInMarkContentSplit[3];
                    }
                }
                whenCheckInCode = tsGetText (["It will be checked in when you:",
                                        "C: create new copy of the file.",
                                        "P: path change or name.",
                                        "D: delete the file.",
                                        "M: modify the file.",
                                        "R: the 'Auto Check In' will be removed after first event.",
                                        "",
                                        "Write one or more of above capital letters",
                                        "if there is only 'R' then the 'Auto Check In'",
                                        "will be removed now permanently."], whenCheckInCode, false);
                if (!whenCheckInCode) {
                    break;
                }
                //autoCheckInMarkFile
                if (whenCheckInCode == "C" || whenCheckInCode == "c") {
                    whenCheckInCode = "CR";
                }
                if (whenCheckInCode != "R" && whenCheckInCode != "r") {
                    var isToReferencePath = confirm ("Do you want also to check in destination according to it's source?");
                    if (isToReferencePath) {
                        var messageLines = ["Choose How the Source File determined (Write relative path using):",
                        "<O>: Relative to the original file in the copying sequence.",
                        "<P>: Relative to The previous file in the copying sequence or the previous path when path changed.",
                        "<C>: Relative to this file CONTENT as the source id.",
                        "<S>: Relative to a file to be SELECTED next.",
                        "//: Root of Tree Shade path.",
                        "./: File parent folder path. add dots for parent of parent...",
                        "<.>: File parent folder name.",
                        "<AP>: Absolute file path portion without Tree Shade root path.",
                        "<AP.>: Absolute file path separated by dots.",
                        "<FD>: File display.",
                        "<FN>: File name.",
                        "<FN.>: File name separated by dots to path portion.",
                        "<FNS>: File name suffix after the square brackets.",
                        "<FC>: File content.",
                        "<FF>: First folder.",
                        "<LF>: Last folder.",
                        "",
                        "The following also accepts abbreviation and used for date, time and random code:",
                        "<Day_Seconds>, <Day_Minutes>, <Day_Hours>, <Weekday_Order>, <Weekday_Name>, <Weekday_Abbreviation>,",
                        "<Month_Date>, <Month_Order>, <Month_Name>, <Month_Abbreviation>, <Year_Full>,",
                        "<Year_Abbreviation>, <Time_Decimal>, <Time_Hexadecimal>, <Time_Shortest>,",
                        "<Random_Style_Long> Where 'Style' a combination of symbols 'a' for small letters,",
                        "'A' capital letters, 'h' small hexadecimal, 'H' large hexadecimal and '1' for numbers.",
                        "For example <Random_1A_8> means random 8 characters consists of capital letters and numbers",
                        ""
                        ];
                        sourceDeterminer = tsGetText (messageLines, sourceDeterminer, false);
                        if (!sourceDeterminer) {
                            break;
                        }
                        if (sourceDeterminer.search (/<S>/i) != -1 && sourceDeterminer.indexOf (":") == -1) {
                            var theSourceFile = File.openDialog ("Select a file as a source.");
                            if (!theSourceFile) {
                                break;
                            }
                            var testSourceID = tsGetID (theSourceFile);
                            if (testSourceID) {
                                sourceDeterminer += ":" + testSourceID.replace (/\//g,"\.").slice (1);
                            }
                            else {
                                alert ("The file you picked has no ID!");
                                break;
                            }
                        }
                        relationReferencePath = tsGetText (["Choose How the destination determined (Write relative path using):",
                                                            "//: Root of Tree Shade path.",
                                                            "./: File parent folder path. add dots for parent of parent...",
                                                            "<.>: File parent folder name.",
                                                            "<AP>: Absolute file path portion without Tree Shade root path.",
                                                            "<AP.>: Absolute file path separated by dots.",
                                                            "<FD>: File display.",
                                                            "<FN>: File name.",
                                                            "<FN.>: File name separated by dots to path portion.",
                                                            "<FNS>: File name suffix after the square brackets.",
                                                            "<FC>: File content.",
                                                            "<FF>: First folder.",
                                                            "<NF>: New folder.",
                                                            "<LF>: Last folder.",
                                                            "<DNC>: Don't check in the file and the destination!",
                                                            "<DD>: Delete destination if the file deleted.",
                                                            "<CO>: When Conflict overwrite the destination.",
                                                            "",
                                                            "The following also accepts abbreviation and used for date, time and random code:",
                                                            "<Day_Seconds>, <Day_Minutes>, <Day_Hours>, <Weekday_Order>, <Weekday_Name>, <Weekday_Abbreviation>,",
                                                            "<Month_Date>, <Month_Order>, <Month_Name>, <Month_Abbreviation>, <Year_Full>,",
                                                            "<Year_Abbreviation>, <Time_Decimal>, <Time_Hexadecimal>, <Time_Shortest>,",
                                                            "<Random_Style_Long> Where 'Style' a combination of symbols 'a' for small letters,",
                                                            "'A' capital letters, 'h' small hexadecimal, 'H' large hexadecimal and '1' for numbers.",
                                                            "For example <Random_1A_8> means random 8 characters consists of capital letters and numbers",
                                                            "",
                                                            "To reference to the source file write like this '.$/' or '<FN$>'...",
                                                            "To produce all source location files put '-' as the file name like './-'."
                                                            ], relationReferencePath, false);
                        if (!relationReferencePath) {
                            break;
                        }
                        if (relationReferencePath.search (/<DD>/i) != -1) {
                            if (whenCheckInCode.search (/D/i) == -1) {
                                whenCheckInCode += "D";
                            }
                        }
                    }
                    else {
                        relationReferencePath = "";
                        sourceDeterminer = "";
                        if (confirm ("Do you want to check in placing documents?")) {
                            relationReferencePath = "PLACING_DOCS";
                        }
                    }
                }
            }
            var autoCheckFileContent = fileID + "\n" + relationReferencePath + "\n" + sourceDeterminer + "\n" + whenCheckInCode;
            if (whenCheckInCode == "R" || whenCheckInCode == "r") {
                autoCheckInMarkFile.remove ();
            }
            else {
                writeEncodedFile (autoCheckInMarkFile, autoCheckFileContent);
            }

            if (sourceDeterminer.search (/<O>/i) == -1 || (whenCheckInCode == "R" || whenCheckInCode == "r")) {
                //add label name to folder paths
                var newAbsolutePath = filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                newAbsolutePath = newAbsolutePath.slice (1);
                newAbsolutePath = newAbsolutePath.replace (/\//g, " ➔ ");
                newAbsolutePath += " ➔ " + File.decode (filesList[r].name);
                var newPathFile = new File (autoCheckInFilesFolder.fsName.replace(/\\/g, '/') + "/" + newAbsolutePath);
                if (whenCheckInCode == "R" || whenCheckInCode == "r") {
                    newPathFile.remove ();   
                }
                else {
                    writeEncodedFile (newPathFile, autoCheckFileContent);
                }

                //add to tsAutoCheckInFilesList
                for (var acfl = tsAutoCheckInFilesList.length - 1; acfl >= 0; acfl--) {
                    if (fileID == tsAutoCheckInFilesList[acfl][0]) {
                        tsAutoCheckInFilesList.splice (acfl, 1);
                        break;
                    }
                }
                if (whenCheckInCode != "R" && whenCheckInCode != "r") {
                    var autoCheckFileContentSplit = autoCheckFileContent.split ("\n");
                    tsAutoCheckInFilesList.push (autoCheckFileContentSplit);
                    tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (filesList[r]);
                    tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (0);
                    tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (false);
                    tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (null);
                }
            }
        }
    }
}

function tsSelectRelationFileHandler (relationName) {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    if (filesList.length != 1) {
        alert ("Please select one file.");
        return false;
    }
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            filesList[r] = new File (filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (filesList[r].name).slice (6));
        }
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (!tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    var relationFileID = readFile (File (tsDataPath + "/IDs" + fileID + "/" + relationName + " ID"));
                    if (relationFileID) {
                        var fileID_Path_newID = [relationFileID];
                        tsGetPath (fileID_Path_newID);                 
                        if (!fileID_Path_newID[1]) {
                            alert ("The " + relationName + " file has trashed or missed and has id " + relationFileID);
                            return false;
                        }
                        var relationFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                        if (!relationFile.exists) {
                            alert ("The " + relationName + " file is not exist!\n" + "ID " + relationFileID + "\nPath " + fileID_Path_newID[1]);
                            return false;
                        }
                        //select the relation file
                        tsToBeSelectedThumbnail = new Thumbnail (relationFile);
                        tsLoadStage = 2;
                        app.document.thumbnail = tsToBeSelectedThumbnail.parent;
                    }
                    else {
                        alert ("The file has no " + relationName + "!");
                    }
                }
            }
        }
    }
}

function tsChangeRelationFileHandler (relationName) {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    if (filesList.length == 0) {
        alert ("Please select one file at least.");
        return false;
    }
    var selectedFile = filesList[0].parent.openDlg ("Select " + relationName + " File.", "*", false);
    if (!selectedFile) 
        return false;
    if (selectedFile.alias)
        selectedFile = selectedFile.resolve();
    var selectedID = tsGetID (selectedFile);
    if (!selectedID) {
        alert ("The file you have selected has no ID!");
        return false;
    }
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            filesList[r] = new File (filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (filesList[r].name).slice (6));
        }
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (!tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    var relationFileIDMark = File (tsDataPath + "/IDs" + fileID + "/" + relationName + " ID");
                    relationFileIDMark.parent.create ();
                    writeFile (relationFileIDMark, selectedID);
                    for (var ic = recipientsList.length - 1; ic >= 0; ic--) {
                        tsUploadFilePath (filesList[r], null, fileID, ic, false);
                    }

                }
                else if (filesList.length == 1) {
                    alert ("The selected file has no ID!");
                }
            }
            else if (filesList.length == 1) {
                alert ("Load the file and try again.");
            }
        }
        else if (filesList.length == 1) {
            alert ("Select file from Workshop!");
        }
    }
}

function tsRemoveRelationFileHandler (relationName) {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    if (filesList.length == 0) {
        alert ("Please select one file at least.");
        return false;
    }
    var logMessage = "";
    var logsSeparator = "";
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            filesList[r] = new File (filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (filesList[r].name).slice (6));
        }
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (!tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    var relationFileIDMark = File (tsDataPath + "/IDs" + fileID + "/" + relationName + " ID");
                    relationFileIDMark.remove ();
                    for (var ic = recipientsList.length - 1; ic >= 0; ic--) {
                        tsUploadFilePath (filesList[r], null, fileID, ic, false);
                    }
                }
                else {
                    logMessage += logsSeparator + "the file '" + File.decode (filesList[r].name) + "' has no ID.";
                }
            }
            else {
                logMessage += logsSeparator + "the file '" + File.decode (filesList[r].name) + "' needs to be loaded.";
            }
        }
        else {
            logMessage += logsSeparator + "the file '" + File.decode (filesList[r].name) + "' is out of 'Workshop'.";
        }
        logsSeparator = "\n";
    }
    if (logMessage != "") {
        alert (logMessage);
    }
}

function releaseSelectedHandler () {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    for (var r = 0; r < filesList.length; r++) {
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            filesList[r] = new File (filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (filesList[r].name).slice (6));
        }
        if (filesList[r].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (!tsIsShade (filesList[r])) {
                var fileID = tsGetID (filesList[r]);
                if (fileID) {
                    var fileDotID = fileID.replace (/\//g,"\.");
                    fileDotID = fileDotID.slice (1);
                    var currentVersionDigitsFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                    var currentVersionDigits = readFile (currentVersionDigitsFile);
                    if (currentVersionDigits) {
                        currentVersionDigits = currentVersionDigits.split (":")[0];
                        var currentVersionFile = new File (filesList[r].parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + currentVersionDigits + " " + File.decode (filesList[r].name));
                        if (currentVersionFile.exists) {
                            var modified = tsGetActualModified (filesList[r].modified.getTime (), fileID);
                            var versionModified = readFile (File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersionDigits + "/Modifying Time"));
                            versionModified = !versionModified? 0 : parseInt (versionModified, 10);
                            if (modified <= versionModified) {
                                var allVersions = currentVersionFile.parent.getFiles ("ver?? " + File.decode (filesList[r].name));
                                for (var v = 0; v < allVersions.length; v++) {
                                    if (tsIsShade (allVersions[v]))
                                        continue;
                                    var versionPrefix = File.decode (allVersions[v].name).slice (0, 5);
                                    var indexTime = readFile (File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/Modifying Time"));
                                    if (indexTime) {
                                        var requiredFiles = Folder (tsDataPath + "/IDs" + fileID + "/Required").getFiles (isUnhiddenFile);
                                        var involvedRecipients = new Array;
                                        for (var m = 0; m < requiredFiles.length; m++) {
                                            var recipientIndex = tsGetRecipientIndex (File.decode (requiredFiles[m].name));
                                            if (recipientIndex != -1) {
                                                involvedRecipients.push (recipientIndex);
                                                tsIsSendingDone = false;
                                                var sendingBoxesItem = new Array;
                                                sendingBoxesItem.push ("HaveYou");
                                                sendingBoxesItem.push (fileDotID + "." + versionPrefix + "." + indexTime);
                                                sendingBoxesItem.push ("WILL_RELEASE");
                                                recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                                            }
                                            else {
                                                
                                            }
                                        }
                                        if (involvedRecipients.length > 0) {
                                            var askForFolder = new Folder (tsDataPath + "/Messages/AskFor" + fileID + "/" + versionPrefix + "." + indexTime);
                                            askForFolder.create ();
                                            var toDoFile = new File (askForFolder.fsName.replace(/\\/g, '/') + "/ToDo");
                                            writeFile (toDoFile, "WILL_RELEASE");
                                        }
                                    }                                        
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

function cancelToCheckInListHandler () {
    var PDFPreviewFolder = Folder (tsDataPath + "/Messages/PDFPreview");
    if (PDFPreviewFolder.exists) {
        var allFiles = PDFPreviewFolder.getFiles (isUnhiddenFile);
        for (var afis = 0; afis < allFiles.length; afis++) {
            allFiles[afis].remove ();
        }
    } 
}

function tsLoadVersionFile (shadeVersionFile, fileID, isForced) {
    /**///$.writeln ($.line);
    var versionPrefix = shadeVersionFile.fsName.replace(/\\/g, '/').slice (shadeVersionFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    versionPrefix = versionPrefix.slice (0, 5);
    var fileDotID = fileID.replace (/\//g,"\.");
    fileDotID = fileDotID.slice (1);
    var versionTimeFile = new File (tsDataPath + "/IDs" + fileID + "/" + versionPrefix + "/Modifying Time");
    if (versionTimeFile.exists) {
        var versionTime = readFile (versionTimeFile);
        if (versionTime) {
            var requiredFiles = Folder (tsDataPath + "/IDs" + fileID + "/Required").getFiles (isUnhiddenFile);
            var toDoFile = new File (tsDataPath + "/Messages/AskFor" + fileID + "/" + versionPrefix + "." + versionTime + "/ToDo");
            var isToLoad = true;
            if (toDoFile.exists) {
                var content = readFile (toDoFile);
                if (content == "WILL_REQUEST") {
                    if (!isForced) {
                        isToLoad = false;
                    }
                }
            }
            if (isToLoad) {
                var recipientIndex = -1;
                if (requiredFiles.length == 1) {
                    recipientIndex = tsGetRecipientIndex (File.decode (requiredFiles[0].name));
                    if (recipientIndex != -1) {
                        tsIsSendingDone = false;
                        var sendingBoxesItem = new Array;
                        sendingBoxesItem.push ("IRequest");
                        sendingBoxesItem.push (fileDotID + "." + versionPrefix + "." + versionTime);
                        sendingBoxesItem.push ("A");
                        recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                    }
                }
                if (recipientIndex == -1) {
                    var isWillRequest = false;
                    for (var m = 0; m < requiredFiles.length; m++) {
                        recipientIndex = tsGetRecipientIndex (File.decode (requiredFiles[m].name));
                        if (recipientIndex != -1) {
                            isWillRequest = true;
                            
                            tsIsSendingDone = false;
                            var sendingBoxesItem = new Array;
                            sendingBoxesItem.push ("HaveYou");
                            sendingBoxesItem.push (fileDotID + "." + versionPrefix + "." + versionTime);
                            sendingBoxesItem.push ("WILL_REQUEST");
                            recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                        }
                        else {
                        }
                    }
                    if (isWillRequest) {
                        if (!toDoFile.parent.exists)
                            toDoFile.parent.create ();
                        writeFile (toDoFile, "WILL_REQUEST");
                    }
                    else {
                        var askTwin = getTotalGoal (shadeVersionFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, ""), null, fileID, false);
                        for (var aw = 0; aw < askTwin.length; aw++) {
                            for (var sp = 0; sp < askTwin[aw].length; sp++) {
                                for (var rc = 0; rc < askTwin[aw][sp][1].length; rc++) {
                                    isWillRequest = true;

                                    tsIsSendingDone = false;
                                    var sendingBoxesItem = new Array;
                                    sendingBoxesItem.push ("HaveYou");
                                    sendingBoxesItem.push (fileDotID + "." + versionPrefix + "." + versionTime);
                                    sendingBoxesItem.push ("WILL_REQUEST");
                                    
                                    recipientsList[askTwin[aw][sp][1][rc]][8][1].push (sendingBoxesItem);
                                }
                            }
                        }
                        if (isWillRequest) {
                            if (!toDoFile.parent.exists)
                                toDoFile.parent.create ();
                            writeFile (toDoFile, "WILL_REQUEST");
                        }
                    }
                }
            }
            else {
                return false;
            }
        }
    }
}

function tsUpload (versionDotIDwithModification, senderIndex, scopesIndexes) {
    //getting the information
    var versionDotID = versionDotIDwithModification.slice (0, versionDotIDwithModification.lastIndexOf ("."));
    var versionID = "/" + versionDotID.replace (/\./g, "\/");
    var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
    var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
    var modificationTime = versionDotIDwithModification.slice (versionDotIDwithModification.lastIndexOf (".") + 1);
    var CVRecordFile;
    var CVDigits = "00";
    var CVFinal = "P";
    var isToFabricateTime;
    var fileID_Path_newID = [fileID];
    var pathTime = tsGetPath (fileID_Path_newID);

    if (!fileID_Path_newID[1]) {
        tsUploadFilePath (null, null, fileID, sendersList[senderIndex][0][3], false);
        return false;
    }
    var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
    if (versionPrefix == "ver00") {
        CVRecordFile = new File (tsDataPath + "/IDs" + fileID  + "/CV");
        if (CVRecordFile.exists) {
            var CVRecordSplitted = readFile (CVRecordFile);
            if (CVRecordSplitted) {
                CVRecordSplitted = CVRecordSplitted.split (":");
                CVDigits = CVRecordSplitted[0];
                CVFinal = CVRecordSplitted[1];
                versionPrefix = "ver" + CVDigits;
                versionID = fileID + "/" + versionPrefix;
                versionDotID = versionID.replace (/\//g,"\.");
                versionDotID = versionDotID.slice (1);
                isToFabricateTime = true;
            }
        }
        else {
            if (workshopFile.exists) {
                if (!tsIsShade (workshopFile)) {
                    var IDFolder = new Folder (tsDataPath + "/IDs" + fileID);
                    var allVersions = IDFolder.getFiles ("ver??");
                    var maxNumber = 0;
                    if (allVersions.length > 0) {
                        maxNumber = parseInt (File.decode (allVersions[allVersions.length-1].name).slice (3), 10);
                    }
                    maxNumber += 1; 
                    maxNumber = maxNumber < 10? "0" + maxNumber : "" + maxNumber;
                    var digitsFileIDTriple = new Array;
                    digitsFileIDTriple.push (maxNumber == "01"? "new" : maxNumber);
                    var versionFile = File (workshopFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + maxNumber + " " + File.decode (workshopFile.name));
                    digitsFileIDTriple.push (versionFile);
                    digitsFileIDTriple.push (fileID);
                    tsCheckIn (workshopFile, digitsFileIDTriple, false, false, false, true, false, false, senderIndex == -1? null : sendersList[senderIndex][0][0]);
                    return true;
                }
                else {
                    tsUploadFilePath (null, null, fileID, sendersList[senderIndex][0][3], false);
                    return false;
                }
            }
            else {
                tsUploadFilePath (null, null, fileID, sendersList[senderIndex][0][3], false);
                return false;
            }
        }
    }

    //getting own time
    var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
    var versionTime = readFile (versionTimeFile);
    if (!versionTime) {
        /*Error*/$.writeln ("Tree Shade Error #" + $.line);
        return false;
    }
    if (isToFabricateTime || modificationTime == "0")
        modificationTime = versionTime;
    if (modificationTime != versionTime) {
        return false;
    }
    
    //Treating
    var treatingList = new Array;
    //treatingList[x][0] sync path
    //treatingList[x][1] sync location
    //treatingList[x][2] list of recipients indexes
    if (senderIndex != -1) {
        if (sendersList[senderIndex][0][3] != -1) {
            var treatingItem = new Array;
            treatingItem.push (recipientsList[sendersList[senderIndex][0][3]][1].fsName.replace(/\\/g, '/'));
            treatingItem.push ("SELF");
            treatingItem.push ([sendersList[senderIndex][0][3]]);
            treatingList.push (treatingItem);
        }
    }
    if (scopesIndexes) {
        //sort scopes Indexes
        for (var si = 0; si < scopesIndexes.length - 1; si++) {
            for (var sc = si + 1; sc < scopesIndexes.length; sc++) {
                if (tsScopesList[scopesIndexes[sc]][2].length > tsScopesList[scopesIndexes[si]][2].length) {
                    var swapCell = scopesIndexes[sc];
                    scopesIndexes[sc] = scopesIndexes[si];
                    scopesIndexes[si] = swapCell;
                }
            }
        }
        var alreadyRecipientIndexList = new Array;
        if (senderIndex != -1) {
            if (sendersList[senderIndex][0][3] != -1) {
                alreadyRecipientIndexList.push (sendersList[senderIndex][0][3]);
            }
        }
        for (var sir = 0; sir < scopesIndexes.length; sir++) {
            var treatingItem = new Array;
            treatingItem.push (tsScopesList[scopesIndexes[sir]][1][5].parent.fsName.replace(/\\/g, '/'));
            treatingItem.push (tsScopesList[scopesIndexes[sir]][0]);
            treatingItem.push (new Array);
            for (var srl = 0; srl < tsScopesList[scopesIndexes[sir]][2].length; srl++) {
                var isDone = false;
                for (var ari = 0; ari < alreadyRecipientIndexList.length; ari++) {
                    if (alreadyRecipientIndexList[ari] == tsScopesList[scopesIndexes[sir]][2][srl]) {
                        isDone = true;
                        break;
                    }
                }
                if (isDone)
                    continue;
                alreadyRecipientIndexList.push (tsScopesList[scopesIndexes[sir]][2][srl]);
                treatingItem[2].push (tsScopesList[scopesIndexes[sir]][2][srl]);
            }
            if (treatingItem[2].length > 0) {
                treatingList.push (treatingItem);
            }
        }
    }
    var requestedFile = new File (tsVersionsPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/") + 1) + versionPrefix + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1));
    var versionDigits = versionPrefix.slice (-2);
    var digitsFileIDTriple = new Array;
    digitsFileIDTriple.push (versionDigits);
    digitsFileIDTriple.push (requestedFile);
    digitsFileIDTriple.push (fileID);
    var checkInResult = tsCheckIn (workshopFile, digitsFileIDTriple, false, false, false, true, false, true, senderIndex == -1? null : sendersList[senderIndex][0][0]);
    if (checkInResult == false || checkInResult == "CREATE_NEW" || checkInResult == "CHECKEDIN" || checkInResult == "SHADE") {
        return checkInResult;
    }

    if (requestedFile.exists) {
        if (!tsIsShade (requestedFile)) {
            //set thumbnail if fubricated
            var fubricatedMessageExtension = "";
            var thumbnailFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + versionDigits + "/V/" + versionTime + "/Thumbnail.jpg");
            if (workshopFile) {
                var workingThumbFile = new File (workshopFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (workshopFile.name)) + File.decode (workshopFile.name) + ".jpg");
                if (workingThumbFile.exists) {
                    var isToCopyWorkshopThumb = false;
                    if (thumbnailFile.exists) {
                        if (workingThumbFile.modified.getTime () > thumbnailFile.modified.getTime ()) {
                            isToCopyWorkshopThumb = true;
                        }
                    }
                    else {
                        thumbnailFile.parent.create ();
                        isToCopyWorkshopThumb = true;
                    }
                    if (isToCopyWorkshopThumb) {
                        workingThumbFile.copy (thumbnailFile);
                    }
                }
            }               
            if (thumbnailFile.exists) {
                if (tsGetMetadata (thumbnailFile, "TS_THUMB_FABRICATED")) {
                    fubricatedMessageExtension = ".jpg";
                }
            }
            for (var tl = 0; tl < treatingList.length; tl++) {
                var waitingFolder = new Folder (treatingList[tl][0] + "/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/Waited");
                if (!waitingFolder.exists)
                    waitingFolder.create ();
                //copying files to physical folder
                var requestedPhysicalFile = new File (waitingFolder.parent.fsName.replace(/\\/g, '/') + "/File");
                if (!requestedPhysicalFile.exists) {
                    var verTophysThumbnail = new Thumbnail (requestedFile);
                    if (requestedFile.length > 500000000) {
                        tsCopyToList.push ([verTophysThumbnail, waitingFolder.parent, "File"]);
                    }
                    else {
                        var isCopiedverTophysThumbnail = true;
                        try {
                            isCopiedverTophysThumbnail = verTophysThumbnail.copyTo (waitingFolder.parent);
                        }
                        catch (e) {
                            continue;
                        }
                        if (!isCopiedverTophysThumbnail)
                            continue;
                        File (waitingFolder.parent.fsName.replace(/\\/g, '/') + "/" + File.decode (requestedFile.name)).rename ("File");
                    }
                }
                var isWithPages = true;
                var isWithPDF = true;
                var packageLinks = null;
                if (isInDesignFile (requestedFile)) {
                    packageLinks = getPackageLinks (fileID, versionPrefix, modificationTime);
                    var requestedPagesFolder = Folder (requestedFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages).slice (0, -5));
                    var requestedPages = requestedPagesFolder.getFiles (isUnhiddenFile);
                    if (tsVersionsOutputZero == "ONLY_ZERO" && CVDigits == versionDigits) {
                        requestedPages = Folder (requestedPagesFolder.fsName.replace(/\\/g, '/').slice (0, requestedPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver")) + "/ver00" + requestedPagesFolder.fsName.replace(/\\/g, '/').slice (requestedPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver") + 6)).getFiles (isUnhiddenFile);
                    }
                    if (requestedPages.length > 0) {
                        var physicalPagesFolder = new Folder (waitingFolder.parent.fsName.replace(/\\/g, '/') + "/Pages");
                        var isPagesAlready = false;
                        if (!physicalPagesFolder.exists)
                            physicalPagesFolder.create ();
                        else {
                            if (physicalPagesFolder.getFiles (isUnhiddenFile).length == requestedPages.length) {
                                isPagesAlready = true;
                            }    
                        }
                        var physicalCountFile = new File (waitingFolder.parent.fsName.replace(/\\/g, '/') + "/Count");
                        if (!physicalCountFile.exists) {
                            if (!writeFile (physicalCountFile, requestedPages.length))
                                return false;
                        }
                        if (!isPagesAlready) {
                            for (var q = 0; q < requestedPages.length; q++) {
                                if (!requestedPages[q].copy (File (physicalPagesFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (requestedPages[q].name))))
                                    return false;
                            }
                        }
                    }
                    else {
                        isWithPages = false;
                    }
                    var physicalPrevPDFFile = new File (waitingFolder.parent.fsName.replace(/\\/g, '/') + "/PrevPDF");
                    if (!physicalPrevPDFFile.exists) {
                        var targetPrevPDFFile = new File (tsVersionsPDFPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + "/" + versionPrefix + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1, fileID_Path_newID[1].lastIndexOf (".")) + ".pdf");
                        if (targetPrevPDFFile.exists) {
                            targetPrevPDFFile.copy (physicalPrevPDFFile);
                        }
                        else {
                            isWithPDF = false;
                        }
                    }
                }
                var extraPackaging = "None";
                if (isWithPDF && isWithPages) {
                    extraPackaging = "With All";
                }
                else if (isWithPDF) {
                    extraPackaging = "With PDF";
                }
                else if (isWithPages) {
                    extraPackaging = "With Pages";
                }
                for (var tlr = 0; tlr < treatingList[tl][2].length; tlr++) {
                    var requiredFile = new File (tsDataPath + "/IDs" + fileID + "/Required/" + recipientsList[treatingList[tl][2][tlr]][0]);
                    if (!requiredFile.exists) {
                        if (!requiredFile.parent.exists)
                            requiredFile.parent.create ();
                        writeFile (requiredFile, "TS");
                    }
                    writeFile (File (waitingFolder.fsName.replace(/\\/g, '/') + "/" + recipientsList[treatingList[tl][2][tlr]][0]), "TS");
                    var messageTitle = versionDotID + "." + modificationTime + fubricatedMessageExtension;
                    //copying fubricated thumbnail file if exist
                    if (fubricatedMessageExtension) {
                        var cloudThumbnailFile = new File (recipientsList[treatingList[tl][2][tlr]][1].fsName.replace(/\\/g, '/') + "/Thumbnails/" + messageTitle);
                        if (!cloudThumbnailFile.parent.exists)
                            cloudThumbnailFile.parent.create ();
                        thumbnailFile.copy (cloudThumbnailFile);
                    }
                    var previousID = readFile (File (tsDataPath + "/IDs" + fileID + "/Previous ID"));
                    var originalID = readFile (File (tsDataPath + "/IDs" + fileID + "/Original ID"));
                    if (!previousID) previousID = "NO_ID";
                    if (!originalID) originalID = "NO_ID";
                    var messageContnet = ((CVFinal == "F") ? "Final" : "Proof") + ":" + "L" + treatingList[tl][1] + ":" + extraPackaging + ":" + previousID + ":" + originalID + "\n" + versionPrefix.slice (3) + "\n" + pathTime + "\n" + fileID_Path_newID[1];
                    if (packageLinks) {
                        messageContnet += "\n" + packageLinks;
                    }
                    tsIsSendingDone = false;
                    var sendingBoxesItem = new Array;
                    sendingBoxesItem.push ("Download");
                    sendingBoxesItem.push (messageTitle);
                    sendingBoxesItem.push (messageContnet);
                    recipientsList[treatingList[tl][2][tlr]][8][1].push (sendingBoxesItem);
                }
            }
        }
    }
    return true;
}

function tsLoadFile (fileID, versionDigits, creatorName, isActualFile) {
    /**///$.writeln ($.line);
    var recipientIndex = tsGetRecipientIndex (creatorName);
    if (recipientIndex != -1) {
        var fileDotID = fileID.replace (/\//g,"\.");
        fileDotID = fileDotID.slice (1);
        if (versionDigits == null) {
            versionDigits = "ver00";
        }
        tsIsSendingDone = false;
        var sendingBoxesItem = new Array;
        sendingBoxesItem.push ("IRequest");
        sendingBoxesItem.push (fileDotID + "." + versionDigits + ".0");
        sendingBoxesItem.push (isActualFile? "A" : "S"); //A abbreviation for Actual File, S abbreviation for Shade File
        recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
    }
    else {
    }
}

function getToBeCheckedFiles (scannedItem, allToBeCheckedFiles) {
    /**///$.writeln ($.line);
    if (scannedItem instanceof Folder) {
        var allFiles = scannedItem.getFiles (isAcceptedFileOrFolder);
        for (var c = 0; c < allFiles.length; c++) {
            getToBeCheckedFiles (allFiles[c], allToBeCheckedFiles);
        }
    }
    else {
        if (scannedItem.alias) {
            var actualFile = scannedItem.resolve ();
            if (actualFile) {
                if (actualFile.exists) {
                    scannedItem = actualFile;
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        if (scannedItem.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            allToBeCheckedFiles.push (scannedItem);
        }
        else if (scannedItem.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            allToBeCheckedFiles.push (File (scannedItem.parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (scannedItem.name).slice (6)));
        }
    }
    return true;
}

function changeRootHandler () {
    var isToSwitch = false;
    var rootFolderPathFile = new File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Path for " + tsClientID);
    var currentFolder = app.document.thumbnail.spec;
    tsUserImage = currentFolder.getFiles ("I'm *.jpg");
    if (tsUserImage.length == 1) {
        writeEncodedFile (rootFolderPathFile, currentFolder.fsName.replace(/\\/g, '/'));
    }
    else {
        if (tsPreviousRootPath) {
            isToSwitch = confirm ("Change to previous root folder?");
        }
        if (isToSwitch) {
            writeEncodedFile (rootFolderPathFile, tsPreviousRootPath);
        }
        else {
            var rootLocation = Folder.myDocuments.selectDlg ("Select root folder for Tree Shade.");
            if (!rootLocation) {
                return false;
            }
            writeEncodedFile (rootFolderPathFile, rootLocation.fsName.replace(/\\/g, '/'));
        }
    }
    tsPreviousRootPath = tsRootFolderPath;
    tsChangeRootRequested = true;
}

function getFileInfoHandler () {
    /**///$.writeln ($.line);
    var selectedThumbnail = app.document.selections[0];
    var targetFile = selectedThumbnail.spec;
    if (selectedThumbnail.container) {
        var selectedFolder = selectedThumbnail.spec;
        if (selectedFolder.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            var labelIDPair = tsGetLabel (selectedFolder, true, true);
            if (labelIDPair) {
                targetFile = labelIDPair[0];
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    if (targetFile.alias)
        targetFile = targetFile.resolve();
    if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
        targetFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (targetFile.name).slice (6));
        if (!targetFile.exists) {
            alert ("The file doesn't have working copy.");
            return false;
        }
    }
    if (targetFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
        var message = "";
        var fileID = tsGetID (targetFile);
        if (fileID) {
            if (File.decode (targetFile.name)[0] == '-') {
                var trsdTwin = getTotalGoal (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""), null, null, false);
                message += "\n---\nScopes:\n";
                if (trsdTwin[0].length > 0) {
                    message += "Real Syncronizing: \n";
                    for (var ausp = 0; ausp < trsdTwin[0].length; ausp++) {
                        message += "      " + tsScopesList[trsdTwin[0][ausp][0]][1][0];
                        if (ausp < trsdTwin[0].length - 1) {
                            message += ", ";
                        }
                    }
                }
                if (trsdTwin[1].length > 0) {
                    message += "\n---\nShade Syncronizing: \n";
                    for (var nosp = 0; nosp < trsdTwin[1].length; nosp++) {
                        message += "      " + tsScopesList[trsdTwin[1][nosp][0]][1][0];
                        if (nosp < trsdTwin[1].length - 1) {
                            message += ", ";
                        }
                    }
                }

                if (message == "Scopes:\n") {
                    message = "Out of all scopes.";
                }
            }
            else {
                var digitsFileIDTriple = getWorkshopVersionInfo (targetFile, fileID);
                if (digitsFileIDTriple) {
                    var IDCreatorFile = new File (tsDataPath + "/IDs" + fileID + "/Creator");
                    var IDCreatorContent = readFile (IDCreatorFile);
                    if (IDCreatorContent) {
                        var IDCreatorName = IDCreatorContent;
                        //searching for the user name
                        for (var idc = 0; idc < recipientsList.length; idc++) {
                            if (IDCreatorContent == recipientsList[idc][0]) {
                                IDCreatorName = recipientsList[idc][5];
                                break;
                            }
                        }
                        message += "\nCreator: " + IDCreatorName;
                    }
                    if (digitsFileIDTriple[0] != "new") {
                        message += "\nCurrent Version: " + digitsFileIDTriple[0] + ".";
                        var versionTimeFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/Modifying Time");
                        var versionTime = readFile (versionTimeFile);
                        if (versionTime) {
                            var modifiedDate = new Date (parseInt (versionTime, 10));
                            var dateString = modifiedDate.toLocaleDateString() + "\n\t" + modifiedDate.toLocaleTimeString();
                            message += "\nModified: " + dateString;
                            var versionCreatorFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/Creator");
                            var creatorID = readFile (versionCreatorFile);
                            if (creatorID) {
                                for (var recic = 0; recic < recipientsList.length; recic++) {
                                    if (creatorID == recipientsList[recic][0]) {
                                        message += "\nVersion Creator: " + recipientsList[recic][5];
                                        break;
                                    }
                                }
                            }
                            var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/V/" + versionTime + "/UnderEditingByOther");
                            if (underEditingByOtherFile.exists) {
                                var editorID = readFile (underEditingByOtherFile);
                                var editorName = editorID;
                                //searching for the user name
                                for (var reci = 0; reci < recipientsList.length; reci++) {
                                    if (editorID == recipientsList[reci][0]) {
                                        editorName = recipientsList[reci][5];
                                        break;
                                    }
                                }
                                message += "\nUnder Editing by: " + editorName;
                            }
                        }
                    }
                    else {
                        message += "\nNo version yet.";
                    }
                    var requiredFiles = Folder (tsDataPath + "/IDs" + fileID + "/Required").getFiles (isUnhiddenFile);
                    if (requiredFiles.length == 0) {
                        message += "\n\nNo collaborator has the file.";
                    }
                    else {
                        message += "\n\nCollaborators have the file:";
                        for (var m = 0; m < requiredFiles.length; m++) {
                            var recipientIndex = tsGetRecipientIndex (File.decode (requiredFiles[m].name));
                            if (recipientIndex != -1) {
                                //recipientsList[x][5] full name
                                //recipientsList[x][6] email
                                message += "\n" + recipientsList[recipientIndex][5] + " [" + recipientsList[recipientIndex][6] + "]";
                            }
                        }
                    }
                }
            }   
            tsGetText (message.split ("\n"), fileID.replace (/\//g,"\.").slice (1), false);
        }
    }
    else if (targetFile.parent.fsName.replace(/\\/g, '/').indexOf ("/Workflow/Collaborators/") != -1) {
        var imageInfo = tsGetUserInfo (targetFile);
        if (imageInfo) {
            alert ("Collaborator ID: " + imageInfo[0] + "\n" + "Name: " + imageInfo[1] + "\n" + "Email: " + imageInfo[2]);            
        }
    }
}

function directLinkToHandler () {
    /**///$.writeln ($.line);
    var newFile = File.openDialog ("Select a file to direct all documents's links from the selected file to it.");
    if (newFile) {
        if (newFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            var newID = tsGetID (newFile);
            var selectedThumbnail = app.document.selections[0];
            var oldID = tsGetID (selectedThumbnail.spec);
            if (oldID && newID) {
                if (oldID == newID) {
                    alert ("Select a different file to direct all the documents's links from the selected one to it.");
                    return false;
                }
                tsMoveToTrash (selectedThumbnail.spec, 1, ":" + newID, true, oldID, false);
            }
        }
    }
}

function newFromHandler (targetFiles, autoCheckInFol) {
    /**///$.writeln ($.line);
    var isRemoteTarget = false;
    var theSelFolderThumb = null;
    var mainMethod = "Main";
    if (targetFiles.length == 0) {
        if (tsRecentNewFromPath == "BBB") {
            tsRecentNewFromPath = tsWorkshopPath;
        }
        var defaultFolder = new Folder (tsRecentNewFromPath);
        targetFiles = defaultFolder.openDlg ("Select a file to create new Product.", "*", false);
        if (!targetFiles)
            return false;
        targetFiles = [targetFiles];
    }
    else {
        var isRemoteTargetFolderDetermined = false;
        if (autoCheckInFol) {
            mainMethod = "Main_Directly";
            tsNewFromRemoteTargetFolder = autoCheckInFol;
            isRemoteTargetFolderDetermined = true;
            isRemoteTarget = true;
        }
        else if (app.document.selections.length == 1) {
            if (app.document.selections[0].container) {
                tsNewFromRemoteTargetFolder = app.document.thumbnail.spec;
                isRemoteTargetFolderDetermined = true;
                isRemoteTarget = true;
                theSelFolderThumb = app.document.selections[0];
            }
            else if (app.document.selections[0].spec.name[0] == '-') {
                var isDeterminedNext = confirm ("Produce next this folder?");
                if (isDeterminedNext) {
                    tsNewFromRemoteTargetFolder = app.document.thumbnail.spec.parent;
                    isRemoteTargetFolderDetermined = true;
                    isRemoteTarget = true;
                }
            }
        }
        if (!isRemoteTargetFolderDetermined) {
            if (!tsNewFromRemoteTargetFolder) {
                tsNewFromRemoteTargetFolder = new Folder (tsWorkshopPath);
            }
            var newRemoteFolder = tsNewFromRemoteTargetFolder.selectDlg ("Select a folder. If empty will be used directy, if not then a new one inside it will be created.");
            if (!newRemoteFolder) {
                return false;
            }
            if ((newRemoteFolder.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0) {
                if (newRemoteFolder.getFiles (isAcceptedFileOrFolder) == 0) {
                    mainMethod = "Main_Empty";
                }
                tsNewFromRemoteTargetFolder = newRemoteFolder;
                isRemoteTarget = true;
            }
            else {
                alert ("The target folder for the new Product must be in Tree Shade 'Workshop' folder.");
                return false;
            }    
        }
    }
    var isAcceptChosenFileAsLabel = false;
    if (targetFiles.length == 1) {
        if (!targetFiles[0].exists)
            return false;
        if (tsIsShade (targetFiles[0]) && File.decode (targetFiles[0].name)[0] != '-') {
            if (!autoCheckInFol)
                alert ("The file you have selected is a shade, please load the actual file and try again.");
            return false;
        }
        tsRecentNewFromPath = targetFiles[0].parent.fsName.replace(/\\/g, '/');
        if (autoCheckInFol || isInDesignFile (targetFiles[0])) {
            isAcceptChosenFileAsLabel = true;
        }
    }
    var allFiles = new Array;
    var plainFiles = [""];
    for (var tf = targetFiles.length - 1; tf >= 0; tf--) {
        if (File.decode (targetFiles[tf].name)[0] == '-' || isAcceptChosenFileAsLabel) {
            var filesList = new Array;
            retrieveFilesList (targetFiles[tf].parent, filesList, true, []);
            var pre = [targetFiles[tf].parent.fsName.replace(/\\/g, '/') + "/"];
            allFiles.push (pre.concat (filesList));
        }
        else {
            plainFiles.push (targetFiles[tf]);
        }
    }
    
    for (var af1 = 0; af1 < allFiles.length - 1; af1++) {
        for (var af2 = af1 + 1; af2 < allFiles.length; af2++) {
            if (allFiles[af1].length < allFiles[af2].length) {
                var swap = allFiles[af1];
                allFiles[af1] = allFiles[af2];
                allFiles[af2] = swap;
            }
        }
    }
    allFiles.push (plainFiles);
    for (var af1 = allFiles.length - 1; af1 > 0; af1--) {
        for (var a1 = allFiles[af1].length - 1; a1 > 0; a1--) {
            var isRepeated = false;
            for (var af2 = 0; af2 < af1; af2++) {
                for (var a2 = 1; a2 < allFiles[af2].length; a2++) {
                    if (allFiles[af2][a2].fsName.replace(/\\/g, '/') == allFiles[af1][a1].fsName.replace(/\\/g, '/')) {
                        allFiles[af1].splice (a1, 1);
                        isRepeated = true;
                        break;
                    }
                }
                if (isRepeated) break;
            }
        }
        if (allFiles[af1].length == 1) {
            allFiles.splice (af1, 1);
        }
    }
    if (allFiles.length > 0) {
        if (allFiles[0][0] == "") {
            if (allFiles[0].length > 1) {
                var lastSlashIndex = 0;
                var pickedPath = allFiles[0][1].fsName.replace(/\\/g, '/').slice (0, allFiles[0][1].fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1);
                for (var ffp = 0; ffp < pickedPath.length; ffp++) {
                    var isAllMatch = true;
                    for (var ffm = 2; ffm < allFiles[0].length; ffm++) {
                        var toBeTest = allFiles[0][ffm].fsName.replace(/\\/g, '/').slice (0, allFiles[0][ffm].fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1);
                        if (toBeTest.length == ffp) {
                            isAllMatch = false;
                            break;
                        }
                        else if (pickedPath[ffp] != toBeTest[ffp]) {
                            isAllMatch = false;
                            break;
                        }
                    }
                    if (!isAllMatch) {
                        break;
                    }
                    if (pickedPath[ffp] == "/") {
                        lastSlashIndex = ffp;
                    }
                }
                allFiles[0][0] = pickedPath.slice (0, lastSlashIndex + 1);
            }
        }
    }
    var producingList = new Array;
    for (var af3 = 0; af3 <allFiles.length; af3++) {
        var producingItem = [mainMethod];
        if (mainMethod == "Main_Directly") {
            tsGetProduceDirecty (allFiles[af3], producingItem, "");
        }
        else {
            tsGetProduce (allFiles[af3], producingItem, "");   
        }
        producingList.push (producingItem);
    }
    //get information 
    var mainThumbnail = app.document.thumbnail;
    var theFirstFolder = null;
    for (var af4 = 0; af4 <allFiles.length; af4++) {
        var newProductFolder = null;
        if (isRemoteTarget) {
            newProductFolder = tsNewFromRemoteTargetFolder;
        }
        else {
            if (producingList[af4][1][0] == app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/") { 
                newProductFolder = app.document.thumbnail.spec.parent;
            }
            else {
                newProductFolder = app.document.thumbnail.spec;
            }
        }
        if (!newProductFolder)
            return false;
        if (af4 == 0) {
            theFirstFolder = newProductFolder;
        }
        var returned = tsGetProduceInfo (mainThumbnail, newProductFolder, producingList[af4], newProductFolder.fsName.replace(/\\/g, '/'));
        if (returned == false)
            return false;
    }
    //newProductPathIDPairs 
    var newProductPathIDPairs = new Array;
    for (af4 = 0; af4 <allFiles.length; af4++) {
        tsExecuteProduce (producingList[af4], newProductPathIDPairs);
    }
    for (var npp = 0; npp <newProductPathIDPairs.length; npp++) {
        var digitsFileIDTriple = getWorkshopVersionInfo (File (newProductPathIDPairs[npp][0]), newProductPathIDPairs[npp][1]);
        if (digitsFileIDTriple)
            tsCheckIn (File (newProductPathIDPairs[npp][0]), digitsFileIDTriple, false, true, true, true, false, true, null);
    }
    var targetProducersList = new Array;
    //targetProducersList[x][0] Producer ID
    //targetProducersList[x][1] List of (file path, id, new path) pairs of indesign
    var isToCheckInInDesign = [null];
    if (mainMethod == "Main_Directly") {
        isToCheckInInDesign = [true];
    }
    for (af4 = 0; af4 <allFiles.length; af4++) {
        tsProducersList (producingList[af4], newProductPathIDPairs, targetProducersList, isToCheckInInDesign);
    }
    var orderID = "#" + tsUserID + (new Date ().getTime ());
    for (var tp = 0; tp < targetProducersList.length; tp++) {
        var recipientIndex = tsGetRecipientIndex (targetProducersList[tp][0]);
        if (recipientIndex != -1) {
            var totalPairs = newProductPathIDPairs.concat (targetProducersList[tp][1]);
            for (var npp = 0; npp < totalPairs.length; npp++) {
                var productFile = new File (totalPairs[npp][0]);
                var isWorkshopOrVersion = 1;
                var versionFullDotID = null;
                if (File.decode (productFile.name)[0] == '-' && tsIsShade (productFile)) {
                    var fileID_Path_newID = [totalPairs[npp][1]];
                    var pathTime = tsGetPath (fileID_Path_newID);
                    if (!pathTime)
                        return false;
                    versionFullDotID = totalPairs[npp][1].replace (/\//g,"\.");
                    versionFullDotID = versionFullDotID.slice (1);
                    versionFullDotID += ".pth00." + pathTime;
                }
                else {
                    var digitsFileIDTriple = getWorkshopVersionInfo (productFile, totalPairs[npp][1]);
                    if (!digitsFileIDTriple)
                        return false;
                    if (digitsFileIDTriple[0] == "new") {
                        return false;
                    }
                    var versionTimeFile = new File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/ver" + digitsFileIDTriple[0] + "/Modifying Time");
                    var versionTime = readFile (versionTimeFile);
                    if (!versionTime) {
                        return false;
                    }
                    versionFullDotID = digitsFileIDTriple[2].replace (/\//g,"\.");
                    versionFullDotID = versionFullDotID.slice (1);
                    versionFullDotID += ".ver" + digitsFileIDTriple[0] + "." + versionTime;
                }
                var theMessage = orderID + ":" + totalPairs.length;
                if (totalPairs[npp].length > 2) {
                    theMessage += "\n" + "Produce:" + totalPairs[npp][2];
                }
                //sending
                tsIsSendingDone = false;
                var sendingBoxesItem = new Array;
                sendingBoxesItem.push ("HaveYou");
                sendingBoxesItem.push ("Info");
                var messageContent = "Message" + "\n" + versionFullDotID + ":" + isWorkshopOrVersion + ":" + targetProducersList.length + ":" + "N" + "\n" + theMessage;
                sendingBoxesItem.push (messageContent);
                recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
            }
        }
    }
    //go to the new folder
    if (theFirstFolder && mainMethod != "Main_Directly") {
        var createdFolder = new Folder (theFirstFolder.fsName.replace(/\\/g, '/') + "/" + producingList[0][1][1][0][0][1]);
        app.document.thumbnail = new Thumbnail (createdFolder);
        if (theSelFolderThumb) {
            tsToBeSelectedThumbnail = theSelFolderThumb;
            tsLoadStage = 1;
            app.document.thumbnail = tsToBeSelectedThumbnail.parent;
        }
    }
}

function tsProducersList (producingList, newProductPathIDPairs, targetProducersList, isToCheckInInDesign) {
    for (var pl = 0; pl < producingList[1][2].length; pl++) {
        var fileID = tsGetID (producingList[1][2][pl]);
        if (fileID) {
            var versionCreatorFile = null;
            if (!tsIsIgnoreVersionOwner) {
                var digitsFileIDTriple = getWorkshopVersionInfo (producingList[1][2][pl], fileID);
                if (digitsFileIDTriple) {
                    if (digitsFileIDTriple[0] != "new") {
                        versionCreatorFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/Creator");
                    }
                }
            }
            if (versionCreatorFile && versionCreatorFile.exists) {
                var creatorName = readFile (versionCreatorFile);
                if (creatorName) {
                    var producerIndex = -1;
                    for (var tp = targetProducersList.length - 1; tp >= 0; tp--) {
                        if (targetProducersList[tp][0] == creatorName) {
                            producerIndex = tp;
                            break;
                        }
                    }
                    if (producerIndex == -1) {
                        producerIndex = targetProducersList.length;
                        targetProducersList.push ([creatorName, new Array]);
                    }
                    var newPath = producingList[1][1][0][0][0].fsName.replace(/\\/g, '/') + "/" + producingList[1][2][pl].fsName.replace(/\\/g, '/').replace (producingList[1][0], "");
                    newPath = newPath.replace (tsWorkshopPath, "");
                    targetProducersList[producerIndex][1].push ([producingList[1][2][pl].fsName.replace(/\\/g, '/'), fileID, newPath]);
                }
            }
            else {
                newPathIDList = tsChangeFile (producingList[1][2][pl], File (producingList[1][1][0][0][0].fsName.replace(/\\/g, '/') + "/" + producingList[1][2][pl].fsName.replace(/\\/g, '/').replace (producingList[1][0], "")), true, 5, false);
                if (newPathIDList) {
                    if (isToCheckInInDesign[0] == null) {
                        isToCheckInInDesign[0] = confirm ("Do you want to check in the documents which you created?");
                    }
                    if (isToCheckInInDesign[0]) {
                        newProductPathIDPairs.push (newPathIDList);
                        var digitsFileIDTriple = getWorkshopVersionInfo (File (newProductPathIDPairs[newProductPathIDPairs.length - 1][0]), newProductPathIDPairs[newProductPathIDPairs.length - 1][1]);
                        if (digitsFileIDTriple) {
                            var PDFPreviewIndex = -1;
                            for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                                if (newProductPathIDPairs[newProductPathIDPairs.length - 1][0] == tsAlertPDFPreviewList[ppl][0]) {
                                    PDFPreviewIndex = ppl;
                                    break;
                                }
                            }
                            if (PDFPreviewIndex == -1) {
                                tsAlertPDFPreviewList.push ([
                                    newProductPathIDPairs[newProductPathIDPairs.length - 1][0], //The document full path
                                    digitsFileIDTriple[2], //fileID
                                    digitsFileIDTriple[0], //versionNumber
                                    false, //isWithFinal
                                    0, //count down
                                    0 //skips count
                                ]);
                            }
                        }
                    }
                }
            }
        }
    }
}

function tsExecuteProduce (producingList, newProductPathIDPairs) {
    for (var pi = 0; pi < producingList[1][1].length; pi++) {
        var newBaseFolder = producingList[1][1][pi][0][0];
        newBaseFolder.create ();
        //[1][0] Labels New Names
        var newPathIDList = null;
        for (var pl = 0; pl < producingList[1][1][pi][1][0].length; pl++) {
            var sourceIndex = producingList[1][1][pi][1][0][pl][0];
            var product = producingList[1][3][sourceIndex][1];
            var rootToFilePortion = (product.parent.fsName.replace(/\\/g, '/') + "/").replace (producingList[1][0], "");
            if (rootToFilePortion != "")
                rootToFilePortion = rootToFilePortion + "/";
            newPathIDList = tsChangeFile (new File (product.fsName.replace(/\\/g, '/')), new File (newBaseFolder.fsName.replace(/\\/g, '/') + "/" + rootToFilePortion + producingList[1][1][pi][1][0][pl][1]), true, 5, false);
            if (newPathIDList)
                newProductPathIDPairs.push (newPathIDList);
        }
        //[1][1] LiveSnippets New Contents
        for (var pl = 0; pl < producingList[1][1][pi][1][1].length; pl++) {
            var sourceIndex = producingList[1][1][pi][1][1][pl][0];
            var product = producingList[1][3][sourceIndex][1];
            var targetLiveSnippetFile = new File (newBaseFolder.fsName.replace(/\\/g, '/') + "/" + product.fsName.replace(/\\/g, '/').replace (producingList[1][0], ""));
            if (!targetLiveSnippetFile.parent.exists)
                targetLiveSnippetFile.parent.create ();
            targetLiveSnippetFile.encoding = "UTF8";
            writeFile (targetLiveSnippetFile, producingList[1][1][pi][1][1][pl][1]);

            var idThumbFile = new File (product.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (product.name)) + File.decode (product.name) + ".jpg");
            var destinationIdThumbFile = File (targetLiveSnippetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetLiveSnippetFile.name)) + File.decode (targetLiveSnippetFile.name) + ".jpg");
            if (!destinationIdThumbFile.parent.exists)
                destinationIdThumbFile.parent.create ();
            idThumbFile.copy (destinationIdThumbFile);

            newPathIDList = new Array;
            newPathIDList.push (targetLiveSnippetFile.fsName.replace(/\\/g, '/'));
            newPathIDList.push (tsUpdateFileState (targetLiveSnippetFile, -2, -1));
            newProductPathIDPairs.push (newPathIDList);
        }
        //[1][2] New Replacements Files
        for (var pl = 0; pl < producingList[1][1][pi][1][2].length; pl++) {
            var sourceIndex = producingList[1][1][pi][1][2][pl][0];
            var product = producingList[1][3][sourceIndex][1];
            var sourceName = File.decode (producingList[1][1][pi][1][2][pl][1].name);
            var prefix = "";
            var pureName = sourceName;
            var extension = "";
            if (sourceName.indexOf (".") > 0) {
                extension = sourceName.slice (sourceName.lastIndexOf ("."));
            }
            pureName = tsGetPureName (sourceName, false);
            if (producingList[1][1][pi][1][2][pl][2]) {
                pureName = producingList[1][1][pi][1][2][pl][2];
            }
            var targetName = prefix + pureName + extension;
            var theSub = product.fsName.replace(/\\/g, '/').replace (producingList[1][0], "");
            if (theSub.indexOf ("/") != -1) {
                theSub = theSub.slice (0, theSub.lastIndexOf ("/") + 1);
            }
            else {
                theSub = "";
            }
            newPathIDList = tsChangeFile (producingList[1][1][pi][1][2][pl][1], new File (newBaseFolder.fsName.replace(/\\/g, '/') + "/" + theSub + targetName), true, 5, false);
            if (newPathIDList)
                newProductPathIDPairs.push (newPathIDList);
        }
        //[1][3] Links New Replacements Folders
        for (var pl = 0; pl < producingList[1][1][pi][1][3].length; pl++) {
            var sourceIndex = producingList[1][1][pi][1][3][pl][0];
            var product = producingList[1][3][sourceIndex][1];
            var allNewFolderFiles = new Array;
            retrieveFilesList (producingList[1][1][pi][1][3][pl][1], allNewFolderFiles, false, []);
            for (var nff = 0; nff < allNewFolderFiles.length; nff++) {
                var newPrefixPath = allNewFolderFiles[nff].parent.fsName.replace(/\\/g, '/').replace (producingList[1][1][pi][1][3][pl][1].fsName.replace(/\\/g, '/'), "");
                if (newPrefixPath == "")
                    newPrefixPath = "/";
                else 
                    newPrefixPath += "/";                    
                newPathIDList = tsChangeFile (allNewFolderFiles[nff], new File (newBaseFolder.fsName.replace(/\\/g, '/') + "/" + Folder (product).fsName.replace(/\\/g, '/').replace (producingList[1][0], "") + newPrefixPath + File.decode (allNewFolderFiles[nff].name)), true, 5, false);
                if (newPathIDList)
                    newProductPathIDPairs.push (newPathIDList);
            }
        }
    }
    for (var sl = 0; sl < producingList[1][3].length; sl++) {
        if (producingList[1][3][sl][0] == "List") {
            tsExecuteProduce (producingList[1][3][sl], newProductPathIDPairs);
        }
    }
}

function tsGetProduceInfo (mainThumbnail, parentListFolder, producingList, mainPath) {
    var newProductFolder = null;
    var newLocationName = null;
    if (producingList[0].indexOf("Main") == 0) {
        if (producingList[0] == "Main_Empty" || producingList[0] == "Main_Directly") {
            newProductFolder = parentListFolder;
        }
        else {
            newProductFolder = tsProduceNextFolder (parentListFolder, "New Product Folder Name:");
        }
        newLocationName = newProductFolder.fsName.replace(/\\/g, '/').slice (newProductFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1);
    }
    else {
        if (producingList[1][1].length > 0) {
            newLocationName = tsNextIncrement (producingList[1][1][producingList[1][1].length - 1][0][1], " A");
        }
        else {
            newLocationName = producingList[1][0].slice (0, producingList[1][0].lastIndexOf ("/"));
            newLocationName = newLocationName.slice (newLocationName.lastIndexOf ("/") + 1);
        }
        newProductFolder = new Folder (parentListFolder.fsName.replace(/\\/g, '/') + "/" + newLocationName);
    }
    if (!newProductFolder)
        return false;
    var newSubDisplay = "..." + newProductFolder.fsName.replace(/\\/g, '/').replace (mainPath, "");
    var newProductItem = new Array;
    newProductItem.push (new Array); // Base Info
    newProductItem[0].push (newProductFolder); //[0][0] new increment folder
    newProductItem[0].push (newLocationName); //[0][1] new location name
    newProductItem.push (new Array); // Product Files
    newProductItem[1].push (new Array); //[1][0] Labels New Names
    newProductItem[1].push (new Array); //[1][1] LiveSnippets New Contents
    newProductItem[1].push (new Array); //[1][2] New Replacements Files
    newProductItem[1].push (new Array); //[1][3] Links New Folders
    for (var pl = 0; pl < producingList[1][3].length; pl++) {
        switch(producingList[1][3][pl][0]) {
            case "Label": //[0] Labels New Names
                var labelPureName = File.decode (producingList[1][3][pl][1].name);
                labelPureName = labelPureName.replace(/-\s*/, "");
                var labelExtension = "";
                if (labelPureName.lastIndexOf (".") != -1) {
                    labelExtension = labelPureName.slice (labelPureName.lastIndexOf ("."));
                    labelPureName = labelPureName.slice (0, labelPureName.lastIndexOf ("."));
                }
                //select the file
                tsToBeSelectedThumbnail = new Thumbnail (producingList[1][3][pl][1]);
                tsLoadStage = 1;
                app.document.thumbnail = tsToBeSelectedThumbnail.parent;
                //get new content 
                var newLabel = tsGetText (["Label: " + newSubDisplay + "/" + (producingList[1][3][pl][1].parent.fsName.replace(/\\/g, '/') + "/").replace (producingList[1][0], "")], labelPureName, false);
                //return to mainThumbnail
                app.document.thumbnail = mainThumbnail;
                if (!newLabel) {
                    var isToContinue = confirm ("Continue producing?");
                    if (!isToContinue)
                        return false;
                }
                else {
                    newProductItem[1][0].push ([pl, "- " + newLabel + labelExtension]);
                }
                break;
            case "Live Snippet": //[1] LiveSnippets New Contents
                //get new content
                producingList[1][3][pl][1].encoding = "UTF8";
                var promptMes = "";
                var theSnippetContent = readFile (producingList[1][3][pl][1]);
                var isDynamicSnippet = false;
                if (theSnippetContent.indexOf (tsDynamicSnippetTag) == 0 && theSnippetContent.indexOf (":\n") == -1) {
                    isDynamicSnippet = true;
                }
                else {
                    //select the file
                    tsToBeSelectedThumbnail = new Thumbnail (producingList[1][3][pl][1]);
                    tsLoadStage = 1;
                    app.document.thumbnail = tsToBeSelectedThumbnail.parent;
                    promptMes = [newSubDisplay + "/" + producingList[1][3][pl][1].fsName.replace(/\\/g, '/').replace (producingList[1][0], "")];
                    if (theSnippetContent == "no_text") {
                        theSnippetContent = "";
                    }
                }
                var newContent = theSnippetContent;
                if (!isDynamicSnippet) {
                    newContent = tsGetText (promptMes, theSnippetContent, true);
                    //return to mainThumbnail
                    app.document.thumbnail = mainThumbnail;
                    if (newContent == null) {
                        var isToContinue = confirm ("Continue producing?");
                        if (!isToContinue)
                            return false;
                    }
                }
                if (newContent == "" && !isDynamicSnippet) {
                    newContent = "no_text";
                }
                newProductItem[1][1].push ([pl, newContent]);
                break;
            case "File": //[2] New Replacements Files
                var pickFolder = producingList[1][3][pl][1].parent;
                var newReplacementFile = null;
                if (producingList[1][3][pl][2]) {
                    if (producingList[1][3][pl][2] == "SAME") {
                        newReplacementFile = producingList[1][3][pl][1];
                    }
                    else {
                        var fileID_Path_newID = [producingList[1][3][pl][2]];
                        tsGetPath (fileID_Path_newID);
                        if (fileID_Path_newID[1]) {
                            var pickFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                            if (pickFile.exists) {
                                pickFolder = pickFile.parent;
                            }
                        }
                    }
                }
                var newFileName = false;
                var filePureName = "";
                if (producingList[1][3][pl][3] == "3") { //name method
                    var filePureName = File.decode (producingList[1][3][pl][1].name);
                    filePureName = tsGetPureName (filePureName, false);
                }
                if (!newReplacementFile) {
                    //select the file
                    tsToBeSelectedThumbnail = new Thumbnail (producingList[1][3][pl][1]);
                    tsLoadStage = 1;
                    app.document.thumbnail = tsToBeSelectedThumbnail.parent;
                    //get new replacement
                    newReplacementFile = pickFolder.openDlg ("Select a new file for " + newSubDisplay + "/" + producingList[1][3][pl][1].fsName.replace(/\\/g, '/').replace (producingList[1][0], ""), "*", false);
                    if (newReplacementFile && producingList[1][3][pl][3] == "3") { //name method
                        //get new name 
                        newFileName = tsGetText (["New File Name: " + newSubDisplay + "/" + (producingList[1][3][pl][1].parent.fsName.replace(/\\/g, '/') + "/").replace (producingList[1][0], "")], filePureName, false);
                    }
                    else if (newReplacementFile && producingList[1][3][pl][3] == "1") { //name method
                        newFileName = filePureName;
                    }
                    //return to mainThumbnail
                    app.document.thumbnail = mainThumbnail;
                    if (!newReplacementFile || newFileName == null) {
                        var isToContinue = confirm ("Continue producing?");
                        if (!isToContinue)
                            return false;
                    }
                    else {
                        newProductItem[1][2].push ([pl, newReplacementFile, newFileName]);
                    }
                }
                else {
                    if (newReplacementFile && producingList[1][3][pl][3] == "3") { //name method
                        //select the file
                        tsToBeSelectedThumbnail = new Thumbnail (producingList[1][3][pl][1]);
                        tsLoadStage = 1;
                        app.document.thumbnail = tsToBeSelectedThumbnail.parent;
                        newFileName = tsGetText (["New File Name: " + newSubDisplay + "/" + (producingList[1][3][pl][1].parent.fsName.replace(/\\/g, '/') + "/").replace (producingList[1][0], "")], filePureName, false);
                        //return to mainThumbnail
                        app.document.thumbnail = mainThumbnail;                        
                        if (newFileName == null) {
                            var isToContinue = confirm ("Continue producing?");
                            if (!isToContinue)
                                return false;
                        }
                    }
                    newProductItem[1][2].push ([pl, newReplacementFile, newFileName]);
                }
                break;
            case "Links": //[3] Links New Folders
                //select the file
                app.document.thumbnail = new Thumbnail (new Folder (producingList[1][3][pl][1]));
                //new links
                var newReplacementFolder = Folder.myDocuments.selectDlg ("Select a new folder to replace " + newSubDisplay + "/" + producingList[1][3][pl][1].replace (producingList[1][0], ""));
                //return to mainThumbnail
                app.document.thumbnail = mainThumbnail;
                if (!newReplacementFolder) {
                    var isToContinue = confirm ("Continue producing?");
                    if (!isToContinue)
                        return false;
                }
                else {
                    newProductItem[1][3].push ([pl, newReplacementFolder]);
                }
                break;
            case "List":
                var returned = false;
                var count = 0;
                var subParentListFolder = new Folder (newProductFolder.fsName.replace(/\\/g, '/') + ((producingList[1][3][pl][1][4]== "")? "" : "/" + producingList[1][3][pl][1][4]));
                var subParentFolder = null;
                for (var pll = 0; pll < producingList[1][3][pl][1][3].length; pll++) {
                    if (producingList[1][3][pl][1][3][pll][0] != "List" && producingList[1][3][pl][1][3][pll][0] != "Links") {
                        subParentFolder = producingList[1][3][pl][1][3][pll][1].parent;
                        break;
                    }
                }
                var mainListThumb = null;
                var itemListThumb = null;
                var listThumbs = new Array;
                for (var pll = 0; pll < producingList[1][3][pl][1][3].length; pll++) {
                    if (producingList[1][3][pl][1][3][pll][0] != "List" && producingList[1][3][pl][1][3][pll][0] != "Links") {
                        if (mainListThumb == null) {
                            var listRootFolder = producingList[1][3][pl][1][3][pll][1].parent.parent;
                            if (listRootFolder) {
                                var labelIDPair = tsGetLabel (listRootFolder, false, false);
                                if (labelIDPair) {
                                    mainListThumb = new Thumbnail (labelIDPair[0]);
                                    break;
                                }
                            }
                            mainListThumb = false;
                        }
                        if (File.decode (producingList[1][3][pl][1][3][pll][1].name)[0] == '-') {
                            if (!itemListThumb) {
                                itemListThumb = new Thumbnail (producingList[1][3][pl][1][3][pll][1]);
                            }
                        }
                        else {
                            listThumbs.push (new Thumbnail (producingList[1][3][pl][1][3][pll][1]));
                        }
                    }
                }
                do {
                    if (subParentFolder) {
                        var toBeSelected = null;
                        if (count == 0) {
                            if (mainListThumb) {
                                toBeSelected = mainListThumb;
                            }
                            else if (itemListThumb) {
                                toBeSelected = itemListThumb;
                            }
                            else {
                                toBeSelected = listThumbs;
                            }
                        }
                        else {
                            if (itemListThumb) {
                                toBeSelected = itemListThumb;
                            }
                            else if (mainListThumb) {
                                toBeSelected = mainListThumb;
                            }
                            else {
                                toBeSelected = listThumbs;
                            }
                        }
                        if (toBeSelected instanceof Array) {
                            app.document.thumbnail = new Thumbnail (subParentFolder);
                            for (var lth = 0; lth < toBeSelected.length; lth++) {
                                app.document.select (toBeSelected[lth]);
                            }
                        }
                        else if (toBeSelected) {
                            tsToBeSelectedThumbnail = toBeSelected;
                            tsLoadStage = 1;
                            app.document.thumbnail = tsToBeSelectedThumbnail.parent;        
                        }
                    }
                    else {
                        app.document.thumbnail = mainThumbnail;
                    }
                    var isToContinueList = null;
                    if (count == 0) {
                        isToContinueList = confirm ("Start in producing the list?");
                        returned = !isToContinueList? null : returned;
                    }
                    else {
                        returned = null;
                        isToContinueList = confirm ("You have now " + count + " item" + (count > 1? "s.\n":".\n") + "Produce new one in this list?");
                    }
                    if (isToContinueList) {
                        app.document.thumbnail = mainThumbnail;
                        returned = tsGetProduceInfo (mainThumbnail, subParentListFolder , producingList[1][3][pl], mainPath);
                    }
                    count++;
                } while (returned); 
                if (returned == false) {
                    return returned;
                }
                break;
            default:
                return false;
        }
    }
    producingList[1][1].push (newProductItem);
    return true;
}

function tsGetProduceDirecty (filesList, producingList, parentBasePath) {
    var producingItem = new Array;
    //producingItem
    producingItem.push (filesList[0]); //[0] label root
    producingItem.push (new Array); //[1] new products lists, will be added later
    producingItem.push (new Array); //[2] InDesign List
    producingItem.push (new Array); //[3] Elements List
    producingItem.push (parentBasePath); //[4] parent base List path
    for (var fl = 1; fl < filesList.length; fl++) {
        var elementItem = new Array;
        //elementItem[0] "List", "Links", "Label", "Live Snippet", "File"
        //elementItem[1] if List: producingItem, if Links: path, if Label, live Snippet or File: the file object 
        var thePhrase = "SAME";
        var nameMethod = "1";
        if (!isInDesignFile (filesList[fl])) {
            elementItem.push ("File");
            elementItem.push (filesList[fl]);
            elementItem.push (thePhrase);
            elementItem.push (nameMethod);
        }
        if (elementItem.length != 0) {
            producingItem[3].push (elementItem);
        }
        else { //It's InDesign File
            producingItem[2].push (filesList[fl]);
        }
    }
    producingList.push (producingItem);
}

function tsGetProduce (filesList, producingList, parentBasePath) {
    var producingItem = new Array;
    //producingItem
    producingItem.push (filesList[0]); //[0] label root
    producingItem.push (new Array); //[1] new products lists, will be added later
    producingItem.push (new Array); //[2] InDesign List
    producingItem.push (new Array); //[3] Elements List
    producingItem.push (parentBasePath); //[4] parent base List path
    for (var fl = 1; fl < filesList.length; fl++) {
        var elementItem = new Array;
        //elementItem[0] "List", "Links", "Label", "Live Snippet", "File"
        //elementItem[1] if List: producingItem, if Links: path, if Label, live Snippet or File: the file object 
        var relativePath = (filesList[fl].parent.fsName.replace(/\\/g, '/') + "/").replace (filesList[0], "");
        if (relativePath.search (/List\/[^\/]+\//) != -1) {
            var subFilesList = new Array;
            var basePath = relativePath.slice (0, relativePath.indexOf ("List/") + 5);
            var restPath = relativePath.slice (relativePath.indexOf ("List/") + 5);
            var subPath = basePath + restPath.slice (0, restPath.indexOf ("/"));
            subFilesList.push (filesList[0] + subPath + "/");
            subFilesList.push (filesList[fl]);
            for (var sfl = fl + 1; sfl < filesList.length; sfl++) {
                if (filesList[sfl].fsName.replace(/\\/g, '/').indexOf (filesList[0] + basePath) == 0) {
                    if (filesList[sfl].fsName.replace(/\\/g, '/').indexOf (filesList[0] + subPath + "/") == 0) {
                        if (filesList[sfl].fsName.replace(/\\/g, '/').indexOf (subFilesList[0]) == 0) {
                            subFilesList.push (filesList[sfl]);   
                        }
                    }
                    fl++;
                }
            }
            elementItem.push ("List");
            tsGetProduce (subFilesList, elementItem, basePath);
        }
        else if (relativePath.indexOf ("Links/") != -1) {
            var suggestedLinksPath = filesList[0] + relativePath.slice (0, relativePath.indexOf ("Links/") + 5);
            for (var pe = 0; pe < producingItem[3].length; pe++) {
                if (producingItem[3][pe][0] == "Links") {
                    if (producingItem[3][pe][1] == suggestedLinksPath) {
                        suggestedLinksPath = null;
                        break;   
                    }
                }
            }
            if (suggestedLinksPath) {
                elementItem.push ("Links");
                elementItem.push (suggestedLinksPath);
            }
        }
        else {
            var thePhrase = null;
            var nameMethod = null;
            var thumbnailFile = new File (filesList[fl].parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (filesList[fl].name)) + File.decode (filesList[fl].name) + ".jpg");
            if (thumbnailFile.exists) {
                thePhrase = tsGetMetadata (thumbnailFile, "TS_PRODUCING_PICK");
                nameMethod = tsGetMetadata (thumbnailFile, "TS_PRODUCING_NAME");
            }
            else if (filesList[fl].name == "ts_sort.txt") {
                thePhrase = "SAME";
                nameMethod = "1";
            }
            if (filesList[fl].name[0] == '-' && !thePhrase) {
                elementItem.push ("Label");
                elementItem.push (filesList[fl]);
            }
            else if (tsIsLiveSnippetFile (filesList[fl]) && !thePhrase) {
                elementItem.push ("Live Snippet");
                elementItem.push (filesList[fl]);
            }
            else if (!isInDesignFile (filesList[fl])) {
                elementItem.push ("File");
                elementItem.push (filesList[fl]);
                elementItem.push (thePhrase);
                elementItem.push (nameMethod);
            }
        }
        if (elementItem.length != 0) {
            producingItem[3].push (elementItem);
        }
        else { //It's InDesign File
            producingItem[2].push (filesList[fl]);
        }
    }
    producingList.push (producingItem);
}

function tsProduceNextFolder (parentFolder, askMess) {
    var returnedFolder = null;
    var allFolders = parentFolder.getFiles (isAcceptedFolder);
    var promptName = null;
    var lastFolderName = "0000";
    if (allFolders.length > 0) {
        lastFolderName = File.decode (allFolders[allFolders.length - 1].name);
    }
    do {
        lastFolderName = tsNextIncrement (lastFolderName, null);
        if (!lastFolderName) {
            if (!askMess)
                return null;
            promptName = prompt ((promptName? "Already Exist! " : "") + askMess, promptName);
            if (!promptName)
                return null;
            lastFolderName = promptName;
        }
        returnedFolder = new Folder (parentFolder.fsName.replace(/\\/g, '/') + "/" + lastFolderName);
    }
    while (returnedFolder.exists);
    return returnedFolder;
}

function tsNextIncrement (oldText, Appendix) {
    if (oldText.search (/[0-9A-Z]+(?![\w])/) != -1) {
        var shiftPhrase = oldText.match (/[0-9A-Z]+(?![\w])/)[0];
        if (oldText.search (/^ID[A-Z0-9]+/) != -1) {
            var idPart = shiftPhrase.slice (2);
            if (idPart.length > 4) {
                shiftPhrase = "ID" + tsMakeRandom (idPart.length, "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
            }
            else {
                shiftPhrase = "ID" + tsNextChar (idPart);
            }
        }
        else {
            shiftPhrase = tsNextChar (shiftPhrase);
        }
        oldText = oldText.replace (/[0-9A-Z]+(?![\w])/, shiftPhrase);
        return oldText;
    }
    else if (Appendix) {
        return oldText + Appendix;
    }
    return null;
}

function tsNextChar (c) {
    var u = c.toUpperCase();
    if (tsSame (u, 'Z')){
        var txt = '';
        var i = u.length;
        while (i--) {
            txt += '0';
        }
        return (txt+'0');
    } else {
        var p = "";
        var q = "";
        if(u.length > 1){
            p = u.substring(0, u.length - 1);
            q = String.fromCharCode(p.slice(-1).charCodeAt(0));
        }
        var l = u.slice(-1).charCodeAt(0);
        var z = tsNextLetter (l);
        if(z==='0'){
            return p.slice(0,-1) + tsNextLetter (q.slice(-1).charCodeAt(0)) + z;
        } else {
            return p + z;
        }
    }
}

function tsNextLetter (l){
    if(l<90){
        if (l == 57) { //If it was '9' jump to 'A' because there are symbols between the numbers and capital letters
            return "A";
        }
        else {
            return String.fromCharCode(l + 1);
        }
    }
    else{
        return '0';
    }
}

function tsSame (str, character){
    var i = str.length;
    while (i--) {
        if (str[i]!==character){
            return false;
        }
    }
    return true;
}

function tsDealOpened (targetFile, destinationFile, cancelOrOverwriteOrSolve) {
    if (isInDesignFile (targetFile)) {
        if (tsIsShade (targetFile)) {
            return false;
        }
        for (var cac = tsChangeAfterCloseList.length - 1; cac >= 0; cac--) {
            if (targetFile.fsName.replace(/\\/g, '/') == tsChangeAfterCloseList[cac][1]) {
                return true;
            }
        }
        var targetInDesign = BridgeTalk.getSpecifier ("indesign");
        var talkInDesign = new BridgeTalk;
        talkInDesign.target = targetInDesign;
        talkInDesign.onResult = function (returnBtObj)
        { setInDesignScript (returnBtObj.body); }
        talkInDesign.body = 
            "testExisting ();" +
            "function testExisting () {" +
                "for (var a = 0; a < app.documents.length; a++) " +
                "{" + 
                    "var osPath = app.documents[a].filePath.fsName.replace(/\\/g, '/');" + //replace(/\\/g, '/')
                    "var resultPath = osPath.replace (/:/g, '/');" +
                    "if (resultPath.indexOf ('/Users/') > 0) {" +
                        "resultPath = resultPath.slice (resultPath.indexOf  ('/Users/'));" +
                    "}" +
                    "else {" +
                        "if (resultPath.indexOf ('~') == 0) {" +
                            "resultPath = resultPath.replace ('~', '/Users/' + tsClientID);" +
                        "}" +
                        "if (resultPath[0] != '/') {" +
                            "resultPath = '/Volumes/' + resultPath;" +
                        "}" +
                    "}" +
                    "if (resultPath + '/' + app.documents[a].name == '" + targetFile.fsName.replace(/\\/g, '/') + "') {" +
                        "var isModified = app.documents[a].modified? 'modified' : 'saved';" + 
                        "app.documents[a].close (SaveOptions.ASK);" +
                        "return '" + targetFile.fsName.replace(/\\/g, '/') + "<>opened<>' + isModified;" +
                    "}" +
                "}" +
                "return '" + targetFile.fsName.replace(/\\/g, '/') + "<>closed<>undefined';" +
            "}";
        talkInDesign.send ();
        function setInDesignScript (theBody) {
            if (theBody) {
                theBody = theBody.split ("<>");
                for (var cac = tsChangeAfterCloseList.length - 1; cac >= 0; cac--) {
                    if (theBody[0] == tsChangeAfterCloseList[cac][1]) {
                        tsChangeAfterCloseList[cac][4] = true;
                        tsChangeAfterCloseList[cac][5] = (theBody[1] == "opened")? true : false;
                        if (tsChangeAfterCloseList[cac][5])
                            tsChangeAfterCloseList[cac][6] = (theBody[2] == "modified")? true : false;
                        break;
                    }
                }
            }
        }
        //tsChangeAfterCloseList
        //tsChangeAfterCloseList[cac][0] counter
        //tsChangeAfterCloseList[cac][1] targetFilePath
        //tsChangeAfterCloseList[cac][2] destinationFilePath
        //tsChangeAfterCloseList[cac][3] cancelOrOverwriteOrSolve
        //tsChangeAfterCloseList[cac][4] is tested
        //tsChangeAfterCloseList[cac][5] was opened
        //tsChangeAfterCloseList[cac][6] was modified
        var changeAfterCloseItem = new Array;
        changeAfterCloseItem.push (0);
        changeAfterCloseItem.push (targetFile.fsName.replace(/\\/g, '/'));
        changeAfterCloseItem.push (destinationFile.fsName.replace(/\\/g, '/'));
        changeAfterCloseItem.push (cancelOrOverwriteOrSolve);
        changeAfterCloseItem.push (false);
        changeAfterCloseItem.push (null);
        changeAfterCloseItem.push (null);
        tsChangeAfterCloseList.push (changeAfterCloseItem);
        return true;
    }
    return false;
}

function tsPickForChangeHandler () {
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesListWithSubs (app.document.selections[c].spec, tsPickedFilesListWithSubs, "", "");
    }
}

function tsGetDisplayName(fileName) {
    var pureName = fileName;
    if (pureName.indexOf(".") != -1) {
        pureName = pureName.slice(0, pureName.lastIndexOf("."));
    }

    var match = pureName.match(/\[[^\[\]]*\]$/);
    if (match) {
        var content = match[0].slice(1, -1);
        return content;
    }

    return null;
}

function tsSetDisplayName (fileName, newDisplayName) {
    var nameWithoutExt = fileName;
    var ext = "";
    if (fileName.indexOf (".") != -1) {
        ext = fileName.slice (fileName.lastIndexOf ("."));
        nameWithoutExt = nameWithoutExt.slice (0, nameWithoutExt.lastIndexOf ("."));
    }

    if (nameWithoutExt.search (/\[[^\[\]]+\]$/) != -1) {
        nameWithoutExt = nameWithoutExt.replace (/\[[^\[\]]+\]$/, "[" + newDisplayName + "]");
    }
    else {
        nameWithoutExt += " [" + newDisplayName + "]";
    }
    return nameWithoutExt + ext;
}

function tsChangeHandler (templatesFile) {
    /**///$.writeln ($.line);
    var isToCompleteChangeList = false;
    if (tsChangeList.length > 1 && templatesFile == null) {
        isToCompleteChangeList = confirm ("Continue changing that was previously stopped?");
        if (!isToCompleteChangeList) {
            tsChangeList = [0];
        }
    }
    else if (templatesFile) {
        tsChangeList = [0];
    }
    if (!isToCompleteChangeList) {
        var filesListWithSubs = new Array;
        if (templatesFile == null) {
            for (var c = 0; c < app.document.selections.length; c++) {
                retrieveFilesListWithSubs (app.document.selections[c].spec, filesListWithSubs, "", "");
            }
        }
        var lastSelectedText = "";
        if (templatesFile && templatesFile.exists) {
            retrieveFilesListWithSubs (templatesFile, filesListWithSubs, "", "");
            lastSelectedText = " for '" + File.decode (templatesFile.name) + "'.";
        }
        else if (tsPickedFilesListWithSubs.length > 0) {
            filesListWithSubs = tsPickedFilesListWithSubs;
            tsPickedFilesListWithSubs = new Array;
        }
        else if (filesListWithSubs.length == 0 && tsLastSelected && tsLastSelected.exists) {
            filesListWithSubs = new Array;
            retrieveFilesListWithSubs (tsLastSelected, filesListWithSubs, "", "");
            lastSelectedText = " for '" + File.decode (tsLastSelected.name) + "'.";
        }
        if (filesListWithSubs.length > 0) {
            var isToDuplicate = false;
            var duplicatingTimes = 0;
            var conflictOption = 3; //Solve
            var promptMessage = [
                "Direct Commands:",
                "",
                "<OO>: Overwrite Original file.",
                "<UO>: Update by original file.",
                "<OP>: Overwrite previous file.",
                "<UP>: Update by Previous file.",
                "<OI>: Overwrite Picked file.",
                "<UI>: Update by picked file.",
                "",
                "New Full Path:" + lastSelectedText,
                "",
                "//: Root of Tree Shade path.",
                "./: File parent folder path. Add dots for parent of parent. Use '.$/' for the current folder.",
                "<.>: File parent folder name... Use <.$> for the current folder.",
                "<AP>: Absolute file path portion without Tree Shade root path.",
                "<AP.>: Absolute file path separated by dots.",
                "<FD>: File display.",
                "<FN>: File name.",
                "<FN.>: File name separated by dots to path portion.",
                "<FNS>: File name suffix after the square brackets.",
                "<T>: To be selected folder path.",
                "<D>: To duplicate. For multiple times write <D3>. Use '*' in the path so the number determined automatically.",
                "<CO>: When Conflict overwrite target.",
                "<COO>: When conflict overwrite target if it's older.",
                "<CC>: When conflict cancel.",
                "<CCS>: When conflict cancel except shade files.",
                "<CS>: When conflict solve (Default).",
                "<WP>: With the paired folder.",
                "<SF>: Selected folder name.",
                "<SP>: Sub Path inside the selected folder.",
                "<SP.>: Sub Path separated by dots.",
                "<L>: What left of the path from selected folder to the file name, combining <SF>/<SP>/<FN> together.",
                "<FF>: First folder.",
                "<LF>: Last folder.", 
                "<NFEF>: New folder for each file.",
                "<NFES>: New folder for each selected folder.",
                "<NFAF>: New folder for all files.",
                "<CE>: Confirm for each.",
                "<RP/from/to>: Replace the path.",
                "<RN/from/to>: Replace the file name.",
                "<RE/from/to>: Replace the file extension.",
                "Use regex in'from' part. Put '*' in 'to' part to be asked for a new list.",
                "",
                "The following also accepts abbreviation and used for date, time and random code:",
                "<Day_Seconds>, <Day_Minutes>, <Day_Hours>, <Weekday_Order>, <Weekday_Name>, <Weekday_Abbreviation>,",
                "<Month_Date>, <Month_Order>, <Month_Name>, <Month_Abbreviation>, <Year_Full>,",
                "<Year_Abbreviation>, <Time_Decimal>, <Time_Hexadecimal>, <Time_Shortest>,",
                "<Random_Style_Long> Where 'Style' a combination of symbols 'a' for small letters,",
                "'A' capital letters, 'h' small hexadecimal, 'H' large hexadecimal and '1' for numbers.",
                "For example <Random_1A_8> means random 8 characters consists of capital letters and numbers",
                "Write like <Random_=1A_8> to generate one random instance for all."];
            if (tsChangeShortcuts.length > 0) {
                promptMessage = tsChangeShortcuts.concat(
                    [
                        "",
                        "1. To add a shortcut, write something like 'd Describtion of the Command: THE_NEW_PATH'.",
                        "2. To execute a shortcut, write its abbreviation followed by ':' (colon).",
                        "3. To remove a shortcut, write its abbreviation followed by ':!' (colon and exclamation mark).",
                        ""
                    ],
                    promptMessage
                );
                promptMessage.unshift ("Shortcuts:");
            }
            promptMessage.unshift ("");
            var promptName = null;
            var isTemplatesFile = false;
            if (templatesFile) {
                promptName = ".$/<FN><CE><D><WP>";
                isTemplatesFile = true;
            }
            else {
                promptName = tsGetText (promptMessage, tsChangeTemplate, false);
            }
            var isCommand = false;
            if (promptName) {
                if (promptName.search (/<OO>/i) != -1 || promptName.search (/<UO>/i) != -1 || promptName.search (/<OP>/i) != -1 || promptName.search (/<UP>/i) != -1) {
                    isCommand = true;
                    var relationName = "Original";
                    if (promptName.search (/<OP>/i) != -1 || promptName.search (/<UP>/i) != -1) {
                        relationName = "Previous";
                    }
                    for (var r = 0; r < filesListWithSubs.length; r++) {
                        var toOverwriteFile = filesListWithSubs[r][0];
                        var fileID = tsGetID (toOverwriteFile);
                        if (fileID) {
                            var relationFileID = readFile (File (tsDataPath + "/IDs" + fileID + "/" + relationName + " ID"));
                            if (relationFileID) {
                                var fileID_Path_newID = [relationFileID];
                                tsGetPath (fileID_Path_newID);                 
                                if (fileID_Path_newID[1]) {
                                    var relationFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                    if (relationFile.exists) {
                                        var isAlreadyTargeted = false;
                                        for (var tls = targetsList.length - 1; tls >= 0; tls--) {
                                            if (promptName.search (/<UO>/i) != -1 || promptName.search (/<UP>/i) != -1) {
                                                if (targetsList[tls] == toOverwriteFile.fsName.replace(/\\/g, '/')) {
                                                    isAlreadyTargeted = true;
                                                    break;
                                                }
                                            }
                                            else {
                                                if (targetsList[tls] == relationFile.fsName.replace(/\\/g, '/')) {
                                                    isAlreadyTargeted = true;
                                                    break;
                                                }
                                            }
                                        }
                                        if (!isAlreadyTargeted && relationFile.fsName.replace(/\\/g, '/') != toOverwriteFile.fsName.replace(/\\/g, '/')) {
                                            if (promptName.search (/<UO>/i) != -1 || promptName.search (/<UP>/i) != -1) {
                                                tsChangeFile (relationFile, toOverwriteFile, true, 2, false);
                                                targetsList.push (toOverwriteFile.fsName.replace(/\\/g, '/'));
                                            }
                                            else {
                                                tsChangeFile (toOverwriteFile, relationFile, true, 2, false);
                                                targetsList.push (relationFile.fsName.replace(/\\/g, '/'));
                                            }
                                        }
                                    }
                                }
                            }
                        }        
                    }
                }
                else if (promptName.search (/<OI>/i) != -1 || promptName.search (/<UI>/i) != -1) {
                    isCommand = true;
                    if (filesListWithSubs.length == 1) {
                        var overwriteSourceFile = filesListWithSubs[0][0];
                        var overwriteFilesList = new Array;
                        for (var c = 0; c < app.document.selections.length; c++) {
                            retrieveFilesList (app.document.selections[c].spec, overwriteFilesList, false, []);
                        }
                        var targetsList = new Array;
                        for (var ofl = 0; ofl < overwriteFilesList.length; ofl++) {
                            var isAlreadyTargeted = false;
                            for (var tls = targetsList.length - 1; tls >= 0; tls--) {
                                if (promptName.search (/<UI>/i) != -1) {
                                    if (targetsList[tls] == overwriteFilesList[ofl].fsName.replace(/\\/g, '/')) {
                                        isAlreadyTargeted = true;
                                        break;
                                    }
                                }
                                else {
                                    if (targetsList[tls] == overwriteSourceFile.fsName.replace(/\\/g, '/')) {
                                        isAlreadyTargeted = true;
                                        break;
                                    }
                                }
                            }
                            if (!isAlreadyTargeted && overwriteSourceFile.fsName.replace(/\\/g, '/') != overwriteFilesList[ofl].fsName.replace(/\\/g, '/')) {
                                if (promptName.search (/<UI>/i) != -1) {
                                    tsChangeFile (overwriteSourceFile, overwriteFilesList[ofl], true, 2, false);
                                    targetsList.push (overwriteFilesList[ofl].fsName.replace(/\\/g, '/'));
                                }
                                else {
                                    tsChangeFile (overwriteFilesList[ofl], overwriteSourceFile, true, 2, false);
                                    targetsList.push (overwriteSourceFile.fsName.replace(/\\/g, '/'));
                                }
                            }
                        }
                    }
                }
            }
            if (!isCommand && promptName) {
                if (promptName.search(/^\.+$/) == 0) {
                    if (promptName == ".") {
                        promptName = "./<FN><CE>";
                    }
                    else {
                        promptName = "./<FN><CE><D" + (promptName.length - 1).toString () + ">";
                    }
                }
                else if (promptName.indexOf (":") != -1) {
                    var promptNameSplitted = promptName.split (":");
                    var shortcutIndex = -1;
                    for (var csh = 0; csh < tsChangeShortcuts.length; csh++) {
                        if (tsChangeShortcuts[csh].indexOf (promptNameSplitted[0]) == 0) {
                            shortcutIndex = csh;
                            break;
                        }
                    }
                    if (promptNameSplitted[1] != '') {
                        if (shortcutIndex != -1) {
                            if (promptNameSplitted[1] == '!') {
                                tsChangeShortcuts.splice (shortcutIndex, 1);
                                return true;
                            }
                        }
                        else {
                            shortcutIndex = 0;
                            tsChangeShortcuts.unshift ("");
                        }
                        tsChangeShortcuts[shortcutIndex] = promptName;
                    }
                    else if (shortcutIndex == -1) {
                        alert ("The shortcut is wrong!");
                        return false;
                    }
                    promptName = tsChangeShortcuts[shortcutIndex].slice (tsChangeShortcuts[shortcutIndex].indexOf (":") + 1);
                    promptName = promptName.replace(/^ +/g, '');
                }
            }
            if (!isCommand && promptName) {
                promptName = tsSolveRandom (promptName, '=');
                if (templatesFile == null) {
                    tsChangeTemplate = promptName;
                }
                var isCE = false;
                var isWP = false;
                if (promptName.search (/<CE>/i) != -1) {
                    promptName = promptName.replace(/<CE>/gi, "");
                    isCE = true;
                }
                if (promptName.search (/<L>/i) != -1) {
                    promptName = promptName.replace(/<L>/gi, "<SF>/<SP>/<FN>");
                }
                if (promptName.search (/<WP>/i) != -1) {
                    promptName = promptName.replace(/<WP>/gi, "");
                    isWP = true;
                }
                if (promptName.indexOf ("/") == -1) {
                    promptName = "./" + promptName;
                }
                if (promptName.search (/<D>/i) != -1) {
                    promptName = promptName.replace(/<D>/gi, "<D1>");
                }
                if (promptName.indexOf ("//") == 0) {
                    promptName = promptName.replace("//", tsRootFolderPath + "/");
                }
                var prefixDisplayIndex = promptName.search (/\/?\.+\$\//);
                while (prefixDisplayIndex != -1) {
                    var targetParent = app.document.thumbnail.spec;
                    var deepCount = 3;
                    var isRelative = false;
                    var displayFirstMatch = promptName.match (/\/?\.+\$\//)[0];
                    if (displayFirstMatch[0] == "/") {
                        isRelative = true;
                        deepCount++;
                    }
                    for (var pml = 0; pml < displayFirstMatch.length - deepCount; pml++) {
                        if (!targetParent.parent) {
                            break;
                        }
                        targetParent = targetParent.parent;
                    }
                    var parentPath = targetParent.fsName.replace(/\\/g, '/') + "/";
                    if (isRelative) {
                        parentPath = parentPath.replace (tsWorkshopPath, "");
                    }
                    promptName = promptName.replace (displayFirstMatch, parentPath);
                    prefixDisplayIndex = promptName.search (/\/?\.+\$\//);
                }
                
                var nameDisplayIndex = promptName.search (/<\.+\$>/);
                while (nameDisplayIndex != -1) {
                    var deepCount = 4;
                    var displayFirstMatch = promptName.match (/<\.+\$>/)[0];
                    var targetParent = app.document.thumbnail.spec;
                    for (var pml = 0; pml < displayFirstMatch.length - deepCount; pml++) {
                        if (!targetParent.parent) {
                            break;
                        }
                        targetParent = targetParent.parent;
                    }
                    var parentFolderName = "";
                    if (targetParent && targetParent.name) {
                        parentFolderName = File.decode (targetParent.name);
                    }
                    promptName = promptName.replace (displayFirstMatch, parentFolderName);
                    nameDisplayIndex = promptName.search (/<\.+\$>/);
                }
    
                var toDuplicateIndex = promptName.search (/<D\d+>/);
                if (toDuplicateIndex != -1) {
                    isToDuplicate = true;
                    var duplicateMatch = promptName.match (/<D\d+>/)[0];
                    var duplicateFactor = duplicateMatch.match (/\d+/)[0];
                    if (duplicateFactor) {
                        duplicatingTimes = parseInt (duplicateFactor, 10);
                    }
                    promptName = promptName.replace (duplicateMatch, "");
                }
                else if (templatesFile) {
                    isToDuplicate = true;
                    duplicatingTimes = 1;
                }
                if (promptName.search (/<CO>/i) != -1) {
                    conflictOption = 2;
                    promptName = promptName.replace(/<CO>/gi, "");
                }
                if (promptName.search (/<COO>/i) != -1) {
                    conflictOption = 4;
                    promptName = promptName.replace(/<COO>/gi, "");
                }
                if (promptName.search (/<CC>/i) != -1) {
                    conflictOption = 1;
                    promptName = promptName.replace(/<CC>/gi, "");
                }
                if (promptName.search (/<CCS>/i) != -1) {
                    conflictOption = 8;
                    promptName = promptName.replace(/<CCS>/gi, "");
                }
                if (promptName.search (/<CS>/i) != -1) {
                    conflictOption = 3;
                    promptName = promptName.replace(/<CS>/gi, "");
                }
                if (promptName.search (/<T>/i) != -1) {
                    var destinationFolder = app.document.thumbnail.spec.selectDlg ("Select a destination folder."); 
                    if (!destinationFolder) {
                        return false;
                    }
                    promptName = promptName.replace(/<T>/gi, destinationFolder.fsName.replace(/\\/g, '/'));
                }
                var replaceList = [];
                var replaceMatchs = promptName.match (/((<RP)|(<RN)|(<RE))[^<>]+>/gi);
                if (replaceMatchs) {
                    for (var rms = 0; rms < replaceMatchs.length; rms++) {
                        var replaceMatchSplitted = replaceMatchs[rms].split (/\//g);
                        for (var ri = 0; ri < replaceMatchSplitted.length - 1; ri++) {
                            if (replaceMatchSplitted[ri].length > 0 && replaceMatchSplitted[ri].search (/\\$/) != -1) {
                                replaceMatchSplitted[ri] = replaceMatchSplitted[ri].slice (0, -1);
                                replaceMatchSplitted[ri] = replaceMatchSplitted[ri] + "/" + replaceMatchSplitted[ri + 1];
                                replaceMatchSplitted.splice (ri + 1, 1);
                            }
                        }
                        if (replaceMatchSplitted.length > 2) {
                            var listText = "";
                            var getTextMes = null;
                            var replaceType = "";
                            var replaceFlags = "";
                            if (replaceMatchSplitted[2].search (/>$/) != -1) {
                                replaceMatchSplitted[2] = replaceMatchSplitted[2].slice (0, -1);
                            }
                            if (replaceMatchSplitted.length > 3) {
                                if (replaceMatchSplitted[3].search (/>$/) != -1) {
                                    replaceMatchSplitted[3] = replaceMatchSplitted[2].slice (0, -1);
                                }
                                replaceFlags = replaceMatchSplitted[3];
                            }
                            if (replaceMatchSplitted[0].search (/^<rp$/i) == 0) {
                                getTextMes = "Paths or subpaths list:";
                                replaceType = "rp";
                            }
                            else if (replaceMatchSplitted[0].search (/^<rn$/i) == 0) {
                                getTextMes = "Full names or names portions list:";
                                replaceType = "rn";
                            }
                            else if (replaceMatchSplitted[0].search (/^<re$/i) == 0) {
                                getTextMes = "Extensions list:";
                                replaceType = "re";
                            }
                            if (getTextMes) {
                                if (replaceMatchSplitted[2] == "*") {
                                    listText = tsGetText ([getTextMes], "", true);
                                }
                                replaceList.push ([replaceType, replaceMatchSplitted[1], replaceMatchSplitted[2], replaceFlags, listText.split ("\n")]);
                            }
                        }
                    }
                    promptName = promptName.replace (/((<RP)|(<RN)|(<RE))[^<>]+>/gi, "");
                }
                var promptPaths = [promptName];
                if (promptName.indexOf ("*") != -1) {
                    promptPaths = getActualPaths ("", promptName);
                }
                if (promptPaths.length > 1) {
                    isToDuplicate = true;
                }
                else if (duplicatingTimes > 1){
                    var newDuplicating = promptPaths.slice ();
                    while (duplicatingTimes > 1) {
                        newDuplicating = newDuplicating.concat (promptPaths);
                        duplicatingTimes--;
                    }
                    promptPaths = newDuplicating;
                }
                for (var pp = 0; pp < promptPaths.length; pp++) {
                    var nesList = new Array; //for <NFES>
                    var nextFolderForAll = null;
                    var virtualNextFolderName = "0000";
                    for (var r = 0; r < filesListWithSubs.length; r++) {
                        var currentPromptName = promptPaths[pp];
                        currentPromptName = tsSolveDateTime (currentPromptName);
                        currentPromptName = tsSolveRandom (currentPromptName, null);
                        var prefixDotsIndex = currentPromptName.search (/\/?\.+\//);
                        while (prefixDotsIndex != -1) {
                            var targetParent = filesListWithSubs[r][0].parent;
                            var deepCount = 2;
                            var isRelative = false;
                            var dotsFirstMatch = currentPromptName.match (/\/?\.+\//)[0];
                            if (dotsFirstMatch[0] == "/") {
                                isRelative = true;
                                deepCount++;
                            }
                            for (var pml = 0; pml < dotsFirstMatch.length - deepCount; pml++) {
                                if (!targetParent.parent) {
                                    break;
                                }
                                targetParent = targetParent.parent;
                            }
                            var parentPath = targetParent.fsName.replace(/\\/g, '/') + "/";
                            if (isRelative) {
                                parentPath = parentPath.replace (tsWorkshopPath, "");
                            }
                            currentPromptName = currentPromptName.replace (dotsFirstMatch, parentPath);
                            prefixDotsIndex = currentPromptName.search (/\/?\.+\//);
                        }
        
                        var nameDotsIndex = currentPromptName.search (/<\.+>/);
                        while (nameDotsIndex != -1) {
                            var deepCount = 3;
                            var dotsFirstMatch = currentPromptName.match (/<\.+>/)[0];
                            var targetParent = filesListWithSubs[r][0].parent;
                            for (var pml = 0; pml < dotsFirstMatch.length - deepCount; pml++) {
                                if (!targetParent.parent) {
                                    break;
                                }
                                targetParent = targetParent.parent;
                            }
                            var parentFolderName = "";
                            if (targetParent && targetParent.name) {
                                parentFolderName = File.decode (targetParent.name);
                            }
                            currentPromptName = currentPromptName.replace (dotsFirstMatch, parentFolderName);
                            nameDotsIndex = currentPromptName.search (/<\.+>/);
                        }
        
                        if (currentPromptName.search (/<AP>/i) != -1) {
                            var fileAP = filesListWithSubs[r][0].parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                            if (fileAP == "") {
                                currentPromptName = currentPromptName.replace(/\/?<AP>/gi, fileAP);
                            }
                            else {
                                currentPromptName = currentPromptName.replace(/<AP>/gi, fileAP.slice (1));
                            }
                        }
        
                        var apDotIndex = currentPromptName.search (/<AP.+>/i);
                        while (apDotIndex != -1) {
                            var fileAPDot = filesListWithSubs[r][0].parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                            var apDotFirstMatch = currentPromptName.match (/<AP.+>/i)[0];
                            var apDotSep = apDotFirstMatch.slice (3, -1);
                            if (fileAPDot != "") {
                                fileAPDot = fileAPDot.slice (1);
                            }
                            fileAPDot = fileAPDot.replace (/\//g, apDotSep);
                            currentPromptName = currentPromptName.replace (/<AP.+>/i, fileAPDot);
                            apDotIndex = currentPromptName.search (/<AP.+>/i);
                        }
                        if (currentPromptName.search (/<FD>/i) != -1) {
                            var targetName = File.decode (filesListWithSubs[r][0].name);
                            targetName = tsGetDisplayName (targetName);
                            if (targetName == null) targetName = '';
                            currentPromptName = currentPromptName.replace(/<FD>/gi, targetName);
                        }
                        if (currentPromptName.search (/<FN>/i) != -1) {
                            var targetName = File.decode (filesListWithSubs[r][0].name);
                            if (targetName.indexOf (".") > 0)
                                targetName = targetName.slice (0, targetName.lastIndexOf ("."));
                            currentPromptName = currentPromptName.replace(/<FN>/gi, targetName);
                        }
                        var fnDotIndex = currentPromptName.search (/<FN.+>/i);
                        while (fnDotIndex != -1) {
                            var targetName = File.decode (filesListWithSubs[r][0].name);
                            targetName = tsGetPureName (targetName, false);
                            var fnDotFirstMatch = currentPromptName.match (/<FN.+>/i)[0];
                            if (targetName != "") {
                                var fnDotSep = fnDotFirstMatch.slice (3, -1);
                                targetName = targetName.split (fnDotSep).join ("/");
                                currentPromptName = currentPromptName.replace (/<FN.+>/i, targetName);
                            }
                            else {
                                currentPromptName = currentPromptName.replace (/\/?<FN.+>/i, targetName);
                            }
                            fnDotIndex = currentPromptName.search (/<FN.+>/i);
                        }
        
                        if (currentPromptName.search (/<FNS>/i) != -1) {
                            var targetName = File.decode (filesListWithSubs[r][0].name);
                            targetName = tsGetPureName (targetName, false);
                            currentPromptName = currentPromptName.replace(/<FNS>/gi, targetName);
                        }
        
                        if (currentPromptName.search (/<SF>/i) != -1) {
                            if (filesListWithSubs[r][2] == "")
                                currentPromptName = currentPromptName.replace(/\/?<SF>/gi, filesListWithSubs[r][2]);
                            else
                                currentPromptName = currentPromptName.replace(/<SF>/gi, filesListWithSubs[r][2]);
                        }
        
                        if (currentPromptName.search (/<SP>/i) != -1) {
                            if (filesListWithSubs[r][1] == "")
                                currentPromptName = currentPromptName.replace(/\/?<SP>/gi, filesListWithSubs[r][1]);
                            else
                                currentPromptName = currentPromptName.replace(/<SP>/gi, filesListWithSubs[r][1]);
                        }
        
                        var spDotIndex = currentPromptName.search (/<SP.+>/i);
                        while (spDotIndex != -1) {
                            var spDotFirstMatch = currentPromptName.match (/<SP.+>/i)[0];
                            var spDotSep = spDotFirstMatch.slice (3, -1);
                            var fileSPDot = filesListWithSubs[r][1].replace (/\//gi, spDotSep);
                            currentPromptName = currentPromptName.replace (/<SP.+>/i, fileSPDot);
                            spDotIndex = currentPromptName.search (/<SP.+>/i);
                        }
        
                        if (currentPromptName.search (/<FF>/i) != -1) {
                            var firstFolderName = null;
                            var toLookInFolder = Folder (currentPromptName.slice (0, currentPromptName.search (/\/<FF>/i)));
                            if (toLookInFolder.exists) {
                                var firstFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                if (firstFolder.length > 0) {
                                    firstFolderName = File.decode (firstFolder[0].name);
                                }
                            }
                            if (firstFolderName) {
                                currentPromptName = currentPromptName.replace (/<FF>/gi, firstFolderName);
                            }
                            else {
                                currentPromptName = currentPromptName.replace (/<FF>/gi, "<NFAF>");
                            }
                        }
                        if (currentPromptName.search (/<LF>/i) != -1) {
                            var lastFolderName = null;
                            var toLookInFolder = Folder (currentPromptName.slice (0, currentPromptName.search (/\/<LF>/i)));
                            if (toLookInFolder.exists) {
                                var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                if (lastFolder.length > 0) {
                                    lastFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
                                }
                            }
                            if (lastFolderName) {
                                currentPromptName = currentPromptName.replace(/<LF>/gi, lastFolderName);
                            }
                            else {
                                currentPromptName = currentPromptName.replace(/<LF>/gi, "<NFAF>");
                            }
                        }
                        if (currentPromptName.search (/<NFEF>/i) != -1) {
                            if (virtualNextFolderName == "0000") {
                                var toLookInFolder = Folder (currentPromptName.slice (0, currentPromptName.search (/\/<NFEF>/i)));
                                if (toLookInFolder.exists) {
                                    var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                    if (lastFolder.length > 0) {
                                        virtualNextFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
                                    }
                                }
                            }
                            virtualNextFolderName = tsNextIncrement (virtualNextFolderName, "_01");
                            currentPromptName = currentPromptName.replace(/<NFEF>/gi, virtualNextFolderName);
                        }
                        if (currentPromptName.search (/<NFES>/i) != -1) {
                            if (filesListWithSubs[r][2] == "") {
                                currentPromptName = currentPromptName.replace(/\/?<NFES>/gi, "");
                            }
                            else {
                                var nextFolderName = null;
                                for (var nesIndex = 0; nesIndex < nesList.length; nes++) {
                                    if (nesList[nesIndex][0] == filesListWithSubs[r][2]) {
                                        nextFolderName = nesList[nesIndex][1];
                                        break;
                                    }
                                }
                                if (nextFolderName == null) {
                                    nextFolderName = "0001";
                                    var toLookInFolder = Folder (currentPromptName.slice (0, currentPromptName.search (/\/<NFES>/i)));
                                    if (toLookInFolder.exists) {
                                        var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                        if (lastFolder.length > 0) {
                                            var lastFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
                                            nextFolderName = tsNextIncrement (lastFolderName, "_01");
                                        }
                                    }
                                    nesList.push ([filesListWithSubs[r][2], nextFolderName]);
                                }
                                currentPromptName = currentPromptName.replace(/<NFES>/gi, nextFolderName);
                            }
                        }
                        if (currentPromptName.search (/<NFAF>/i) != -1) {
                            if (!nextFolderForAll) {
                                nextFolderForAll = "0001";
                                var toLookInFolder = Folder (currentPromptName.slice (0, currentPromptName.search (/\/<NFAF>/i)));
                                if (toLookInFolder.exists) {
                                    var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                    if (lastFolder.length > 0) {
                                        var lastFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
                                        nextFolderForAll = tsNextIncrement (lastFolderName, "_01");
                                    }
                                }
                            }
                            currentPromptName = currentPromptName.replace(/<NFAF>/gi, nextFolderForAll);
                        }
                        var extension = (File.decode (filesListWithSubs[r][0].name).lastIndexOf (".") > 0)? File.decode (filesListWithSubs[r][0].name).slice (File.decode (filesListWithSubs[r][0].name).lastIndexOf (".")) : "";
                        if (replaceList.length > 0) {
                            var desPath = "/";
                            var desName = currentPromptName;
                            if (currentPromptName.indexOf ("/") != -1) {
                                desPath = currentPromptName.slice (0, currentPromptName.lastIndexOf ("/") + 1);
                                desName = currentPromptName.slice (currentPromptName.lastIndexOf ("/") + 1);
                            }
                            for (var rl = 0; rl < replaceList.length; rl++) {
                                var replaceWith = replaceList[rl][2];
                                if (replaceWith == "*") {
                                    if (replaceList[rl][4].length > r) {
                                        replaceWith = replaceList[rl][4][r];
                                    }
                                    else {
                                        continue;
                                    }
                                } 
                                if (replaceList[rl][0] == "rp") {
                                    desPath = desPath.replace (new RegExp (replaceList[rl][1], replaceList[rl][3]), replaceWith);
                                }
                                else if (replaceList[rl][0] == "rn") {
                                    desName = desName.replace (new RegExp (replaceList[rl][1], replaceList[rl][3]), replaceWith);
                                }
                                else if (replaceList[rl][0] == "re") {
                                    extension = extension.replace (new RegExp (replaceList[rl][1], replaceList[rl][3]), replaceWith);
                                }
                            }
                            currentPromptName = desPath + desName;
                        }
                        currentPromptName = tsSolveDateTime (currentPromptName);
                        currentPromptName = tsSolveRandom (currentPromptName, null);
                        var desFullPath = currentPromptName + extension;
                        if (isCE) {
                            tsChangeList[0]++;
                            tsChangeList.push ([filesListWithSubs[r][0].fsName.replace(/\\/g, '/'), desFullPath, isToDuplicate, conflictOption, isWP, isTemplatesFile]);
                        }
                        else {
                            if (filesListWithSubs[r][0].fsName.replace(/\\/g, '/') != desFullPath || conflictOption == 3) {
                                var pairedFolderName = tsGetPureName (File.decode (filesListWithSubs[r][0].name), false);
                                var expectedFolder = new Folder (filesListWithSubs[r][0].parent.fsName.replace(/\\/g, '/') + "/" + pairedFolderName);
                                var newPathIDList = tsChangeFile (filesListWithSubs[r][0], new File (desFullPath), isToDuplicate, conflictOption, false);
                                if (newPathIDList) {
                                    if (isWP) {
                                        var desFile = new File (newPathIDList[0]);
                                        var desPureName = tsGetPureName (File.decode (desFile.name), false);
                                        var desFolder = new Folder (desFile.parent.fsName.replace(/\\/g, '/') + "/" + desPureName);
                                        if (expectedFolder.fsName.replace(/\\/g, '/') != desFolder.fsName.replace(/\\/g, '/') && expectedFolder.exists) {
                                            var filesList = new Array;
                                            retrieveFilesList (expectedFolder, filesList, false, []);
                                            if (filesList.length > 0) {
                                                for (var fl = 0; fl < filesList.length; fl++) {
                                                    var isAlreadySelected = false;
                                                    for (var flws = 0; flws < filesListWithSubs.length; flws++) {
                                                        if (filesList[fl].fsName.replace(/\\/g, '/') == filesListWithSubs[flws][0].fsName.replace(/\\/g, '/')) {
                                                            isAlreadySelected = true;
                                                            break;
                                                        }
                                                    }
                                                    if (!isAlreadySelected) {
                                                        var pairedDesFullPath = desFolder.fsName.replace(/\\/g, '/') + filesList[fl].fsName.replace(/\\/g, '/').replace (expectedFolder.fsName.replace(/\\/g, '/'), "");
                                                        tsChangeFile (filesList[fl], File (pairedDesFullPath), isToDuplicate, conflictOption, false);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    var isToContinueWarning = true;
    for (var cel = 1; cel < tsChangeList.length; cel++) {
        //tsChangeList[cel][0] source file object
        //tsChangeList[cel][1] destination string full path
        //tsChangeList[cel][2] is to duplicate
        //tsChangeList[cel][3] conflict Option
        //tsChangeList[cel][4] isWP
        //tsChangeList[cel][5] isTemplatesFile
        var isToSkipToNext = true;
        var fromFile = new File (tsChangeList[cel][0]);
        if (fromFile.exists) {
            tsToBeSelectedThumbnail = new Thumbnail (fromFile);
            tsLoadStage = 1;
            if (app.document.thumbnail.spec && app.document.thumbnail.spec.fsName.replace(/\\/g, '/') == fromFile.parent.fsName.replace(/\\/g, '/')) {
                app.document.thumbnail = tsToBeSelectedThumbnail.parent;
            }
            var theOrder = (tsChangeList[0] - tsChangeList.length + cel + 1) + " of " + tsChangeList[0];
            var copyMoveTxt = tsChangeList[cel][2]? "Copy: " : "Move: ";
            if (tsChangeList[cel][5]) {
                var pathSplitted = tsChangeList[cel][1].split ("/");
                if (pathSplitted.length > 1) {
                    var displayPart = tsGetDisplayName (pathSplitted[pathSplitted.length-1]);
                    if (displayPart !== null) {
                        var newDisplayPart = prompt ("New Label:", displayPart);
                        pathSplitted[pathSplitted.length-1] = tsSetDisplayName (pathSplitted[pathSplitted.length-1], newDisplayPart);
                    }
                    else {
                        var nameWithoutExt = pathSplitted[pathSplitted.length-1];
                        var nameExt = "";
                        if (pathSplitted[pathSplitted.length-1].indexOf (".") != -1) {
                            nameExt = pathSplitted[pathSplitted.length-1].slice (pathSplitted[pathSplitted.length-1].lastIndexOf ("."));
                            nameWithoutExt = pathSplitted[pathSplitted.length-1].slice (0, pathSplitted[pathSplitted.length-1].lastIndexOf ("."));
                        }
                        var newFileName = prompt ("New File Name:", nameWithoutExt);
                        if (newFileName) {
                            nameWithoutExt = newFileName;
                        }
                        pathSplitted[pathSplitted.length-1] = nameWithoutExt + nameExt;
                    }
                    tsChangeList[cel][1] = pathSplitted.join ("/");
                }
            }
            else {
                tsChangeList[cel][1] = tsGetText ([theOrder, copyMoveTxt, fromFile.fsName.replace(/\\/g, '/'), "", "To:"], tsChangeList[cel][1], false);
            }
            if (!tsChangeList[cel][1]) {
                if (cel != tsChangeList.length - 1) {
                    isToSkipToNext = confirm ("Skip to next file?");
                }
            }
            else if (fromFile.fsName.replace(/\\/g, '/') != tsChangeList[cel][1] || tsChangeList[cel][3] == 3) {
                var pairedFolderName = tsGetPureName (File.decode (fromFile.name), false);
                var expectedFolder = new Folder (fromFile.parent.fsName.replace(/\\/g, '/') + "/" + pairedFolderName);
                var newPathIDList = tsChangeFile (fromFile, new File (tsChangeList[cel][1]), tsChangeList[cel][2], tsChangeList[cel][3], false);
                if (newPathIDList) {
                    if (tsChangeList[cel][4]) {
                        var desFile = new File (newPathIDList[0]);
                        var desPureName = tsGetPureName (File.decode (desFile.name), false);
                        var desFolder = new Folder (desFile.parent.fsName.replace(/\\/g, '/') + "/" + desPureName);
                        if (expectedFolder.fsName.replace(/\\/g, '/') != desFolder.fsName.replace(/\\/g, '/') && expectedFolder.exists) {
                            var filesList = new Array;
                            retrieveFilesList (expectedFolder, filesList, false, []);
                            if (filesList.length > 0) {
                                for (var fl = 0; fl < filesList.length; fl++) {
                                    var isAlreadySelected = false;
                                    for (var cl = 1; cl < tsChangeList.length; cl++) {
                                        if (filesList[fl].fsName.replace(/\\/g, '/') == tsChangeList[cl][0]) {
                                            isAlreadySelected = true;
                                            break;
                                        }
                                    }
                                    if (!isAlreadySelected) {
                                        var pairedDesFullPath = desFolder.fsName.replace(/\\/g, '/') + filesList[fl].fsName.replace(/\\/g, '/').replace (expectedFolder.fsName.replace(/\\/g, '/'), "");
                                        tsChangeFile (filesList[fl], File (pairedDesFullPath), tsChangeList[cel][2], tsChangeList[cel][3], false);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            if (cel != tsChangeList.length - 1) {
                if (isToContinueWarning) {
                    isToContinueWarning = confirm ("The file " + tsChangeList[cel][0] + " has been deleted or moved! Continue showing this warning?");
                }
            }
            else {
                alert ("The file " + tsChangeList[cel][0] + " has been deleted!");
            }
        }
        tsChangeList.splice (cel, 1);
        cel--;
        if (!isToSkipToNext) {
            break;
        }
    }
}

function getActualPaths (solvedPath, promptName) {
    var resultArr = new Array;
    if (promptName.indexOf ("*") == -1) {
        resultArr.push (solvedPath + promptName);
    }
    else {
        var theNewPart = promptName.slice (0, promptName.indexOf ("*"));
        var theRest = promptName.slice (promptName.indexOf ("*") + 1);
        var suffixPortion = "";
        var newPromptName = "";
        if (theRest != "") {
            suffixPortion = theRest;
            if (theRest.indexOf ("/") != -1) {
                suffixPortion = theRest.slice (0, theRest.indexOf ("/"));
                newPromptName = theRest.slice (theRest.indexOf ("/"));
            }
        }
        if (newPromptName != "") {
            var prefixPortion = theNewPart.slice (theNewPart.lastIndexOf ("/") + 1);
            var nextSolved = theNewPart.slice (0, theNewPart.lastIndexOf ("/"));
            var allFolders = Folder (solvedPath + nextSolved).getFiles (prefixPortion + "*" + suffixPortion);
            for (var af = 0; af < allFolders.length; af++) {
                if (isAcceptedFolder (allFolders[af])) {
                    var newPaths = getActualPaths (allFolders[af].fsName.replace(/\\/g, '/'), newPromptName);
                    resultArr = resultArr.concat (newPaths);
                }
            }
        }
        else {
            var nextSolved = theNewPart.slice (0, theNewPart.lastIndexOf ("/"));
            var filePortion = promptName.slice (promptName.lastIndexOf ("/") + 1);
            var allFiles = Folder (solvedPath + nextSolved).getFiles (filePortion);
            for (var af = 0; af < allFiles.length; af++) {
                if (allFiles[af] instanceof File) {
                    var fileName = File.decode (allFiles[af].name);
                    var pathWithoutExt = allFiles[af].fsName.replace(/\\/g, '/');
                    if (fileName.indexOf (".") > 0) {
                        pathWithoutExt = allFiles[af].fsName.replace(/\\/g, '/').slice (0, allFiles[af].fsName.replace(/\\/g, '/').lastIndexOf ("."));
                    }
                    resultArr.push (pathWithoutExt);
                }
            }
        }
    }
    return resultArr;
}

function openPairedHandler (isToCreateFolder, isToAsk) {
    if (app.document.selections.length == 1) {
        if (app.document.selections[0].spec) {
            if (app.document.selections[0].spec.fsName) { //Without Replace
                if (app.document.selections[0].container) {
                    var pairedFiles = app.document.selections[0].spec.parent.getFiles (isAcceptedFile);
                    for (var adf = 0; adf < pairedFiles.length; adf++) {
                        if (tsGetPureName (File.decode (pairedFiles[adf].name)) == File.decode (app.document.selections[0].spec.name)) {
                            app.document.deselectAll ();
                            app.document.select (new Thumbnail (pairedFiles[adf]));
                            return true;
                        }
                    }
                }
                else if (app.document.selections[0].spec.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0 && isAcceptedFile (app.document.selections[0].spec) && isAcceptedFolder (app.document.selections[0].spec.parent)) {
                    return openPairedFolder (app.document.selections[0].spec, isToCreateFolder, isToAsk);
                }
            }
        }
    }
    return false;
}

function openPairedFolder (targetFile, isToCreateFolder, isToAsk) {
    //try to open paired folder
    var pairedFolderName = tsGetPureName (File.decode (targetFile.name), false);
    var expectedFolder = new Folder (targetFile.parent.fsName.replace(/\\/g, '/') + "/" + pairedFolderName);
    if (!expectedFolder.exists) {
        if (!isToCreateFolder) {
            return false;
        }
        if (isToAsk) {
            var isToCreatePaired = confirm ("Create Paired Folder?");
            if (!isToCreatePaired) {
                return false;
            }
        }
        expectedFolder.create ();
    }
    app.document.thumbnail = new Thumbnail (expectedFolder);
    return true;
}

function tsThumbFromPageFolder (targetFolder) {
    if (!targetFolder instanceof Folder)
        return false;
    if (!targetFolder.exists)
        return false;
    var allFiles = targetFolder.getFiles (isAcceptedFile);
    for (var af = 0; af < allFiles.length; af++) {
        var fabricatedThumbFlag = "";
        var thumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
        if (thumbFile.exists) {
            fabricatedThumbFlag = tsGetMetadata (thumbFile, "TS_THUMB_FABRICATED");
        }
        if (fabricatedThumbFlag != "ASSIGNED") {
            tsThumbFromPageLocation (allFiles[af], null);
        }
    }
}

function tsThumbFromPageLocation (targetFile, fileID) {
    if (!fileID) {
        fileID = tsGetID (targetFile);
    }
    if (fileID) {
        var pageThumbFile = null;
        var coordinates = new Array;
        var placesFolder = new Folder (tsDataPath + "/IDs" + fileID + "/Workshop/Places");
        if (placesFolder.exists) {
            var placesFiles = placesFolder.getFiles (isUnhiddenFile);
            outerloop:
            for (var pfs = 0; pfs < placesFiles.length; pfs++) {
                var docID = "/" + File.decode (placesFiles[pfs].name).replace (/\./g, "\/");
                var docID_Path_newID = [docID];
                tsGetPath (docID_Path_newID);
                if (docID_Path_newID[1]) {
                    var workingPagesFolder = new Folder (tsPagesPath + "/Workshop" + docID_Path_newID[1]);
                    if (workingPagesFolder.exists) {
                        var placesContent = readFile (placesFiles[pfs]);
                        if (placesContent) {
                            placesContentLines = placesContent.split ("\n");
                            for (var pcl = 0; pcl < placesContentLines.length; pcl++) {
                                var pageLocations = placesContentLines[pcl].split ("|");
                                if (pageLocations[0]) {
                                    var expectedExtList = [".jpg", ".png"];
                                    var pageThumbFile = new File (workingPagesFolder.fsName.replace(/\\/g, '/') + "/" + tsFillZerosIfAllDigits (pageLocations[0], 4)  + expectedExtList[0]);
                                    if (!pageThumbFile.exists) {
                                        pageThumbFile = new File (workingPagesFolder.fsName.replace(/\\/g, '/') + "/" + tsFillZerosIfAllDigits (pageLocations[0], 4)  + expectedExtList[1]);
                                        if (pageThumbFile.exists) {
                                            var swapCell = expectedExtList[0];
                                            expectedExtList[0] = expectedExtList[1];
                                            expectedExtList[1] = swapCell;
                                        }
                                    }
                                    if (!pageThumbFile.exists) {
                                        pageThumbFile = null;
                                    }
                                    else {
                                        for (var coos = 1; coos < pageLocations.length; coos++) {
                                            var coordinate = pageLocations[coos].split (",");
                                            if (coordinate.length > 3) {
                                                coordinates.push ([parseFloat (coordinate[0]), parseFloat (coordinate[1]), parseFloat (coordinate[2]), parseFloat (coordinate[3])]);
                                            }
                                        }
                                        break outerloop;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (pageThumbFile) {
            var source = new BitmapData (pageThumbFile);
            var inPixel = new Array;
            var swth = source.height < source.width? Math.round (source.height * 0.01) : Math.round (source.width * 0.01); //Stroke Width
            if (swth < 1) swth = 1;
            var margin = swth;
            for (var pix = 0; pix < coordinates.length; pix++) {
                var inPixelY1 = Math.round(source.height * (coordinates[pix][0]/100));
                var inPixelX1 = Math.round(source.width * (coordinates[pix][1]/100));
                var inPixelY2 = Math.round(source.height * (coordinates[pix][2]/100));
                var inPixelX2 = Math.round(source.width * (coordinates[pix][3]/100));
                inPixel.push ([inPixelY1, inPixelX1, inPixelY2, inPixelX2]);
            }
            for (var yy = 0; yy < source.height; yy++) {
                for (var xx = 0; xx < source.width; xx++) {
                    for (pix = 0; pix < inPixel.length; pix++) {
                        var xRange = false;
                        if (xx > (inPixel[pix][1] - swth - margin) && xx < (inPixel[pix][3] + swth + margin)) {
                            xRange = true;
                        }
                        var yRange = false;
                        if (yy > (inPixel[pix][0] - swth - margin) && yy < (inPixel[pix][2] + swth + margin)) {
                            yRange = true;
                        }
                        if (xRange && yRange) {
                            if ((yy < (inPixel[pix][0] - margin) || yy > (inPixel[pix][2] + margin)) || (xx < (inPixel[pix][1] - margin) || xx > (inPixel[pix][3] + margin))) {
                                source.setPixel(xx, yy, "Red");
                            }
                        }
                    }
                }
            }
            var thumbnailFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
            if (!thumbnailFile.parent.exists) {
                thumbnailFile.parent.create();
            }
            else if (thumbnailFile.exists) {
                thumbnailFile.remove ();
                thumbnailFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
            }
            source.exportTo(thumbnailFile, 0);
            tsSetMetadata (thumbnailFile, "TS_THUMB_FABRICATED", pageThumbFile.fsName.replace(/\\/g, '/').replace (tsPagesPath + "/Workshop", ""));
            return thumbnailFile;
        }
    }
    return null;
}

function assignThumbFromScreenshotHandler () {
    var selectedFile = null;
    if (app.document.selections.length == 1) {
        selectedFile = app.document.selections[0].spec;
        if (selectedFile.alias)
            selectedFile = selectedFile.resolve ();
        if (!selectedFile)
            return false;
        if (selectedFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") != 0) {
            selectedFile = null;
        }
    }
    if (selectedFile) {
        var sourceThumbFile = null;
        var allDesktopFiles = Folder.desktop.getFiles (isJpgOrPngFile);
        if (allDesktopFiles.length > 0) {
            sourceThumbFile = allDesktopFiles[allDesktopFiles.length - 1];
            var thumbnailFile = new File (selectedFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (selectedFile.name)) + File.decode (selectedFile.name) + ".jpg");
            if (!thumbnailFile.parent.exists) {
                thumbnailFile.parent.create();
            }
            else if (thumbnailFile.exists) {
                thumbnailFile.remove ();
                thumbnailFile = new File (selectedFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (selectedFile.name)) + File.decode (selectedFile.name) + ".jpg");
            }
            var fabObj = new BitmapData (sourceThumbFile);
            if (fabObj) {
                fabObj.exportTo(thumbnailFile, 0);
                tsSetMetadata (thumbnailFile, "TS_THUMB_FABRICATED", "ASSIGNED");
                labelWorkshopFile (selectedFile, [null], false);
            }    
        }
    }
    else {
        alert ("Please select a single file from 'Workshop' and try again to assign a fabricated thumbnail to it.");
    }
}

function assignThumbFromImageFileHandler () {
    var selectedFile = null;
    if (app.document.selections.length == 1) {
        selectedFile = app.document.selections[0].spec;
        if (selectedFile.alias)
            selectedFile = selectedFile.resolve ();
        if (!selectedFile)
            return false;
        if (selectedFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") != 0) {
            selectedFile = null;
        }
    }
    if (selectedFile) {
        var sourceThumbFile = null;
        sourceThumbFile = Folder.desktop.openDlg ("Select a source for the thumbnail.", "*", false);
        if (!sourceThumbFile) 
            return false;
        if (sourceThumbFile.alias)
            sourceThumbFile = sourceThumbFile.resolve();
        var thumbnailFile = new File (selectedFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (selectedFile.name)) + File.decode (selectedFile.name) + ".jpg");
        if (!thumbnailFile.parent.exists) {
            thumbnailFile.parent.create();
        }
        else if (thumbnailFile.exists) {
            thumbnailFile.remove ();
            thumbnailFile = new File (selectedFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (selectedFile.name)) + File.decode (selectedFile.name) + ".jpg");
        }
        var fabObj = new BitmapData (sourceThumbFile);
        if (fabObj) {
            fabObj.exportTo(thumbnailFile, 0);
            tsSetMetadata (thumbnailFile, "TS_THUMB_FABRICATED", "ASSIGNED");
            labelWorkshopFile (selectedFile, [null], false);
        }
    }
    else {
        alert ("Please select a single file from 'Workshop' and try again to assign a fabricated thumbnail to it.");
    }
}

function assignThumbFromDocumentPageHandler () {
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    var shadeThumb = [null]; 
    for (var r = 0; r < filesList.length; r++) {
        if (tsThumbFromPageLocation (filesList[r], null)) {
            labelWorkshopFile (filesList[r], shadeThumb, false);
        }
    }
    return true;
}

function assignThumbFromFileItselfHandler () {
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    var shadeThumb = [null]; 
    for (var r = 0; r < filesList.length; r++) {
        if (!isCSFile (filesList[r])) {
            continue;
        }
        var workingThumbFile = new File (filesList[r].parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (filesList[r].name)) + File.decode (filesList[r].name) + ".jpg");
        if (workingThumbFile.exists) {
            workingThumbFile.remove ();
            workingThumbFile = new File (filesList[r].parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (filesList[r].name)) + File.decode (filesList[r].name) + ".jpg");
        }
        else {
            workingThumbFile.parent.create();
        }
        var thumbObj = new Thumbnail (filesList[r]);
        thumbObj.core.thumbnail.thumbnail.exportTo(workingThumbFile, 0);
        labelWorkshopFile (filesList[r], shadeThumb, false);
    }
    return true;
}

function assignThumbRemoveHandler () {
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    for (var r = 0; r < filesList.length; r++) {
        var thumbnailFile = new File (filesList[r].parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (filesList[r].name)) + File.decode (filesList[r].name) + ".jpg");
        thumbnailFile.remove ();
        app.document.chooseMenuItem('PurgeCacheForSelected');
    }
    return true;
}

function messageHandler () {
    /**///$.writeln ($.line);
    var theMessage = prompt ("Message:", "");
    if (!theMessage)
        return false;
    var versionFullDotID = "";
    var isWorkshopOrVersion = 0;
    if (app.document.selections.length == 1) {
        var selectedFile = app.document.selections[0].spec;
        var digitsFileIDTriple;
        if (selectedFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            digitsFileIDTriple = getWorkshopVersionInfo (selectedFile, null);
            isWorkshopOrVersion = 1;
        }
        else if (selectedFile.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) {
            var workshopFile = new File (selectedFile.parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (selectedFile.name).slice (6));
            digitsFileIDTriple = getWorkshopVersionInfo (workshopFile, null);
            isWorkshopOrVersion = 2;
        }
        if (!digitsFileIDTriple)
            return false;
        if (digitsFileIDTriple[0] == "new") {
            alert ("You need to checkin the file before sending messages.");
            return false;
        }
        var versionTimeFile = new File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/ver" + digitsFileIDTriple[0] + "/Modifying Time");
        var versionTime = readFile (versionTimeFile);
        if (!versionTime) {
            return false;
        }
        versionFullDotID = digitsFileIDTriple[2].replace (/\//g,"\.");
        versionFullDotID = versionFullDotID.slice (1);
        versionFullDotID += ".ver" + digitsFileIDTriple[0] + "." + versionTime;
    }
    var activeCollaboratorsFolder = new Folder (tsRootFolderPath + "/Workflow/Collaborators/Active");
    var collaboratorFiles = activeCollaboratorsFolder.openDlg ("Select collaborator to send the message to.", "*", true);
    if (collaboratorFiles) {
        var isToSetRemoteUnderEditing = false;
        if (isWorkshopOrVersion == 1) {
            if (collaboratorFiles.length == 1) {
                isToSetRemoteUnderEditing = true; //confirm ("Not to put the version to be under editing by " + File.decode (collaboratorFiles[0].name) + "?");
                isToSetRemoteUnderEditing = !isToSetRemoteUnderEditing;
            }
        }
        if (collaboratorFiles.length > 0) {
            for (var co = 0; co < collaboratorFiles.length; co++) {
                collaboratorFile = collaboratorFiles[co];
                if (collaboratorFile.parent.fsName.replace(/\\/g, '/').toLowerCase() == (tsRootFolderPath + "/Workflow/Collaborators/Active").toLowerCase()) {
                    if (collaboratorFile.alias)
                        collaboratorFile = collaboratorFile.resolve();
                    var imageInfo = tsGetUserInfo (collaboratorFile);
                    if (!imageInfo) {
                        alert ("The collaborator Tree Shade Info is corrupted.\n" + collaboratorFile.fsName.replace(/\\/g, '/')); 
                        return false;
                    }
                    var collaboratorID = imageInfo[0];
                    if (collaboratorID) {
                        var recipientIndex = tsGetRecipientIndex (collaboratorID);
                        if (recipientIndex != -1) {
                            tsIsSendingDone = false;
                            var sendingBoxesItem = new Array;
                            sendingBoxesItem.push ("HaveYou");
                            sendingBoxesItem.push ("Info");
                            var messageContent = "Message" + "\n" + versionFullDotID + ":" + isWorkshopOrVersion + ":" + collaboratorFiles.length + ":" + (isToSetRemoteUnderEditing? "Y" : "N") + "\n" + theMessage;
                            sendingBoxesItem.push (messageContent);
                            recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                        }
                    }
                } 
            }
        }
    }
}

function tsSolveAlreadyExisted (newParentFolder, newName) {
    var prefix = "";
    var pureName = newName;
    var extension = "";
    if (newName.indexOf (".") > 0) {
        extension = newName.slice (newName.lastIndexOf ("."));
        if (extension.indexOf ("]") != -1) {
            extension = "";
        }
        else {
            pureName = newName.slice (0, newName.lastIndexOf ("."));
        }
    }
    if (pureName[0] == '[') {
        if (pureName.indexOf ("]") != -1) {
            prefix = pureName.slice (0, pureName.indexOf ("]") + 1) + " ";
            pureName = pureName.slice (pureName.indexOf ("]") + 1);
            while (pureName.length > 1 && pureName[0] == ' ') {
                pureName = pureName.slice (1);
            }
        }
    }
    do {
        pureName = tsNextIncrement (pureName, "_01");
    } while (File (newParentFolder.fsName.replace(/\\/g, '/') + "/" + prefix + pureName + extension).exists);
    newName = prefix + pureName + extension;
    return newName;
}

function tsChangeFile (targetFile, destinationFile, isDuplicate, cancelOrOverwriteOrSolve, isToDealOpened) {
    /**///$.writeln ($.line);
    var isReturnDes = false;
    var isToForgiveDes = false;
    if (cancelOrOverwriteOrSolve == 5) {
        cancelOrOverwriteOrSolve = 1;
        isReturnDes = true;
    }
    else if (cancelOrOverwriteOrSolve == 6) {
        cancelOrOverwriteOrSolve = 4;
        isReturnDes = true;
    }
    else if (cancelOrOverwriteOrSolve == 7 || cancelOrOverwriteOrSolve == 8) {
        if (cancelOrOverwriteOrSolve == 7) {
            isReturnDes = true;
        }
        if (destinationFile.exists && tsIsShade (destinationFile)) {
            cancelOrOverwriteOrSolve = 2;
        }
        else {
            cancelOrOverwriteOrSolve = 1;
        }
    }
    if (!isDuplicate && isToDealOpened) {
        var isDeal = tsDealOpened (targetFile, destinationFile, cancelOrOverwriteOrSolve);
        if (isDeal) {
            return false;
        }
    }
    var oldParentPath = targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/"));
    var newParentFolder = new Folder (destinationFile.fsName.replace(/\\/g, '/').slice (0, destinationFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")));
    var newName = destinationFile.fsName.replace(/\\/g, '/').slice (destinationFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    if (newName[0] == '[') {
        var newFullPath = checkDynamicName (destinationFile, false);
        if (newFullPath) {
            newParentFolder = new Folder (newFullPath.slice (0, newFullPath.lastIndexOf ("/")));
            newName = newFullPath.slice (newFullPath.lastIndexOf ("/")+1);
            destinationFile = new File (newFullPath);
        }
    }
    var oldName = targetFile.fsName.replace(/\\/g, '/').slice (targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    if (cancelOrOverwriteOrSolve == 1 && isReturnDes) {
        if (destinationFile.parent.exists && !destinationFile.exists) {
            var fileName = File.decode (destinationFile.name);
            var nameWithoutExt = fileName.lastIndexOf (".") != -1? fileName.slice (0, fileName.lastIndexOf (".")) : fileName;
            if (nameWithoutExt) {
                var similarExtFiles = destinationFile.parent.getFiles (nameWithoutExt + ".*");
                if (similarExtFiles.length > 0) {
                    destinationFile = similarExtFiles[0];
                }
            }
        }
    }
    if (destinationFile.exists) {
        if (cancelOrOverwriteOrSolve == 4) { //Overwrite the old
            var targetModified = targetFile.modified.getTime ();
            var targetID = tsGetID (targetFile);
            if (targetID)
                targetModified = tsGetActualModified (targetModified, targetID);
            var destinationModified = destinationFile.modified.getTime ();
            var destinationID = tsGetID (destinationFile);
            if (destinationID)
                destinationModified = tsGetActualModified (destinationModified, destinationID);
            if (destinationModified < targetModified) {
                cancelOrOverwriteOrSolve = 2;
            }
            else {
                cancelOrOverwriteOrSolve = 1;
            }
        }
        if (cancelOrOverwriteOrSolve == 1) {//Cancel because the conflict
            if (isReturnDes) {
                var desID =  tsGetID (destinationFile);
                if (desID) {
                    //copy assigned thumb if there is no destination
                    var thumbDesFile = new File (destinationFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (destinationFile.name)) + File.decode (destinationFile.name) + ".jpg");
                    if (!thumbDesFile.exists) {
                        var thumbTarFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
                        if (thumbTarFile.exists) {
                            var fabricatedThumbFlag = tsGetMetadata (thumbTarFile, "TS_THUMB_FABRICATED");
                            if (fabricatedThumbFlag == "ASSIGNED") {
                                if (!thumbDesFile.parent.exists)
                                    thumbDesFile.parent.create ();
                                thumbTarFile.copy (thumbDesFile);
                            }
                        }
                    }
                    return [destinationFile.fsName.replace(/\\/g, '/'), desID];
                }
                else {
                    isToForgiveDes = true;
                }
            }
        }
        else if (cancelOrOverwriteOrSolve == 2) { //Overwrite the destination
            destinationFile.readonly = false;
            var treeOrVersionOrOut = 3;
            if (destinationFile.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath) == 0)
                treeOrVersionOrOut = 1;
            if (tsIsStaticIDs) {
                File (destinationFile.fsName.replace(/\\/g, '/')).remove ();
            }
            else {
                tsMoveToTrash (destinationFile, treeOrVersionOrOut, null, true, null, false);
            }
        }
        else if (cancelOrOverwriteOrSolve == 3) { //Solve by adding numbers or letters
            newName = tsSolveAlreadyExisted (newParentFolder, newName);
        }
    }
    var isToMove = oldParentPath != newParentFolder.fsName.replace(/\\/g, '/')? true : false;
    var isToRename = oldName != newName? true : false;
    var idFile;
    var idThumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
    var destinationIdThumbFile = File (newParentFolder.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (newName) + newName + ".jpg");
    if (isToMove) {
        if (!destinationIdThumbFile.parent.exists)
            destinationIdThumbFile.parent.create ();
    }
    idThumbFile.copy (destinationIdThumbFile);
    if (!tsIsShade (targetFile)) {
        if (!isCSFile (targetFile)) {
            idFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + File.decode (targetFile.name));
            var destinationIdFile = File (newParentFolder.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + newName);
            if (isToMove) {
                if (!destinationIdFile.parent.exists)
                    destinationIdFile.parent.create ();
            }
            idFile.copy (destinationIdFile);
        }
    }
    targetFile.readonly = false;
    if (isDuplicate) {
        if (!isToForgiveDes) {
            var copyToFile = File (newParentFolder.fsName.replace(/\\/g, '/') + "/" + newName);
            if (!copyToFile.parent.exists)
                copyToFile.parent.create ();
            targetFile.copy (copyToFile);
        }
    }
    else {
        if (isToRename) {
            if (isToMove) {
                var randomDigits = Math.floor(Math.random()*10000);
                randomDigits = fillZeros (randomDigits, 5);
                newName = randomDigits + newName;
            }
            targetFile.rename (newName);
        }
        if (isToMove) {
            if (!newParentFolder.exists)
                newParentFolder.create ();
            var targetThumbnail = new Thumbnail (oldParentPath + "/" + newName);
            targetThumbnail.moveTo (newParentFolder);
            if (isToRename) {
                File (newParentFolder.fsName.replace(/\\/g, '/') + "/" + newName).rename (newName.slice (5));
                newName = newName.slice (5);
            }
        }
        if (idFile) {
            idFile.remove ();
        }
        if (idThumbFile) {
            idThumbFile.remove ();
        }
    }
    var newID = tsUpdateFileState (File (newParentFolder.fsName.replace(/\\/g, '/') + "/" + newName), -2, -1);
    var pathIDList = new Array;
    pathIDList.push (newParentFolder.fsName.replace(/\\/g, '/') + "/" + newName);
    pathIDList.push (newID);
    return pathIDList;
}

function createContextMenu () {
    /**///$.writeln ($.line);

    var newFromCommand = new MenuElement( "command", "New from...", "at the beginning of Thumbnail", "newFromCommand");
    newFromCommand.onSelect = function (m) {
        var filesList = new Array;
        if (app.document.selections.length > 0) {
            for (var c = 0; c < app.document.selections.length; c++) {
                retrieveFilesList (app.document.selections[c].spec, filesList, true, []);
            }
        }
        newFromHandler (filesList, null);
    };

    newFromCommand.onDisplay = function ()
    {
        try
        {
            newFromCommand.text = "New From...";
            if (app.document.selections.length > 0) {
                var newFromText = "New From Selected";
                if (app.document.selections.length == 1) {
                    if (app.document.selections[0].container) {
                        newFromText = "New From Folder";
                    }
                    else if (app.document.selections[0].spec.name[0] == '-') {
                        newFromText = "New From Label";
                    }
                }
                newFromCommand.text = newFromText;
            }
        }
        catch(error){ 
            /*Error*/$.writeln (error); 
            /*Error*/$.writeln ($.line);
        }
    };
    
	var checkInCommand = new MenuElement( "command", "Check In", "after newFromCommand", "checkInCommand");
	checkInCommand.onSelect = function (m) 
	{
        var result = confirm ("Check In as Final?\n");
        checkInSelection (result);
    };

	var createNewVersionCommand = new MenuElement( "command", "Create New Version", "after checkInCommand", "createNewVersionCommand");
	createNewVersionCommand.onSelect = function (m) 
	{
        var result = confirm ("Put Under Editing?");
        if (result) {
            if (newVersionDigitsFileIDTriple) {
                if (newVersionDigitsFileIDTriple[2]) {
                    if (newVersionDigitsFileIDTriple[0] != "new") {
                        var versionTimeFile =  new File (tsDataPath + "/IDs" + newVersionDigitsFileIDTriple[2] + "/ver" + newVersionDigitsFileIDTriple[0] + "/Modifying Time");
                        var versionTime = readFile (versionTimeFile);
                        if (versionTime) { 
                            var underEditingFile = new File (tsDataPath + "/IDs" + newVersionDigitsFileIDTriple[2] + "/ver" + newVersionDigitsFileIDTriple[0] + "/V/" + versionTime + "/UnderEditing");
                            if (underEditingFile.exists) {
                                var whatAnswer = confirm ("The file is under editing! Are you sure you want to create new version?");
                                if (!whatAnswer)
                                    return;
                            }
                        }                        
                    }
                }
            }
        }
        createNewVersionForSelection (result);
    };
    createNewVersionCommand.onDisplay = function()
    {
        newVersionDigitsFileIDTriple = null;
        try
        {
            var isInScope = (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0? true : false;
            if (!isInScope) {
                createNewVersionCommand.enabled = false;
            }
            else {
                var isEnabled = true;
                if (tsVersionsPath != "") {
                    filesCount = 0;
                    for (var c = 0; c < app.document.selections.length; c++) {
                        if (app.document.selections[c].container) {
                            isEnabled = false;
                            break;
                        }
                        else {
                            filesCount++;
                        }
                    }
                    if (isEnabled) {
                        if (filesCount == 0) {
                            isEnabled = false;
                        }
                        else if (filesCount == 1) {
                            newVersionDigitsFileIDTriple = getWorkshopVersionInfo (app.document.selections[0].spec, null);
                            if (newVersionDigitsFileIDTriple) {
                                createNewVersionCommand.text = "Create New Version";
                            }
                            else {
                                isEnabled = false;
                            }                            
                        }
                        else {
                            createNewVersionCommand.text = "Create New Versions";
                        }
                    }
                }
                else {
                    isEnabled = false;
                }
                createNewVersionCommand.enabled = isEnabled;
            }
        }
		catch(error){ 
            /*Error*/$.writeln (error); 
            /*Error*/$.writeln ($.line);
        }
	};

	var startEditingCommand = new MenuElement( "command", "Start Editing", "after createNewVersionCommand", "startEditingCommand");
	startEditingCommand.onSelect = function (m) 
	{ 
		startEditingSelectedHandler ();
	};
	startEditingCommand.onDisplay = function()
	{

	};

	var cancelEditingCommand = new MenuElement( "command", "Cancel Editing", "after startEditingCommand", "cancelEditingCommand");
	cancelEditingCommand.onSelect = function (m) 
	{ 
		cancelEditingSelectedHandler ();
	};
	cancelEditingCommand.onDisplay = function()
	{

	};

	var loadCommand = new MenuElement( "command", "Load", "after cancelEditingCommand", "loadCommand");
	loadCommand.onSelect = function (m) 
	{ 
		loadSelectedHandler ();
	};
	loadCommand.onDisplay = function()
	{
        var isOneActualFile = false;
        if (app.document.selections.length == 1) {
            if (!app.document.selections[0].container) {
                if (!tsIsShade (app.document.selections[0].spec)) {
                    isOneActualFile = true;
                }
            }
        }
        if (!isOneActualFile) {
            loadCommand.text = "Load";
        }
        else {
            loadCommand.text = "Check or Direct Reload";
        }
	};

	var labelFolderCommand = new MenuElement( "command", "Label Folder", "after loadCommand", "labelFolderCommand");
	labelFolderCommand.onSelect = function (m) 
	{ 
		setLabelFolderHandler ();
	};
	labelFolderCommand.onDisplay = function ()
	{
        labelFolderCommand.enabled = (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0? true : false;
	};

    
	var messageCommand = new MenuElement( "command", "Message to...", "after labelFolderCommand", "messageCommand");
	messageCommand.onSelect = function (m) 
	{ 
        messageHandler ();
	};
    var assignThumbSubmenu = new MenuElement( "menu", "Set Thumbnail", "after messageCommand", "assignThumbSubmenu");
    var assignThumbFromScreenshotCommand = new MenuElement( "command", "From Recently Screenshot", "at the end of assignThumbSubmenu", "assignThumbFromScreenshotCommand");
	assignThumbFromScreenshotCommand.onSelect = function (m) 
	{ 
        assignThumbFromScreenshotHandler ();
    };
    var assignThumbFromImageFileCommand = new MenuElement( "command", "From Image File", "at the end of assignThumbSubmenu", "assignThumbFromImageFileCommand");
	assignThumbFromImageFileCommand.onSelect = function (m) 
	{ 
        assignThumbFromImageFileHandler ();
    };
    var assignThumbFromDocumentPageCommand = new MenuElement( "command", "From Document Page", "at the end of assignThumbSubmenu", "assignThumbFromDocumentPageCommand");
	assignThumbFromDocumentPageCommand.onSelect = function (m) 
	{ 
        assignThumbFromDocumentPageHandler ();
    };
    var assignThumbFromFileItselfCommand = new MenuElement( "command", "From File Itself", "at the end of assignThumbSubmenu", "assignThumbFromFileItselfCommand");
	assignThumbFromFileItselfCommand.onSelect = function (m) 
	{ 
        assignThumbFromFileItselfHandler ();
    };
    var assignThumbRemoveCommand = new MenuElement( "command", "Remove", "at the end of assignThumbSubmenu", "assignThumbRemoveCommand");
	assignThumbRemoveCommand.onSelect = function (m) 
	{ 
        assignThumbRemoveHandler ();
    };
    
    var pickForChangeCommand = new MenuElement( "command", "Pick for Change", "after assignThumbSubmenu", "pickForChangeCommand");
    pickForChangeCommand.onSelect = function (m) 
    { 
        tsPickForChangeHandler (null);
    };

    var changeCommand = new MenuElement( "command", "Change...", "after pickForChangeCommand", "changeCommand");
    changeCommand.onSelect = function (m) 
    { 
        tsChangeHandler (null);
    };

    var openPairedCommand = new MenuElement( "command", "Switch to the Paired", "after changeCommand", "openPairedCommand");
	openPairedCommand.onSelect = function (m) 
	{
        var isToCreateFolder = true;
        var isToAsk = false;
		openPairedHandler (isToCreateFolder, isToAsk);
	};

    //Preferences
    new MenuElement( "menu", "Preferences", "after openPairedCommand", "preferencesSubmenu");

    var wideScanningCommand = new MenuElement( "command", "Wide Scanning", "at the end of preferencesSubmenu", "wideScanningCommand");
    wideScanningCommand.onSelect = function (m) 
    { 
        wideScanningHandler ();
    };

    wideScanningCommand.onDisplay = function()
    {
        if (tsIsWideScanningUltimate) {
            wideScanningCommand.text = wideScanningCommand.text.replace ("Wide Scanning", "Ultimate Wide Scanning");
        }
        else {
            wideScanningCommand.text = wideScanningCommand.text.replace ("Ultimate Wide Scanning", "Wide Scanning");
        }
        tsUpdateCommandState (wideScanningCommand, tsIsWideScanning);
    };

    var staticIDsCommand = new MenuElement( "command", "Static IDs", "at the end of preferencesSubmenu", "staticIDsCommand");
    staticIDsCommand.onSelect = function (m) 
    { 
        staticIDsHandler ();
    };

    staticIDsCommand.onDisplay = function()
    {
        tsUpdateCommandState(staticIDsCommand, tsIsStaticIDs);
    };

    var VersionsOutputCommand = new MenuElement( "command", "Versions Output To Workshop", "at the end of preferencesSubmenu", "VersionsOutputCommand");
    VersionsOutputCommand.onSelect = function (m) 
    { 
        versionsOutputHandler ();
    };

    VersionsOutputCommand.onDisplay = function()
    {
        VersionsOutputCommand.text = "Versions Output To Workshop";
        tsUpdateCommandState (VersionsOutputCommand, tsIsVersionsOutputToWorkshop);
        if (tsVersionsOutputZero == "WITH_ZERO") {
            VersionsOutputCommand.text = "Versions Output with ZERO";
        }
        else if (tsVersionsOutputZero == "WITH_ZERO") {
            VersionsOutputCommand.text = "Versions Output only ZERO";
        } 
    };

    var switchWithInDesignCommand = new MenuElement( "command", "Switch With InDesign", "at the end of preferencesSubmenu", "switchWithInDesignCommand");
    switchWithInDesignCommand.onSelect = function (m) 
    { 
        switchWithInDesignHandler ();
    };

    switchWithInDesignCommand.onDisplay = function()
    {
        tsUpdateCommandState (switchWithInDesignCommand, tsIsSwitchWithInDesign);
    };

    var ignoreVersionOwnerCommand = new MenuElement( "command", "Ignore Version Owner", "at the end of preferencesSubmenu", "ignoreVersionOwnerCommand");
    ignoreVersionOwnerCommand.onSelect = function (m) 
    { 
        ignoreVersionOwnerHandler ();
    };

    ignoreVersionOwnerCommand.onDisplay = function()
    {
        tsUpdateCommandState (ignoreVersionOwnerCommand, tsIsIgnoreVersionOwner);
    };

    var respondToManuallyDeletedCommand = new MenuElement( "command", "Respond To Manually Deleted Files", "at the end of preferencesSubmenu", "respondToManuallyDeletedCommand");
    respondToManuallyDeletedCommand.onSelect = function (m) 
    { 
        respondToManuallyDeletedHandler ();
    };

    respondToManuallyDeletedCommand.onDisplay = function()
    {
        tsUpdateCommandState (respondToManuallyDeletedCommand, tsIsRespondToManuallyDeleted);
    };
}

function createTemplateCommand(targetFileOrFolder, parentMenu, foldersList) {
    if (File.decode(targetFileOrFolder.name)[0] == '-') {
        return false;
    }
    var displayName = File.decode(targetFileOrFolder.name);
    var pureName = tsGetPureName(displayName, false);
    var cleanName = displayName.replace(/ /g, "");
    var internalName = parentMenu + "_" + cleanName;
    var unsafeID = internalName + "Menu";
    var safeID = unsafeID.replace(/[^a-zA-Z0-9_]/g, "");
    if (targetFileOrFolder instanceof File) {
        var pairedFolder = new Folder(targetFileOrFolder.parent + "/" + pureName);
        var commandDisplay = displayName;
        var displayPart = tsGetDisplayName (displayName);
        if (displayPart) {
            commandDisplay = displayPart;
        }
        else {
            if (commandDisplay.indexOf(".") > 0)
                commandDisplay = commandDisplay.slice(0, commandDisplay.lastIndexOf("."));
    
            if (commandDisplay[0] == '[' && commandDisplay.indexOf("]") != -1) {
                var trimmed = commandDisplay.slice(commandDisplay.indexOf("]") + 1);
                commandDisplay = (trimmed != "") ? "[] " + trimmed : "";
            }
        }
        if (pairedFolder.exists) {
            if (foldersList) {
                for (var i = foldersList.length - 1; i >= 0; i--) {
                    if (File.decode(foldersList[i].name) == pureName) {
                        foldersList.splice(i, 1);
                        break;
                    }
                }
            }
            var subMenu = new MenuElement("menu", commandDisplay, "at the end of " + parentMenu, safeID);
            var pairedCmd = new MenuElement("command", "New", "at the beginning of " + safeID + "-", internalName + "PairedFile");
            pairedCmd.onSelect = function () {
                tsChangeHandler(targetFileOrFolder);
            };
            var innerFiles = pairedFolder.getFiles(isAcceptedFile);
            tsSortFilesList(pairedFolder, innerFiles, false);
            var innerFolders = pairedFolder.getFiles(isAcceptedFolder);
            tsSortFilesList(pairedFolder, innerFolders, true);
            for (var j = 0; j < innerFiles.length; j++) {
                createTemplateCommand(innerFiles[j], safeID, innerFolders);
            }
            for (var j = 0; j < innerFolders.length; j++) {
                createTemplateCommand(innerFolders[j], safeID, null);
            }
        } else {
            if (commandDisplay == "") {
                return false;
            }
            var newCommand = new MenuElement("command", commandDisplay, "at the end of " + parentMenu, internalName + "Cmd");
            newCommand.onSelect = function () {
                tsChangeHandler(targetFileOrFolder);
            };
        }
    } else {
        var newMenu = new MenuElement("menu", displayName, "at the end of " + parentMenu, safeID);

        var innerFiles = targetFileOrFolder.getFiles(isAcceptedFile);
        tsSortFilesList(targetFileOrFolder, innerFiles, false);
        var innerFolders = targetFileOrFolder.getFiles(isAcceptedFolder);
        tsSortFilesList(targetFileOrFolder, innerFolders, true);
        for (var j = 0; j < innerFiles.length; j++) {
            createTemplateCommand(innerFiles[j], safeID, innerFolders);
        }
        for (var j = 0; j < innerFolders.length; j++) {
            createTemplateCommand(innerFolders[j], safeID, null);
        }
    }
}

function logDebug(message) {
    var desktop = Folder.desktop;
    var logFile = new File(desktop.fsName + "/TreeShade_DebugLog.txt");
    if (logFile.open("a")) {
        var now = new Date();
        var timestamp = now.getFullYear() + "-" +
                        ("0" + (now.getMonth() + 1)).slice(-2) + "-" +
                        ("0" + now.getDate()).slice(-2) + " " +
                        ("0" + now.getHours()).slice(-2) + ":" +
                        ("0" + now.getMinutes()).slice(-2) + ":" +
                        ("0" + now.getSeconds()).slice(-2);
        logFile.writeln("[" + timestamp + "] " + message);
        logFile.close();
    }
}


function createPlugInMenu (isStopped) {
    /**///$.writeln ($.line);
    var treeShadeMenu = new MenuElement( "menu", "Tree Shade", "after Tools", "treeShadeMenu");
    
    if (!isStopped) {
        var newSubmenu = new MenuElement( "menu", "New", "at the end of treeShadeMenu", "newSubmenu");
        if (tsTemplatesPath == "CCC") {
            tsTemplatesPath = tsWorkshopPath + "/Initial/New";
        }

        var templatesFolder = new Folder(tsTemplatesPath);
        if (templatesFolder.exists) {
            var innerFiles = templatesFolder.getFiles(isAcceptedFile);
            tsSortFilesList(templatesFolder, innerFiles, false);

            var innerFolders = templatesFolder.getFiles(isAcceptedFolder);
            tsSortFilesList(templatesFolder, innerFolders, true);
            for (var j = 0; j < innerFiles.length; j++) {
                createTemplateCommand(innerFiles[j], "newSubmenu", innerFolders);
            }

            for (var j = 0; j < innerFolders.length; j++) {
                createTemplateCommand(innerFolders[j], "newSubmenu", null);
            }
        } else {
        }

        
        var changeTemplatePathCommand = new MenuElement( "command", "Change Path", "-at the end of newSubmenu", "changeTemplatePathCommand");
        changeTemplatePathCommand.onSelect = function (m) 
        { 
            var templatesPathFolder = Folder.myDocuments.selectDlg ("New Templates' Folder");
            if (!templatesPathFolder)
                return false;
            tsTemplatesPath = templatesPathFolder.fsName.replace(/\\/g, '/');
            alert ("The templates' path is changed to the new folder, but the change to take effect restart Adobe Bridge.");
        };

        newSubmenu.onDisplay = function ()
        {
            if (tsWorkshopPath == "") {
                newSubmenu.enabled = false;
                return false;
            }
            try
            {
                var folderParent = app.document.thumbnail.spec;
                if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0) {
                    newSubmenu.enabled = true;
                    return true;
                }
                else {
                    newSubmenu.enabled = false;
                    return false;
                }
            }
            catch(error){ 
                /*Error*/$.writeln (error); 
                /*Error*/$.writeln ($.line);
            }
        };

        var relationsSubmenu = new MenuElement( "menu", "The Copying Sequence", "at the end of treeShadeMenu", "relationsSubmenu");
        if (tsTemplatesPath == "CCC") {
            tsTemplatesPath = tsWorkshopPath + "/Initial/New";
        }
        
        var revealOriginalCommand = new MenuElement( "command", "Reveal Original", "at the end of relationsSubmenu", "revealOriginalCommand");
        revealOriginalCommand.onSelect = function (m) 
        { 
            tsSelectRelationFileHandler ("Original");
        };

        var revealPreviousCommand = new MenuElement( "command", "Reveal Previous", "at the end of relationsSubmenu", "revealPreviousCommand");
        revealPreviousCommand.onSelect = function (m) 
        { 
            tsSelectRelationFileHandler ("Previous");
        };

        var changeOriginalCommand = new MenuElement( "command", "Change Original", "-at the end of relationsSubmenu", "changeOriginalCommand");
        changeOriginalCommand.onSelect = function (m) 
        { 
            tsChangeRelationFileHandler ("Original");
        };

        var changePreviousCommand = new MenuElement( "command", "Change Previous", "at the end of relationsSubmenu", "changePreviousCommand");
        changePreviousCommand.onSelect = function (m) 
        { 
            tsChangeRelationFileHandler ("Previous");
        };

        var removeOriginalCommand = new MenuElement( "command", "Remove Original Relation", "-at the end of relationsSubmenu", "removeOriginalCommand");
        removeOriginalCommand.onSelect = function (m) 
        { 
            tsRemoveRelationFileHandler ("Original");
        };

        var removePreviousCommand = new MenuElement( "command", "Remove Previous Relation", "at the end of relationsSubmenu", "removePreviousCommand");
        removePreviousCommand.onSelect = function (m) 
        { 
            tsRemoveRelationFileHandler ("Previous");
        };

        relationsSubmenu.onDisplay = function ()
        {
            
        };

        var importCommand = new MenuElement( "command", "Import", "at the end of treeShadeMenu", "importCommand");
        importCommand.onSelect = function (m) 
        {
            var folderParent = app.document.thumbnail.spec;
            if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0) {
                var embarkFolder = new Folder (Folder.myDocuments.parent.fsName.replace(/\\/g, '/') + "/Downloads");
                var sourceFolder = embarkFolder.selectDlg ("Select a folder to import its contents to current folder.");
                if (sourceFolder) {
                    var conflictOption = 6;
                    if (confirm ("When conflict just overwrite shade files?")) {
                        conflictOption = 7;
                    }
                    var allItems = sourceFolder.getFiles (isAcceptedFileOrFolder);
                    for (var c = 0; c < allItems.length; c++) {
                        if (allItems[c] instanceof Folder) {
                            tsImportFolder (allItems[c], Folder (folderParent.fsName.replace(/\\/g, '/') + "/" + File.decode (allItems[c].name)), conflictOption);
                            addToNonTreeEmptyFoldersList (allItems[c].fsName.replace(/\\/g, '/'));
                        }
                        else {
                            tsImportFile (allItems[c], folderParent, false, null, false, conflictOption);
                        }
                    }
                }
            }
            else {
                var treeFolder = new Folder (tsWorkshopPath);
                var sourceFolder;
                var destinationFolder;
                destinationFolder = treeFolder.selectDlg ("Select a destination folder to import selected items to it.");
                var conflictOption = 6;
                if (confirm ("When conflict just overwrite shade files?")) {
                    conflictOption = 7;
                }
                if (destinationFolder) {
                    for (var c = 0; c < app.document.selections.length; c++) {
                        if (app.document.selections[c].container) {
                            tsImportFolder (app.document.selections[c].spec, Folder (destinationFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (app.document.selections[c].spec.name)), conflictOption);
                            addToNonTreeEmptyFoldersList (app.document.selections[c].spec.fsName.replace(/\\/g, '/'));
                        }
                        else {
                            tsImportFile (app.document.selections[c].spec, destinationFolder, false, null, false, conflictOption);
                        }
                    }
                }
            }
        };

        importCommand.onDisplay = function ()
        {
            if (tsWorkshopPath == "") {
                importCommand.enabled = false;
                return false;
            }
            try
            {
                var isToEnable = true;
                var folderParent = app.document.thumbnail.spec;
                if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsDataPath + "/") == 0)
                    isToEnable = false;
                else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0) {
                    importCommand.text = "Import to Here...";
                }
                else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath !="")
                    isToEnable = false;   
                else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "")
                    isToEnable = false; 
                else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "")
                    isToEnable = false;
                else if (app.document.selections.length == 0) {
                    isToEnable = false;
                }
                else if (app.document.selections.length == 1) {
                    if (app.document.selections[0].container) {
                        importCommand.text = "Import Selected Folder to...";
                    }
                    else {
                        importCommand.text = "Import Selected File to...";
                    }
                }
                else {
                    importCommand.text = "Import Selected Files to...";
                }
                importCommand.enabled = isToEnable;
            }
            catch(error){ 
                /*Error*/$.writeln (error); 
                /*Error*/$.writeln ($.line);
            }
        };

        var moveToTrashCommand = new MenuElement ( "command", "Move to Trash", "at the end of treeShadeMenu", "moveToTrashCommand");
        moveToTrashCommand.onSelect = function (m) 
        { 
            moveSelectedToTrash ();
        };
        moveToTrashCommand.onDisplay = function()
        {
            try
            {
                moveToTrashCommand.enabled = (app.document.selections.length >= 1) ? true : false;
            }
            catch(error){ 
                /*Error*/$.writeln (error); 
                /*Error*/$.writeln ($.line);
            }
        };

        var releaseCommand = new MenuElement( "command", "Release", "at the end of treeShadeMenu", "releaseCommand");
        releaseCommand.onSelect = function (m) 
        { 
            releaseSelectedHandler ();
        };

        var cancelToCheckInListCommand = new MenuElement( "command", "Cancel To Check In List", "at the end of treeShadeMenu", "cancelToCheckInListCommand");
        cancelToCheckInListCommand.onSelect = function (m) 
        { 
            cancelToCheckInListHandler ();
        };

        var changeRootCommand = new MenuElement( "command", "Change Root Folder", "-at the end of treeShadeMenu", "changeRootCommand");
        changeRootCommand.onSelect = function (m) 
        { 
            changeRootHandler ();
        };

        var getFileInfoCommand = new MenuElement( "command", "Selected Info...", "at the end of treeShadeMenu", "getFileInfoCommand");
        getFileInfoCommand.onSelect = function (m) 
        { 
            getFileInfoHandler ();
        };
        getFileInfoCommand.onDisplay = function()
        {
            try
            {
                if (app.document.selections.length == 1) {
                    getFileInfoCommand.enabled = true;
                }
                else {
                    getFileInfoCommand.enabled = false;
                }
            }
            catch(error){ 
                /*Error*/$.writeln (error); 
                /*Error*/$.writeln ($.line);
            }
        };

        var directLinkToCommand = new MenuElement( "command", "Direct Link To...", "at the end of treeShadeMenu", "directLinkToCommand");
        directLinkToCommand.onSelect = function (m) 
        { 
            directLinkToHandler ();
        };
        directLinkToCommand.onDisplay = function()
        {
            try
            {
                directLinkToCommand.enabled = false;
                if (app.document.selections.length == 1) {
                    if (!app.document.selections[0].container) {
                        directLinkToCommand.enabled = true;
                    }
                }
            }
            catch(error){ 
                /*Error*/$.writeln (error); 
                /*Error*/$.writeln ($.line);
            }
        };

        var queryPlacingLocationsCommand = new MenuElement( "command", "Query Placing Locations", "at the end of treeShadeMenu", "queryPlacingLocationsCommand");
        queryPlacingLocationsCommand.onSelect = function (m) 
        { 
            queryPlacingLocationsForSelection ();
        };

        var queryLinksCommand = new MenuElement( "command", "Query Links", "at the end of treeShadeMenu", "queryLinksCommand");
        queryLinksCommand.onSelect = function (m) 
        { 
            queryLinksForSelection ();
        };
    
        var stopScanningCommand = new MenuElement( "command", "Stop Wide Scanning for Selected Folder(s)", "at the end of treeShadeMenu", "stopScanningCommand");
        stopScanningCommand.onSelect = function (m) 
        { 
            stopScanningHandler ();
        };

        stopScanningCommand.onDisplay = function()
        {
            if (app.document.selections.length == 0) {
                stopScanningCommand.enabled = false;
            }
            else {
                stopScanningCommand.enabled = true;
            }
        };
    
        var scanCommand = new MenuElement( "command", "Scan Selected...", "at the end of treeShadeMenu", "scanCommand");
        scanCommand.onSelect = function (m) 
        { 
            scanHandler ();
        };

        scanCommand.onDisplay = function()
        {
            if (app.document.selections.length == 0) {
                scanCommand.text = "Scan Current Folder";
            }
            else {
                scanCommand.text = "Scan Selected...";
            }
        };
    
        //autoCheckInAddHandler
        var autoCheckInAddCommand = new MenuElement( "command", "Add to Auto Check In", "at the end of treeShadeMenu", "autoCheckInAddCommand");
        autoCheckInAddCommand.onSelect = function (m) 
        { 
            autoCheckInAddHandler ();
        };

        var uploadSelectedToCommand = new MenuElement( "command", "Upload Selected to...", "at the end of treeShadeMenu", "uploadSelectedToCommand");
        uploadSelectedToCommand.onSelect = function (m) 
        { 
            uploadSelectedToHandler ();
        };

        var updateTreeShadeSortCommand = new MenuElement( "command", "Update ts_sort.txt File", "at the end of treeShadeMenu", "updateTreeShadeSortCommand");
        updateTreeShadeSortCommand.onSelect = function (m) 
        { 
            updateTreeShadeSortHandler ();
        };

        var scopesSubmenu = new MenuElement( "menu", "Scopes", "-at the end of treeShadeMenu", "scopesSubmenu");

        var addScopeCommand = new MenuElement( "command", "Create New Scope", "at the end of scopesSubmenu", "addScopeCommand");
        addScopeCommand.onSelect = function (m) 
        { 
            addScopeHandler ();
        };

        var modifyScopeCommand = new MenuElement( "command", "Modify Scope Profile", "at the end of scopesSubmenu", "modifyScopeCommand");
        modifyScopeCommand.onSelect = function (m) 
        { 
            modifyScopeHandler ();
        };

        var assignScopeCommand = new MenuElement( "command", "Assign Selected Folders to Scope...", "at the end of scopesSubmenu", "assignScopeCommand");
        assignScopeCommand.onSelect = function (m) 
        { 
            var scopesInterfaceFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
            var scopeInfoFile = scopesInterfaceFolder.openDlg ("Select a scope to assign the folder(s) to it.", "*", false);
            if (scopeInfoFile) {
                var scopeIndex = -1;
                if (scopeInfoFile.alias)
                    scopeInfoFile = scopeInfoFile.resolve();
                var selectedScopeID = tsGetScopeID (scopeInfoFile);
                if (selectedScopeID) {
                    for (var sc = 0; sc < tsScopesList.length; sc++) {
                        if (tsScopesList[sc][0] == selectedScopeID) {
                            scopeIndex = sc;
                            break;
                        } 
                    }
                }
                if (scopeIndex >= 0) {
                    var scopeFolder = tsScopesList[scopeIndex][1][5].parent;
                    var newAbstractPaths = new Array;
                    for (var c = 0; c < app.document.selections.length; c++) {
                        var folderLabel = null;
                        if (app.document.selections[c].container) {
                            if ((app.document.selections[c].spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") != 0)
                                continue;
                            var labelIDPair = tsGetLabel (app.document.selections[c].spec, true, true);
                            if (labelIDPair) {
                                folderLabel = labelIDPair[0];
                            }
                        }
                        else {
                            folderLabel = app.document.selections[c].spec;
                            if (folderLabel.alias)
                                folderLabel = folderLabel.resolve();
                            if (!folderLabel) {
                                continue;
                            }
                            if (folderLabel.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") != 0)
                                continue;
                            if (File.decode (folderLabel.name)[0] != '-') {
                                continue;
                            }
                        }
                        if (folderLabel) {
                            newAbstractPaths.push (folderLabel.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""));
                        }
                    }
                    if (newAbstractPaths.length > 0) {
                        assignScopeHandler (newAbstractPaths, scopeFolder);
                    }
                }
            }
        };

        var unassignScopeCommand = new MenuElement( "command", "Remove Selected Folders from Scope...", "at the end of scopesSubmenu", "unassignScopeCommand");
        unassignScopeCommand.onSelect = function (m) 
        { 
            var scopesInterfaceFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
            var scopeInfoFile = scopesInterfaceFolder.openDlg ("Select a scope to remove the folder(s) from it.", "*", false);
            var scopeIndex = -1;
            if (scopeInfoFile) {
                if (scopeInfoFile.alias)
                    scopeInfoFile = scopeInfoFile.resolve();
                var selectedScopeID = tsGetScopeID (scopeInfoFile);
                if (selectedScopeID) {
                    for (var sc = 0; sc < tsScopesList.length; sc++) {
                        if (tsScopesList[sc][0] == selectedScopeID) {
                            scopeIndex = sc;
                            break;
                        } 
                    }
                }
            }
            else {
                return false;
            }
            if (scopeIndex >= 0) {
                var scopeFolder = tsScopesList[scopeIndex][1][5].parent;
                var newAbstractPaths = new Array;
                for (var c = 0; c < app.document.selections.length; c++) {
                    var folderLabel = null;
                    if (app.document.selections[c].container) {
                        if ((app.document.selections[c].spec.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") != 0)
                            continue;
                        var labelIDPair = tsGetLabel (app.document.selections[c].spec, true, true);
                        if (labelIDPair) {
                            folderLabel = labelIDPair[0];
                        }
                    }
                    else {
                        folderLabel = app.document.selections[c].spec;
                        if (folderLabel.alias)
                            folderLabel = folderLabel.resolve();
                        if (!folderLabel) {
                            continue;
                        }
                        if (folderLabel.fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") != 0)
                            continue;
                        if (File.decode (folderLabel.name)[0] != '-') {
                            continue;
                        }
                    }
                    if (folderLabel) {
                        newAbstractPaths.push (folderLabel.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""));
                    }
                }
                if (newAbstractPaths.length > 0) {
                    unassignScopeHandler (newAbstractPaths, scopeFolder);
                }
            }
        };
    
        var revealScopeCommand = new MenuElement( "command", "Reveal", "-at the end of scopesSubmenu", "revealScopeCommand");
        revealScopeCommand.onSelect = function (m) 
        { 
            var scopesInterfaceFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
            if (scopesInterfaceFolder.exists) {
                app.document.thumbnail = new Thumbnail (scopesInterfaceFolder);
            }
        };
    
        var cloudLocationsSubmenu = new MenuElement( "menu", "Cloud Locations", "-at the end of treeShadeMenu", "cloudLocationsSubmenu"); 

        var addCloudLocationCommand = new MenuElement( "command", "Add Cloud Location", "at the end of cloudLocationsSubmenu", "addCloudLocationCommand");
        addCloudLocationCommand.onSelect = function (m) 
        { 
            addCloudLocationHandler ();
        };
    
        var removeCloudLocationCommand = new MenuElement( "command", "Remove Cloud Location", "at the end of cloudLocationsSubmenu", "removeCloudLocationCommand");
        removeCloudLocationCommand.onSelect = function (m) 
        { 
            removeCloudLocationHandler ();
        };
    
        var revealCloudLocationsCommand = new MenuElement( "command", "Reveal", "-at the end of cloudLocationsSubmenu", "revealCloudLocationsCommand");
        revealCloudLocationsCommand.onSelect = function (m) 
        { 
            var cloudLocationsFolder = Folder (tsRootFolderPath + "/Workflow/Cloud Locations");
            if (cloudLocationsFolder.exists) {
                app.document.thumbnail = new Thumbnail (cloudLocationsFolder);
            }
        };

        var reportWorkingTimeCommand = new MenuElement( "command", "Report Working Time", "-at the end of treeShadeMenu", "reportWorkingTimeCommand");
        reportWorkingTimeCommand.onSelect = function (m) 
        { 
            reportWorkingTimeHandler ();
        };

        var setAutoWorkTimeReportingCommand = new MenuElement( "command", "Set Auto Work Time Reporting", "at the end of treeShadeMenu", "setAutoWorkTimeReportingCommand");
        setAutoWorkTimeReportingCommand.onSelect = function (m) 
        { 
            setAutoWorkTimeReportingHandler (-1, null, null);
        };
    
        var modifyMyProfileCommand = new MenuElement( "command", "Modify My Profile", "at the end of treeShadeMenu", "modifyMyProfileCommand");
        modifyMyProfileCommand.onSelect = function (m) 
        { 
            modifyMyProfileHandler ();
        };

        var workflowCommand = new MenuElement( "command", "Workflow Status", "-at the end of treeShadeMenu", "workflowCommand");
        workflowCommand.onSelect = function (m) 
        { 
            workflowHandler ();
        };
    }
	var aboutCommand = new MenuElement( "command", "About Tree Shade", "at the end of treeShadeMenu", "aboutCommand");
	aboutCommand.onSelect = function (m) 
	{ 
		aboutHandler ();
	};

    aboutCommand.onDisplay = function ()
    {

    };

	return true;
}

function aboutHandler () {
    /**///$.writeln ($.line);
    alert ("Developed by Abdulaziz A. Junaid.\ndulajun@gmail.com\nPhone: +966508018243\n\nVersion No. " + tsVersionNumber);
}

function tsGetLabel (targetFolder, isToSolve, isToCreate) {
    var spoiledLabels = targetFolder.getFiles (tsIsLabelFile);
    var newLabelFile = null;
    var labelFileID = null;
    if (spoiledLabels.length == 0 && isToCreate) {
        newLabel = "";
        newLabel = targetFolder.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
        if (newLabel == "")
            newLabel = "Root";
        newLabel = newLabel.slice (1);
        newLabel = newLabel.replace (/\//g,".");
        newLabelFile = new File (targetFolder.fsName.replace(/\\/g, '/') + "/- " + newLabel);
        labelFileID = tsBuildID (newLabelFile, new Date().getTime (), null);
    }
    else if (spoiledLabels.length > 0) {
        var newestIndex = 0;
        for (var sl = 1; sl < spoiledLabels.length; sl++) {
            if (spoiledLabels[newestIndex].modified.getTime () < spoiledLabels[sl].modified.getTime ()) {
                newestIndex = sl;
            }
        }
        if (isToSolve) {
            for (var rm = 0; rm < spoiledLabels.length; rm++) {
                if (rm != newestIndex) {
                    tsMoveToTrash (spoiledLabels[rm], 1, null, true, null, false);
                }
            }
        }
        newLabelFile = spoiledLabels[newestIndex];
        if (!labelFileID) {
            labelFileID = tsGetID (newLabelFile);
        }
        if (!labelFileID) {
            labelFileID = tsUpdateFileState (newLabelFile, -2, -1);
        }
    }
    if (labelFileID) {
        return [newLabelFile, labelFileID];
    }
    return null;
}

function assignScopeHandler (newAbstractPaths, scopeFolder) {
    /**///$.writeln ($.line);
    
    var scopeInfoFile = scopeFolder.getFiles ("Scope *.jpg");
    if (scopeInfoFile.length != 1)
        return false;
    scopeInfoFile = scopeInfoFile[0];
    var scopeID = File.decode (scopeInfoFile.name).slice (6, File.decode (scopeInfoFile.name).lastIndexOf ("."));
    var synchronizingPathsFolder = new Folder (scopeFolder.fsName.replace(/\\/g, '/') + "/Synchronizing Paths");
    if (!synchronizingPathsFolder.exists)
        synchronizingPathsFolder.create ();
    var synchronizingPathsFiles = synchronizingPathsFolder.getFiles (isAcceptedSyncedFile);
    var allPathsFiles = synchronizingPathsFiles.slice (0);
    for (var nap = 0; nap < newAbstractPaths.length; nap++) {
        var fileID = tsGetID (File (tsWorkshopPath + newAbstractPaths[nap]));
        if (!fileID)
            continue;
        var newAbsolutePath = newAbstractPaths[nap].slice (0, newAbstractPaths[nap].lastIndexOf ("/"));
        var labelText = newAbstractPaths[nap].slice (newAbstractPaths[nap].lastIndexOf ("/")+1);
        if (newAbsolutePath.length > 0) {
            newAbsolutePath = newAbsolutePath.slice (1);
            newAbsolutePath = newAbsolutePath.replace (/\//g, " ➔ ");
            var isThereSon = false;
            for (var fps = synchronizingPathsFiles.length - 1; fps >= 0; fps--) {
                if ((File.decode (synchronizingPathsFiles[fps].name) + " ➔ ").indexOf (newAbsolutePath + " ➔ ") == 0) {
                    synchronizingPathsFiles[fps].remove ();
                    synchronizingPathsFiles.splice (fps, 1);
                    isThereSon = true;
                }
            }
            if (!isThereSon) {
                var isThereFather = false;
                for (var spf = 0; spf < synchronizingPathsFiles.length; spf++) {
                    if ((newAbsolutePath + " ➔ ").indexOf (File.decode (synchronizingPathsFiles[spf].name) + " ➔ ") == 0) {
                        isThereFather = true;
                        break;
                    }
                }
                if (isThereFather)
                    continue;
            }
            var newParhFile = new File (synchronizingPathsFolder.fsName.replace(/\\/g, '/') + "/" + newAbsolutePath);
            var pathTimeFile = new File (tsDataPath + "/IDs" + fileID + "/Path/Change Time");
            var pathTime = readFile (pathTimeFile);
            if (!pathTime)
                continue;
            //synchronizingPathsContent
            //synchronizingPathsContent[0] Folder Label ID
            //synchronizingPathsContent[1] Label Date
            //synchronizingPathsContent[2] Assigner ID (Collaborator ID)
            //synchronizingPathsContent[3] Label Text
            writeEncodedFile (newParhFile, fileID + "\n" + pathTime + "\n" + tsUserID + "\n" + labelText);
            allPathsFiles.push (newParhFile);
        }
    }

    if (allPathsFiles.length == 1) {
        var isToSetAuto = confirm ("Do you want to set Auto Work Time Reporting?");
        if (isToSetAuto) {
            var targetPathFile = allPathsFiles[0];
            var autoWorkRootFolder = new Folder (tsWorkshopPath + "/" + File.decode (allPathsFiles[0].name).replace(/\s➔\s/g, "/"));
            var scopeIndex = getScopeIndex (scopeID);
            if (scopeIndex != -1)
                setAutoWorkTimeReportingHandler (scopeIndex, autoWorkRootFolder, null);
        }
    }
}

function unassignScopeHandler (newAbstractPaths, scopeFolder) {
    /**///$.writeln ($.line + " unassignScopeHandler");
    var scopeInfoFile = scopeFolder.getFiles ("Scope *.jpg");
    if (scopeInfoFile.length != 1)
        return false;
    scopeInfoFile = scopeInfoFile[0];
    var scopeID = File.decode (scopeInfoFile.name).slice (6, File.decode (scopeInfoFile.name).lastIndexOf ("."));
    var synchronizingPathsFolder = new Folder (scopeFolder.fsName.replace(/\\/g, '/') + "/Synchronizing Paths");
    if (!synchronizingPathsFolder.exists)
        synchronizingPathsFolder.create ();
    var synchronizingPathsFiles = synchronizingPathsFolder.getFiles (isAcceptedSyncedFile);
    for (var nap = 0; nap < newAbstractPaths.length; nap++) {
        var fileID = tsGetID (File (tsWorkshopPath + newAbstractPaths[nap]));
        if (!fileID)
            continue;
        var newAbsolutePath = newAbstractPaths[nap].slice (0, newAbstractPaths[nap].lastIndexOf ("/"));
        var labelText = newAbstractPaths[nap].slice (newAbstractPaths[nap].lastIndexOf ("/")+1);
        if (newAbsolutePath.length > 0) {
            newAbsolutePath = newAbsolutePath.slice (1);
            newAbsolutePath = newAbsolutePath.replace (/\//g, " ➔ ");
            for (var fps = synchronizingPathsFiles.length - 1; fps >= 0; fps--) {
                if ((File.decode (synchronizingPathsFiles[fps].name) + " ➔ ").indexOf (newAbsolutePath + " ➔ ") == 0) {
                    synchronizingPathsFiles[fps].remove ();
                }
            }
        }
    }
}

function tsUpdateCommandState(command, newValue) {
    if (!command) return;
    command.checked = newValue;
    command.text = (newValue ? "✓ " : "·   ") + command.text.replace(/^[✓·]\s*/, "");
}

function modifyMyProfileHandler () {
    /**///$.writeln ($.line);
    var confirmImage = confirm ("Did you modified your image?\nIf not,click No, modify it and reexcute the command again.");
    if (confirmImage) {
        var newName = prompt ("New Name:", tsUserName);
        if (!newName)
            return false;
        var newEmail = prompt ("New Email:", tsUserEmail);
        if (!newEmail)
            return false;
        if (!tsUserImage.exists) {
            alert ("Tree Shade User Image is missed!");
            return false;
        }
        tsUserName = newName;
        tsUserEmail = newEmail;
        tsUserImage.rename ("I'm " + tsUserName + ".jpg");
        tsUpdateUserInfo (tsUserImage, [tsUserID, tsUserName, tsUserEmail]);
        //copying image to all scopes
        
        for (var sl = 0; sl < tsScopesList.length; sl++) {
            var activeCollaborators = Folder (tsScopesList[sl][1][5].parent.fsName.replace(/\\/g, '/') + "/Collaborators").getFiles ("*.jpg");
            var scopeUserImage = new File (tsScopesList[sl][1][5].parent.fsName.replace(/\\/g, '/') + "/Collaborators/" + tsUserName + ".jpg");
            for (var ac = 0; ac < activeCollaborators.length; ac++) {
                var userInfo = tsGetUserInfo (activeCollaborators[ac]);
                if (!userInfo) {
                    continue;
                }
                if (tsUserID == userInfo[0]) {
                    activeCollaborators[ac].rename (tsUserName + ".jpg");
                    scopeUserImage = activeCollaborators[ac];
                    break;
                }
            }
            tsUserImage.copy (scopeUserImage);
        }
    }
    else {
        var meImageThumbnail = new Thumbnail (tsUserImage);
        meImageThumbnail.revealInSystemBrowser ();
    }
}

function modifyScopeHandler () {
    /**///$.writeln ($.line);
    var scopeName = "";
    var scopeDescription = "";
    var scopeEmail = "";
    var scopeAutoLoading = "No Load";
    
    var scopesInterfaceFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
    var scopeInfoFile = scopesInterfaceFolder.openDlg ("Select a scope to modify its profile.", "*", true);
    var scopeIndex = -1;
    if (scopeInfoFile) {
        if (scopeInfoFile.alias)
            scopeInfoFile = scopeInfoFile.resolve();
        var selectedScopeID = tsGetScopeID (scopeInfoFile);
        if (selectedScopeID) {
            for (var sc = 0; sc < tsScopesList.length; sc++) {
                if (tsScopesList[sc][0] == selectedScopeID) {
                    scopeIndex = sc;
                    break;
                } 
            }
        }
    }
    else {
        return false;
    }
    if (scopeIndex >= 0) {
        scopeName = prompt ("Scope Name:", tsScopesList[scopeIndex][1][0]);
        if (!scopeName)
            return false;
        scopeDescription = prompt ("Scope Description:", tsScopesList[scopeIndex][1][1]);
        if (!scopeDescription)
            return false;
        scopeEmail = prompt ("Scope Email:", tsScopesList[scopeIndex][1][2]);
        if (!scopeEmail)
            return false;
        if (tsScopesList[scopeIndex][1][3] == "Auto Load") {
            if (!confirm ("Actual files Synchronizing?")) {
                scopeAutoLoading = "No Load";
            }
        }
        else {
            if (!confirm ("Shade files Synchronizing?")) {
                scopeAutoLoading = "Auto Load";
            }
        }
        tsUpdateScopeInfo (scopeInfoFile, [scopeName, scopeDescription, scopeEmail, scopeAutoLoading]);
    }
}

function addScopeHandler () {
    /**///$.writeln ($.line);
    currentTime = new Date().getTime();
    var scopeID;
    var scopeName = "";
    var scopeDescription = "";
    var scopeEmail = "";
    var scopeAutoLoading = "Auto Load";
    var scopeInfoFile;
    var isAutoLoadingChanged = false;
    
    scopeID = TSProduceID ();
    
    scopeName = prompt ("Scope Name:", scopeName);
    if (!scopeName)
        return false;
    scopeDescription = prompt ("Scope Description:", scopeDescription);
    if (!scopeDescription)
        return false;
    scopeEmail = prompt ("Scope Email:", scopeEmail);
    if (!scopeEmail)
        return false;
    var cloudLocationsFolder = Folder (tsRootFolderPath + "/Workflow/Cloud Locations");
    var cloudLocationFile = cloudLocationsFolder.openDlg ("Select a Cloud Location for the new Scope.", "*", false);
    if (!cloudLocationFile)
        return false;
    if (cloudLocationFile.alias)
        cloudLocationFile = cloudLocationFile.resolve();
    scopeInfoFile = new File (cloudLocationFile.parent.fsName.replace(/\\/g, '/') + "/Scopes/Scope " + scopeName + "/Scope " + scopeID + ".jpg");
    scopeInfoFile.parent.create ();
    File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Scope Image Template.jpg").copy (scopeInfoFile);
    writeFile (new File (scopeInfoFile.parent.fsName.replace(/\\/g, '/') + "/TS Scope Readme.txt"), "This folder supposed to be inside:\n.../Scopes/\nIf it's not move it there.");
    //copy user info to this new scope
    var meImageFile = new File (scopeInfoFile.parent.fsName.replace(/\\/g, '/') + "/Collaborators/" + tsUserName + ".jpg");
    if (!meImageFile.parent.exists)
        meImageFile.parent.create ();
    if (tsUserImage.exists) {
        tsUserImage.copy(meImageFile);
    }
    else {
        alert ("Tree Shade User Image is missed!");
        return false;
    }
    if (!confirm ("Actual File Synchronizing?"))
        scopeAutoLoading = "No Load";
    if (!tsUpdateScopeInfo (scopeInfoFile, [scopeName, scopeDescription, scopeEmail, scopeAutoLoading])) {
        alert ("Tree Shade: Could't write to the Metadata of Scope Image:\n" + scopeInfoFile.fsName.replace(/\\/g, '/'));
        return false;
    }
    tsSetScopeID (scopeInfoFile, scopeID);
    tsToBeSelectedThumbnail = new Thumbnail (new Folder (scopeInfoFile.parent.fsName.replace(/\\/g, '/')));
    tsLoadStage = 1;
    app.document.thumbnail = tsToBeSelectedThumbnail.parent;
    alert ("Great! New Scope have been created. The selected folder represent the scope. Invite the collaborators to share it.");
}

function TSProduceID () {
    /**///$.writeln ($.line);
    var num = "";
    while (num.length < 10) {
        num = num + ((Math.random() * 1000).toString (36))[0];
    }
    return num
}

function addCloudLocationHandler () {
    /**///$.writeln ($.line);
    var cloudLocationFolder = Folder.myDocuments.selectDlg ("New Cloud Location Folder");
    if (!cloudLocationFolder)
        return false;
        
    var isAlready = false;
    var cloudLocationsFolder = Folder (tsRootFolderPath + "/Workflow/Cloud Locations");
    var allShortcuts = cloudLocationsFolder.getFiles (isUnhiddenShortcutFile);
    for (var asc = 0; asc < allShortcuts.length; asc++) {
        var shortcutName = File.decode (allShortcuts[asc].name);
        var actualFile = allShortcuts[asc].resolve ();
        if (actualFile) {
            if (actualFile.exists) {
                if (cloudLocationFolder.fsName.replace(/\\/g, '/') == actualFile.parent.fsName.replace(/\\/g, '/')) {
                    alert ("This Location is already added as '" + shortcutName + "'.\n Check 'Workflow/Cloud Locations'.");
                    isAlready = true;
                    break;
                }
            }
        }
    }
    if (!isAlready) {
        var cloudLocationLabel = null;
        while (true) {
            if (cloudLocationLabel) {
                cloudLocationLabel = prompt ("Already Exist! New Try:", cloudLocationLabel);
            } 
            else {
                cloudLocationLabel = prompt ("Cloud Location Label:", "");
            }
            if (!cloudLocationLabel)
                return false;
            var isRepeated = false;
            for (var sc = 0; sc < allShortcuts.length; sc++) {
                if (File.decode (allShortcuts[sc].name) == cloudLocationLabel) {
                    isRepeated = true;
                    break;
                }
            }
            if (!isRepeated) {
                break;
            }
        }
        var cloudLocationShortcut = new File (cloudLocationsFolder.fsName.replace(/\\/g, '/') + "/" + cloudLocationLabel);
        var cloudLocationMarkerFile = new File (cloudLocationFolder.fsName.replace(/\\/g, '/') + "/" + cloudLocationLabel + " TSCL.txt");
        writeFile (cloudLocationMarkerFile, "The parent folder for this file is a Tree Shade Cloud Location.");
        cloudLocationShortcut.createAlias (cloudLocationMarkerFile);  
        tsSetCloudPaths ();
        return tsBuildMessagesLists ();
    }
}

function removeCloudLocationHandler () {
    /**///$.writeln ($.line);
    var cloudLocationsFolder = Folder (tsRootFolderPath + "/Workflow/Cloud Locations");
    var cloudLocationFile = cloudLocationsFolder.openDlg ("Select a Cloud Location to remove.", "*", false);
    if (!cloudLocationFile)
        return false;
    var physicalFile = null;
    if (cloudLocationFile.alias)
        physicalFile = cloudLocationFile.resolve();
    if (physicalFile) {
        if (physicalFile.exists) {
            physicalFile.remove ();
        }
    }
    cloudLocationFile.remove ();
    tsSetCloudPaths ();
    return tsBuildMessagesLists ();
}

function reportWorkingTimeHandler () {
    /**///$.writeln ($.line);
    
    var now = new Date ();
    var month = now.getMonth () + 1;
    var day = now.getDate ();
    var hours = now.getHours();
    month = month > 9? month.toString () : "0" + month.toString ();
    day = day > 9? day.toString () : "0" + day.toString ();
    hours = hours > 9? hours.toString () : "0" + hours.toString ();
    var newWorkingTimeStep = Math.floor (now.getMinutes ()/5);
    var step = (newWorkingTimeStep) * 5;
    step = step > 9? step.toString () : ("0" + step.toString ());        
    var year = now.getFullYear();
    var toStr = year + "/" + month + "/" + day + "/" + hours + "/" + step;
    var fromStr = year + "/" + month + "/" + day + "/" + "00" + "/" + "00";
    var result = prompt ("Time format: ", fromStr + "-" + toStr);
    
    if (result) {
        var splitted = result.split ("-");
        if (splitted.length == 2) {
            var fromResult = splitted[0].split ("/");
            var toResult = splitted[1].split ("/");
            if (fromResult.length == 5 && toResult.length == 5) {
                var isForMe = confirm ("Do you want to report your work?");
                if (!isForMe) {
                    var collaboratorID;
                    var collaboratorsFolder = Folder (tsRootFolderPath + "/Workflow/Collaborators/Active");
                    var collaboratorFile = collaboratorsFolder.openDlg ("Select collaborator to get his working details.", "*", true);
                    if (collaboratorFile) {
                        collaboratorFile = collaboratorFile[0];
                        if (collaboratorFile.parent.fsName.replace(/\\/g, '/').toLowerCase() == (tsRootFolderPath + "/Workflow/Collaborators/Active").toLowerCase()) {
                            if (collaboratorFile.alias)
                                collaboratorFile = collaboratorFile.resolve();
                            var imageInfo = tsGetUserInfo (collaboratorFile);
                            if (!imageInfo) {
                                alert ("The collaborator image Tree Shade ID is corrupted."); 
                                return false;
                            }
                            collaboratorID = imageInfo[0];
                        }
                    }
                    if (collaboratorID) {
                        var recipientIndex = tsGetRecipientIndex (collaboratorID);
                        if (recipientIndex != -1) {
                            if (recipientsList[recipientIndex][2].length > 0) {
                                var targetScopeID;
                                if (recipientsList[recipientIndex][2].length == 1) {
                                    targetScopeID = tsScopesList[recipientsList[recipientIndex][2][0]][0];
                                }
                                else {
                                    var dateName = new Date().getTime();
                                    dateName = dateName.toString ();
                                    var queryFolder = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);          
                                    queryFolder.create ();
                                    for (var rsl = 0; rsl < recipientsList[recipientIndex][2].length; rsl++) {
                                        writeFile (File (queryFolder.fsName.replace(/\\/g, '/') + "/" + tsScopesList[recipientsList[recipientIndex][2][rsl]][1][0]), tsScopesList[recipientsList[recipientIndex][2][rsl]][0]);
                                    }
                                    var scopeSelectedFile = queryFolder.openDlg ("Select a scope.", "*", true);
                                    if (scopeSelectedFile) {
                                        scopeSelectedFile = scopeSelectedFile[0];
                                        if (scopeSelectedFile.parent.fsName.replace(/\\/g, '/').toLowerCase() == (queryFolder.fsName.replace(/\\/g, '/')).toLowerCase()) {
                                            targetScopeID = readFile (scopeSelectedFile);
                                        }
                                    }
                                    deleteForcelyFolders (queryFolder, true);
                                }
                                if (targetScopeID) {
                                    tsIsSendingDone = false;
                                    var sendingBoxesItem = new Array;
                                    sendingBoxesItem.push ("HaveYou");
                                    sendingBoxesItem.push ("Info");
                                    sendingBoxesItem.push ("Work Time" + "\n" + splitted[0] + "\n" + splitted[1] + "\n" + targetScopeID);
                                    recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                                }
                            }
                            else{
                                alert ("This collaborator doesn't belong to any Scope!");
                            }
                        }
                    }
                }
                else {
                    var targetScopeID;
                    if (tsScopesList.length == 1) {
                        targetScopeID = tsScopesList[0][0];
                    }
                    else {
                        var dateName = new Date().getTime();
                        dateName = dateName.toString ();
                        var queryFolder = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);          
                        queryFolder.create ();
                        for (var sln = 0; sln < tsScopesList.length; sln++) {
                            writeFile (File (queryFolder.fsName.replace(/\\/g, '/') + "/" + tsScopesList[sln][1][0]), tsScopesList[sln][0]);
                        }
                        var scopeSelectedFile = queryFolder.openDlg ("Select a Scope.", "*", true);
                        if (scopeSelectedFile) {
                            scopeSelectedFile = scopeSelectedFile[0];
                            if (scopeSelectedFile.parent.fsName.replace(/\\/g, '/').toLowerCase() == (queryFolder.fsName.replace(/\\/g, '/')).toLowerCase()) {
                                targetScopeID = readFile (scopeSelectedFile);
                            }
                        }
                        deleteForcelyFolders (queryFolder, true);
                    }
                    if (targetScopeID) {
                        var requestArray = new Array;
                        requestArray.push ("Work Time");
                        requestArray.push (splitted[0]);
                        requestArray.push (splitted[1]);
                        requestArray.push (targetScopeID);
                        var finalResult = getWorkingTable (requestArray);
                        produceWorkingDocument (tsUserName, finalResult);
                    }
                }
            }
        }
    }
}

function setAutoWorkTimeReportingHandler (targetScopeIndex, reportsFolder, shiftsPeriods) {
    if (targetScopeIndex == -1) {
        var targetScopeID = null;
        if (tsScopesList.length == 1) {
            targetScopeID = tsScopesList[0][0];
            targetScopeIndex = 0;
        }
        else {
            var scopesInterfaceFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
            var scopeInfoFile = scopesInterfaceFolder.openDlg ("Select a scope.", "*", false);
            if (scopeInfoFile) {
                if (scopeInfoFile.alias)
                    scopeInfoFile = scopeInfoFile.resolve();
                targetScopeID = tsGetScopeID (scopeInfoFile);
                if (targetScopeID) {
                    for (var sc = 0; sc < tsScopesList.length; sc++) {
                        if (tsScopesList[sc][0] == targetScopeID) {
                            targetScopeID = tsScopesList[sc][0];
                            targetScopeIndex = sc;
                            break;
                        } 
                    }
                }
            }
            else {
                return false;
            }
        }
    }
    if (targetScopeIndex != -1) {
        if (!reportsFolder)
            reportsFolder = Folder (tsWorkshopPath).selectDlg ("Select a folder to report daily working time to.");
        if (reportsFolder) {
            if (!shiftsPeriods)
                shiftsPeriods = getShiftsPeriods ("08:30-16:30");
            if (shiftsPeriods) {
                var dailyFile = new File (tsScopesList[targetScopeIndex][1][5].parent.fsName.replace(/\\/g, '/') + "/Auto Work Time Reporting Settings");
                if (!dailyFile.parent.exists)
                    dailyFile.parent.create ();
                var workTimePath = reportsFolder.fsName.replace(/\\/g, '/');
                if ((workTimePath + "/").indexOf (tsWorkshopPath + "/") == 0) {
                    workTimePath = "<TREE_PATH>" + workTimePath.replace (tsWorkshopPath, "");
                }
                var dailyFileContent = tsScopesList[targetScopeIndex][0] + "\n" + workTimePath + "\n" + shiftsPeriods;
                writeEncodedFile (dailyFile, dailyFileContent);
            }
        }
    }
}

function getShiftsPeriods (shiftsPeriods) {
    var isWrongInput = true;
    while (isWrongInput) {
        isWrongInput = false;
        shiftsPeriods = prompt ("Shifts Periods: ", shiftsPeriods);
        if (shiftsPeriods) {
            var shifts = shiftsPeriods.replace (/ /g, "");
            shifts = shifts.split (",");
            if (shifts.length == 1) {
                var times = new Array;
                times.push (0);
                for (var sp = 0; sp < shifts.length; sp++) {
                    var time = shifts[sp].split ("-");
                    if (time.length != 2) {
                        isWrongInput = true;
                        break;
                    }
                    time[0] = time[0].split (":");
                    if (time[0].length != 2) {
                        isWrongInput = true;
                        break;
                    }
                    var thisTime1 = (parseInt (time[0][0], 10) * 60) + parseInt (time[0][1], 10);
                    if (thisTime1 <= times[times.length - 1]) {
                        isWrongInput = true;
                        break;
                    }
                    times.push (thisTime1);
                    time[1] = time[1].split (":");
                    if (time[1].length != 2) {
                        isWrongInput = true;
                        break;
                    }
                    var thisTime2 = (parseInt (time[1][0], 10) * 60) + parseInt (time[1][1], 10);
                    if (thisTime2 <= times[times.length - 1]) {
                        isWrongInput = true;
                        break;
                    }
                    times.push (thisTime2);
                }
                if (!isWrongInput) {
                    if (times[times.length - 1] > 1440) {
                        isWrongInput = true;
                    }
                }
            }
            else {
                isWrongInput = true;
            }
        }
    }
    return shiftsPeriods;
}

function uploadSelectedToHandler () {
    /**///$.writeln ($.line);
    var recipientIndexes = new Array;
    var scopeIndex = -1;
    var isToScope = confirm ("Do you want to upload to a scope?");
    if (isToScope) {
        var scopesInterfaceFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
        var scopeInfoFile = scopesInterfaceFolder.openDlg ("Select a scope to upload selected to.", "*", false);
        if (scopeInfoFile) {
            if (scopeInfoFile.alias)
                scopeInfoFile = scopeInfoFile.resolve();
            var selectedScopeID = tsGetScopeID (scopeInfoFile);
            if (selectedScopeID) {
                for (var sc = 0; sc < tsScopesList.length; sc++) {
                    if (tsScopesList[sc][0] == selectedScopeID) {
                        scopeIndex = sc;
                        break;
                    } 
                }
                if (scopeIndex == -1) {
                    return false;
                }
                else {
                    recipientIndexes = tsScopesList[scopeIndex][2];
                }
            }
        }
    }
    else {
        var collaboratorID = tsConfirmToPickCollaborator (null, "Select collaborator to get his working details.");
        if (collaboratorID) {
            var recipientIndex = tsGetRecipientIndex (collaboratorID);
            if (recipientIndex == -1) {
                return false;
            }
            else {
                recipientIndexes.push (recipientIndex);
            }
        }
    }
    //ask user to tsUpload actual files or just shades
    if (recipientIndexes.length > 0) {
        var isUploadActualFiles = confirm ("Upload actual files?\nIf 'No' placeholders (shades) will be uploaded.");
        var filesList = new Array;
        for (var c = 0; c < app.document.selections.length; c++) {
            retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
        }
        for (var r = 0; r < filesList.length; r++) {
            var fileID = tsGetID (filesList[r]);
            if (fileID) {
                if (!tsIsShade (filesList[r]) && isUploadActualFiles) {
                    var fileDotID = fileID.replace (/\//g,"\.");
                    fileDotID = fileDotID.slice (1);
                    if (scopeIndex != -1) {
                        tsUpload (fileDotID + ".ver00.0", -1, [scopeIndex]);
                    }
                    else
                    {
                        for (var rc = 0; rc < recipientIndexes.length; rc++) {
                            tsUpload (fileDotID + ".ver00.0", recipientsList[recipientIndexes[rc]][4], null);
                        }
                    }
                }
                else {
                    for (var rc = 0; rc < recipientIndexes.length; rc++) {
                        tsUploadFilePath (filesList[r], null, fileID, recipientIndexes[rc], true);
                    }
                }
            }
        }
    }
}

function updateTreeShadeSortHandler () {
    var dotBridgeSortFile = new File (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/.BridgeSort");
    var tsSortFile = new File (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/ts_sort.txt");
    if (dotBridgeSortFile.exists) {
        var dotBridgeSortContent = readFile (dotBridgeSortFile);
        if (dotBridgeSortContent) {
            var sortList = dotBridgeSortContent.match (/<item key.+\/>/g);
            if (sortList != null && sortList.length > 0) {
                for (var sl = 0; sl < sortList.length; sl++) {
                    sortList[sl] = sortList[sl].slice (11, -18);
                }
                for (sl = sortList.length - 1; sl >= 0; sl--) {
                    if (sortList[sl] == 'ts_sort.txt' || 
                        sortList[sl][0] == '.' ||
                        sortList[sl].slice (-5) == ".idlk" || 
                        sortList[sl].slice (-4) == ".tmp" || 
                        sortList[sl].slice (-4) == ".lst" || 
                        sortList[sl].slice(0, 2) == "~$") {
                        sortList.splice (sl, 1);
                    }
                }
                for (sl = 0; sl < sortList.length; sl++) {
                    var testedPure = tsGetPureName (sortList[sl], false);
                    for (var sla = 0; sla < sortList.length; sla++) {
                        if (sl == sla) {
                            continue;
                        }
                        if (testedPure == sortList[sla]) {
                            sortList.splice (sla, 1);
                            if (sl > sla) {
                                sl--;
                            }
                            break;
                        }
                    }
                }
                for (sl = 0; sl < sortList.length; sl++) {
                    sortList[sl] = tsGetPureName (sortList[sl], false);
                }
                var newContent =sortList.join ("\n");
                writeFile (tsSortFile, newContent);
                var fileID = tsUpdateFileState (tsSortFile, -2, -1);
                var digitsFileIDTriple = getWorkshopVersionInfo (tsSortFile, fileID);
                if (digitsFileIDTriple)
                    tsCheckIn (tsSortFile, digitsFileIDTriple, false, true, true, true, false, true, null);
            }
        }
    }
}

function tsUploadFilePath (targetFile, pathTime, fileID, recipientIndex, isWithThumbnail) {
    var fileDotID = fileID.replace (/\//g,"\.");
    fileDotID = fileDotID.slice (1);
    if (pathTime == null) {
        var pathTimeFile = File (tsDataPath + "/IDs" + fileID + "/Path" + "/Change Time");
        if (pathTimeFile.exists) {
            pathTime = readFile (pathTimeFile);  
        }
    }
    if (pathTime) {
        var pathRecordFile = new File (tsDataPath + "/IDs" + fileID + "/Path/V/" + pathTime + "/Value");
        if (pathRecordFile.exists) {
            var pathRecord = readEncodedFile (pathRecordFile);
            if (pathRecord) {
                //thumbnail
                var withThumbPart = "NO_THUMB";
                if (isWithThumbnail) {
                    if (targetFile == null) {
                        var fileID_Path_newID = [fileID];
                        tsGetPath (fileID_Path_newID);
                        if (fileID_Path_newID[1]) {
                            targetFile = new File (tsWorkshopPath + fileID_Path_newID[1]);  
                            if (targetFile.exists) {

                            }
                        }
                    }
                }
                if (targetFile && isWithThumbnail) {
                    var thumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
                    var syncThumbFile = new File (recipientsList[recipientIndex][1].fsName.replace(/\\/g, '/') + "/Path Thumb/" + fileDotID + "." + pathTime + ".jpg");
                    if (thumbFile.exists) {
                        thumbFile.copy (syncThumbFile);
                        withThumbPart = "WITH_THUMB";
                    }
                    else if (!tsIsShade (targetFile) && isCSFile (targetFile)) {
                        withThumbPart = "WITH_THUMB";
                        var thumbObj = new Thumbnail (targetFile);
                        
                        //tsUploadThumbnailsList[x][0] counter
                        //tsUploadThumbnailsList[x][1] file thumbnail
                        //tsUploadThumbnailsList[x][2] working thumbnail file
                        //tsUploadThumbnailsList[x][3] pathchanged thumbnail file
                        var tsUploadThumbnailsItem = new Array;
                        tsUploadThumbnailsItem.push (0);
                        tsUploadThumbnailsItem.push (thumbObj);
                        tsUploadThumbnailsItem.push (thumbFile);
                        tsUploadThumbnailsItem.push (syncThumbFile);
                        tsUploadThumbnailsList.push (tsUploadThumbnailsItem);
                    }
                }
                var previousID = readFile (File (tsDataPath + "/IDs" + fileID + "/Previous ID"));
                var originalID = readFile (File (tsDataPath + "/IDs" + fileID + "/Original ID"));
                if (!previousID) previousID = "NO_ID";
                if (!originalID) originalID = "NO_ID";
                tsIsSendingDone = false;
                var sendingBoxesItem = new Array;
                sendingBoxesItem.push ("PathChanged");
                sendingBoxesItem.push (fileDotID + "." + pathTime);
                sendingBoxesItem.push (pathRecord + "**" + withThumbPart + "**" + previousID + "**" + originalID);
                recipientsList[recipientIndex][8][1].push (sendingBoxesItem);
                return true;
            }
        } 
    }
    return false;
}

function workflowHandler () {
    /**///$.writeln ($.line);
    var workflowFolder = new Folder (tsRootFolderPath + "/Workflow");
    var needToBeCheckedInFolder = new Folder (workflowFolder.fsName.replace(/\\/g, '/') + "/Need To Be Checked In");
    if (!needToBeCheckedInFolder.exists)
        needToBeCheckedInFolder.create ();
    app.document.thumbnail = new Thumbnail (workflowFolder);
}

function produceNeedToBeCheckedIn () {
    var modifiedMessageFiles = Folder (tsDataPath + "/Messages/Modified").getFiles (isUnhiddenFile);
    var queryFolder = new Folder (tsRootFolderPath + "/Workflow/Need To Be Checked In");
    if (!queryFolder.exists) {
        queryFolder.create ();
    }
    else {
        var toBeDeleted = queryFolder.getFiles (isUnhiddenFileOrFolder);
        for (var tb = 0; tb < toBeDeleted.length; tb++) {
            if (toBeDeleted[tb] instanceof Folder) {
                deleteForcelyFolders (toBeDeleted[tb], true);
            }
            else {
                toBeDeleted[tb].remove ();
            }
        }
    }
    if (modifiedMessageFiles.length > 0) {
        for (var c = 0; c < modifiedMessageFiles.length; c++) {
            var fileID = "/" + File.decode (modifiedMessageFiles[c].name).replace (/\./g, "\/");
            var fileID_Path_newID = [fileID];
            tsGetPath (fileID_Path_newID);
            if (fileID_Path_newID[1]) {
                var targetFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                if (targetFile.exists) {
                    if (tsIsShade (targetFile)) {
                        modifiedMessageFiles[c].remove ();
                        continue;
                    }
                    var shortcutFile = new File (queryFolder.fsName.replace(/\\/g, '/') + fileID_Path_newID[1]);
                    if (!shortcutFile.exists) {
                        if (!shortcutFile.parent.exists) {
                            shortcutFile.parent.create ();
                        }
                        shortcutFile.createAlias (targetFile);
                    }
                }
            }
        }
        app.document.thumbnail = new Thumbnail (queryFolder);
    }
}

function queryPlacingLocationsForSelection () {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    var dateName = new Date().getTime();
    dateName = dateName.toString ();
    var queryFolder = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);
    var isPlaced = false;
    var expectedExtList = [".jpg", ".png"];
    for (var v = 0; v < filesList.length; v++) {
        var pagesFiles = retrievePlacingPages (filesList[v]);
        if (pagesFiles.length > 0)
            isPlaced = true;
        for (var p = 0; p < pagesFiles.length; p++) {
            var pageFile = new File (pagesFiles[p][0] + expectedExtList[0]);
            if (!pageFile.exists) {
                var testPageFile = new File (pagesFiles[p][0] + expectedExtList[1]);
                if (testPageFile.exists) {
                    pageFile = testPageFile;
                    var swapCell = expectedExtList[0];
                    expectedExtList[0] = expectedExtList[1];
                    expectedExtList[1] = swapCell;
                }
            }
            var pageThumbnailFile = new File (pageFile.fsName.replace(/\\/g, '/').replace (tsPagesPath, queryFolder.fsName.replace(/\\/g, '/')));
            if (pageFile.exists) {
                if (!pageThumbnailFile.parent.exists)
                    pageThumbnailFile.parent.create ();
                pageFile.copy (pageThumbnailFile);
            }
            else {
                if (!pageThumbnailFile.parent.exists) {
                    pageThumbnailFile.parent.create ();
                }
                writeFile (pageThumbnailFile, "TS");
            }
        }
    }
    if (!isPlaced)
        alert ("There are no placing locations.");
    else {
        var continueDiving = true;
        var browsingFolder = queryFolder;
        var toBeSelected;
        while (continueDiving) {
            continueDiving = false;
            var includedFiles = browsingFolder.getFiles (isUnhiddenFileOrFolder);
            if (includedFiles.length == 1) {
                if (includedFiles[0] instanceof Folder) {
                    browsingFolder = includedFiles[0];
                    continueDiving = true;
                }
                else {
                    toBeSelected = includedFiles[0];
                }
            }
        }
        app.document.thumbnail = new Thumbnail (browsingFolder);
        if (toBeSelected) {
            app.document.select (new Thumbnail (toBeSelected));
        }
    }
}

function queryLinksForSelection () {
    /**///$.writeln ($.line);
    var filesList = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        retrieveFilesList (app.document.selections[c].spec, filesList, false, []);
    }
    var dateName = new Date().getTime();
    dateName = dateName.toString ();
    var queryFolder = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);
    queryFolder.create ();
    for (var i = 0; i < filesList.length; i++) {
        if (filesList[i].fsName.replace(/\\/g, '/').indexOf (tsWorkshopPath + "/") == 0) {
            if (isInDesignFile (filesList[i])) {
                var fileID = tsGetID (filesList[i]);
                if (fileID) {
                    var linksReportFile = new File (tsDataPath + "/IDs" + fileID + "/Workshop/LinksReport");
                    var reportContent = readFile (linksReportFile);
                    if (reportContent) {
                        var reportLines = reportContent.split ("\n");
                        if (reportLines.length > 1) {
                            for (var u = 1; u < reportLines.length; u++) {
                                var fileID_Path_newID = [reportLines[u]];
                                tsGetPath (fileID_Path_newID);
                                if (fileID_Path_newID[1]) {
                                    var linkFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                    if (linkFile.exists) {
                                        var shortcutFile = new File (queryFolder.fsName.replace(/\\/g, '/') + fileID_Path_newID[1]);
                                        if (!shortcutFile.exists) {
                                            if (!shortcutFile.parent.exists) {
                                                shortcutFile.parent.create ();
                                            }
                                            shortcutFile.createAlias (linkFile);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    app.document.thumbnail = new Thumbnail (queryFolder);
}

function retrievePlacingPages (targetFile) {
    /**///$.writeln ($.line);
    var pagesList = new Array;
    var linkFileID = tsGetID (targetFile);
    var isVersion = ((targetFile.fsName.replace(/\\/g, '/').indexOf (tsVersionsPath + "/") == 0) && tsVersionsPath != "");
    var versionPrefix;
    if (linkFileID) {
        var placesFolder;
        if (isVersion) {
            versionPrefix = File.decode (targetFile.name).slice (0, 5);
            placesFolder = new Folder (tsDataPath + "/IDs" + linkFileID + "/" + versionPrefix + "/Places");
        }
        else {
            placesFolder = new Folder (tsDataPath + "/IDs" + linkFileID + "/Workshop/Places");
        }
        if (placesFolder.exists) {
            var placesFiles = placesFolder.getFiles (isUnhiddenFile);
            for (var e = 0; e < placesFiles.length; e++) {
                var pagesFolder = null;
                var fileDotID = null;
                var versionDotID = null;
                var inDesignVersionPrefix = null;
                if (isVersion) {
                    versionDotID = File.decode (placesFiles[e].name).slice (0, File.decode (placesFiles[e].name).lastIndexOf ("."));
                    inDesignVersionPrefix = versionDotID.slice (versionDotID.lastIndexOf (".") + 1);
                    fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                }
                else {
                    fileDotID = File.decode (placesFiles[e].name);
                }
                var fileID = "/" + fileDotID.replace (/\./g, "\/");
                var fileID_Path_newID = [fileID];
                tsGetPath (fileID_Path_newID);
                if (fileID_Path_newID[1]) {
                    if (isVersion) {
                        if (tsVersionsOutputZero == "ONLY_ZERO") {
                            var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                            var currentDigits = null;
                            var currentContent = readFile (currentRecordFile);
                            if (currentContent) {
                                currentContent = currentContent.split (":");
                                currentDigits = currentContent[0];
                            }
                            if (inDesignVersionPrefix == "ver" + currentDigits) {
                                inDesignVersionPrefix = "ver00";
                            }
                        }
                        pagesFolder = new Folder (tsVersionsPages + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + inDesignVersionPrefix + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1).slice (0, -5));
                    }
                    else {
                        pagesFolder = new Folder (tsPagesPath + "/Workshop" + fileID_Path_newID[1]);
                    }
                }
                if (pagesFolder) {
                    var pageNumbers = readFile (placesFiles[e]);
                    if (pageNumbers) {
                        var pageNumbersLines = pageNumbers.split ("\n");
                        for (var n = 0; n < pageNumbersLines.length; n++) {
                            var pageLocations = pageNumbersLines[n].split ("|");
                            if (pageLocations.length > 0) {
                                var pageName = tsFillZerosIfAllDigits (pageLocations[0], 4);
                                var fullPathWithoutExt = pagesFolder.fsName.replace(/\\/g, '/') + "/" + pageName;
                                pagesList.push ([fullPathWithoutExt, pageLocations]);
                            }
                        }
                    }
                    else {
                        continue;
                    }
                }
                else {
                    continue;
                }
            }
        }
    }
    return pagesList;
}

function retrievePlacingDocsIDs (linkFileID) {
    var placingDocsIDsList = new Array;
    var placesFolder;
    placesFolder = new Folder (tsDataPath + "/IDs" + linkFileID + "/Workshop/Places");
    if (placesFolder.exists) {
        var placesFiles = placesFolder.getFiles (isUnhiddenFile);
        for (var e = 0; e < placesFiles.length; e++) {
            var versionDotID;
            var inDesignVersionPrefix;
            var fileDotID = File.decode (placesFiles[e].name);
            var fileID = "/" + fileDotID.replace (/\./g, "\/");
            placingDocsIDsList.push (fileID);
        }
    }
    return placingDocsIDsList;
}

function tsRetrieveLabelIDsList (labelFile, IDsList) {
    /**///$.writeln ($.line);
    if (labelFile.alias) {
        labelFile = labelFile.resolve();
        if (!labelFile)
            return false;
        if (!labelFile.exists)
            return false;
    }
    var allUnhiddenItems = labelFile.parent.getFiles (isAcceptedFileOrFolder);
    var allFiles = new Array;
    for (var c = 0; c < allUnhiddenItems.length; c++) {
        var theFile = null;
        if (allUnhiddenItems[c] instanceof Folder) {
            var subLabelFile = allUnhiddenItems[c].getFiles (tsIsLabelFile);
            if (subLabelFile.length > 0) {
                theFile = subLabelFile[0];
            }
        }
        else {
            theFile = allUnhiddenItems[c];
        }
        if (theFile) {
            var fileID = tsGetID (theFile);
            if (fileID) {
                IDsList.push (fileID);
                allFiles.push (theFile);
            }
        }
    }
    return allFiles;
}

function retrieveFilesList (targetItem, filesList, isUserSortOrder, excludedParentNames) {
    /**///$.writeln ($.line);
    if (targetItem.alias) {
        targetItem = targetItem.resolve();
        if (!targetItem)
            return false;
        if (!targetItem.exists)
            return false;
    }
    if (targetItem instanceof Folder) {
        for (var epn = 0; epn < excludedParentNames.length; epn++) {
            if (File.decode (targetItem.name) == excludedParentNames[epn]) {
                return false;
            }
        }
        var allUnhiddenItems = null;
        allUnhiddenItems = targetItem.getFiles (isAcceptedFileOrFolder);
        if (isUserSortOrder) {
            tsSortFilesList (targetItem, allUnhiddenItems, null);
        }
        for (var c = 0; c < allUnhiddenItems.length; c++) {
            retrieveFilesList (allUnhiddenItems[c], filesList, isUserSortOrder, excludedParentNames);
        }
    }
    else {
        filesList.push (targetItem);
    }
    return true;
}

function tsSortFilesList (targetFolder, filesList, isTargetFolders) {
    var tsSortFile = new File (targetFolder.fsName.replace(/\\/g, "/") + "/ts_sort.txt");
    if (tsSortFile.exists) {
        var sortFileContent = readFile (tsSortFile);
        if (sortFileContent) {
            var sortList = '';
            if (sortFileContent.indexOf ('\r\n') != -1) {
                sortList = sortFileContent.split ('\r\n');
            }
            else {
                sortList = sortFileContent.split ('\n');
            }
            if (sortList) {
                var sortIndex = 0;
                for (var sl = 0; sl < sortList.length; sl++) {
                    var pureFileName = sortList[sl];
                    for (var fl = sortIndex; fl < filesList.length; fl++) {
                        var testedName = File.decode (filesList[fl].name);
                        if (filesList[fl] instanceof File) {
                            if (isTargetFolders) {
                                continue;
                            }
                            testedName = tsGetPureName (testedName, false);
                        }
                        else {
                            if (isTargetFolders == false) {
                                continue;
                            }
                        }
                        if (testedName == pureFileName) {
                            if (fl != sortIndex) {
                                var swapCell = filesList[fl];
                                filesList[fl] = filesList[sortIndex];
                                filesList[sortIndex] = swapCell;
                            }
                            sortIndex++;
                            break;
                        }
                    }
                }
                return true;
            }
        }
    }
    return false;
}

function retrieveFilesListWithSubs (targetItem, filesListWithSubs, subFolders, selectedName) {
    /**///$.writeln ($.line);
    if (targetItem.alias) {
        targetItem = targetItem.resolve();
        if (!targetItem)
            return false;
        if (!targetItem.exists)
            return false;
    }
    if (targetItem instanceof Folder) {
        if (selectedName == "") {
            selectedName = File.decode (targetItem.name);
        }
        else {
            if (subFolders.length > 0)
                subFolders += "/";
            subFolders += File.decode (targetItem.name);
        }
        var allUnhiddenItems = targetItem.getFiles (isAcceptedFileOrFolder);
        for (var c = 0; c < allUnhiddenItems.length; c++) {
            retrieveFilesListWithSubs (allUnhiddenItems[c], filesListWithSubs, subFolders, selectedName);
        }
    }
    else {
        var twin = new Array;
        twin.push (targetItem);
        twin.push (subFolders);
        twin.push (selectedName);
        filesListWithSubs.push (twin);
    }
}

function tsCheckIn (targetFile, digitsFileIDTriple, isFinal, isWithPDF, isWithPages, isToPhysical, isInfoUser, isDirectCommand, requestedID) {
    /**///$.writeln ($.line);
    var currentTime = new Date ().getTime ();
    var fileID = digitsFileIDTriple[2];
    if (!fileID) {
        return false;
    }
    var currentVersionFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
    var currentVersionContent = readFile (currentVersionFile);
    var finalMark;
    if (currentVersionContent) {
        currentVersionContent = currentVersionContent.split (":")[0];
        finalMark = currentVersionContent.split (":")[1];
    }
    var isFirstVersion = false;
    var versionsFolder = digitsFileIDTriple[1].parent;
    var isCurrentVersionChanged = false;
    if (digitsFileIDTriple[0] == "new") {
        isFirstVersion = true;
        digitsFileIDTriple[0] = "01";
        digitsFileIDTriple[1] = new File (versionsFolder.fsName.replace(/\\/g, '/') + "/ver" + digitsFileIDTriple[0] + " " + File.decode (targetFile.name));
    }
    var isInDesign = isInDesignFile (targetFile);
    var reportLines = new Array;
    var pathTime;
    var pathTimeFile = File (tsDataPath + "/IDs" + fileID + "/Path" + "/Change Time");
    if (pathTimeFile.exists) {
        pathTime = readFile (pathTimeFile);  
    }
    if (!pathTime) {
        //$.writeln ("Error " + $.line);
        return false;
    }
    if (isInDesign) {
        var linksReportFile = new File (tsDataPath + "/IDs" + fileID + "/Workshop/LinksReport");
        var reportContent = readFile (linksReportFile);
        if (reportContent) {
            reportLines = reportContent.split ("\n");
            for (var u = 1; u < reportLines.length; u++) {
                var fileID_Path_newID = [reportLines[u]];
                tsGetPath (fileID_Path_newID);
                if (fileID_Path_newID[1]) {
                    var linkFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                    if (linkFile.exists) {
                        if (tsIsShade (linkFile))
                            continue;
                        var subDigitsFileIDTriple = getWorkshopVersionInfo (linkFile, fileID_Path_newID[0]);
                        if (subDigitsFileIDTriple)
                            tsCheckIn (linkFile, subDigitsFileIDTriple, isFinal, true, true, true, false, true, null);
                    }
                }
            }
        }
    }
    if (tsIsShade (targetFile)) {
        return "SHADE";
    }
    
    
    var versionTimeFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/Modifying Time");
    var versionOldTime = readFile (versionTimeFile);
    if (versionOldTime) {
        var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/V/" + versionOldTime + "/UnderEditingByOther");
        if (underEditingByOtherFile.exists) {
            var editorName = readFile (underEditingByOtherFile);
            if (isInfoUser)
                alert ("The file hadn't checkedin because it's under editing by " + editorName + ".");
            return "UNDER_EDITING_BY_OTHER";
        }
    }
    
    var fileDotID = fileID.replace (/\//g,"\.");
    fileDotID = fileDotID.slice (1); 

    var targetTwin = getTotalGoal (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""), null, fileID, false);
    if (currentVersionContent == digitsFileIDTriple[0]) {
        var modified = tsGetActualModified (targetFile.modified.getTime (), fileID);
        versionOldTime = !versionOldTime? 0 : parseInt (versionOldTime, 10);
        if (modified <= versionOldTime && digitsFileIDTriple[1].exists) { // && !isFinal
            if (isFinal && versionOldTime != 0) {
                for (var auno = 0; auno < targetTwin.length; auno++) {
                    for (var asp = 0; asp < targetTwin[auno].length; asp++) {
                        for (var arc = 0; arc < targetTwin[auno][asp][1].length; arc++) {
                            tsIsSendingDone = false;
                            var sendingBoxesItem = new Array;
                            sendingBoxesItem.push ("NewState");
                            sendingBoxesItem.push (fileDotID + ".ver" + digitsFileIDTriple[0] + "." + versionOldTime);
                            sendingBoxesItem.push ("FINAL" + ":" + (new Date().getTime()));
                            recipientsList[targetTwin[auno][asp][1][arc]][8][1].push (sendingBoxesItem);
                        }
                    }
                }
                if (isInDesign && isWithPDF) {
                    var prevPDFFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPDFPath) + "/ver" + digitsFileIDTriple[0] + " " + File.decode (targetFile.name).slice (0, File.decode (targetFile.name).length -5) + ".pdf"); 
                    if (prevPDFFile.exists) {
                        var finalPDFFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsFinalPDFPath) + "/" + File.decode (targetFile.name).slice (0, File.decode (targetFile.name).length -5) + ".pdf"); 
                        if (!finalPDFFile.parent.exists)
                            finalPDFFile.parent.create ();
                        prevPDFFile.copy (finalPDFFile);
                    }
                }
            }
            if (isInfoUser)
                alert ("The file is already checked in.");
            return "ALREADY_CHECKEDIN";
        }
        else {
            var modifierFile = new Folder (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/V/" + versionOldTime + "/Modifier");
            if (modifierFile.exists) {
                //jump to new version
                if (!isDirectCommand) {
                    return "MODIFIED_NOT_DIRECT";
                }
                var maxNumber = 0;
                var allVersions = Folder (tsDataPath + "/IDs" + fileID).getFiles ("ver??");
                if (allVersions.length > 0) {
                    maxNumber = parseInt (File.decode (allVersions[allVersions.length-1].name).slice (3), 10);
                }
                maxNumber += 1;    
                if (!isFirstVersion) {
                    tsCancelEditing (targetFile, fileID, [currentVersionContent, (finalMark == "P"? false : true)], false, false);
                }
                isCurrentVersionChanged = true;
                digitsFileIDTriple[0] = maxNumber < 10? "0" + maxNumber : "" + maxNumber;
                digitsFileIDTriple[1] = new File (versionsFolder.fsName.replace(/\\/g, '/') + "/ver" + digitsFileIDTriple[0] + " " + File.decode (targetFile.name));
                versionTimeFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/Modifying Time");
            }
        }
    }
    else {
        if (!isFirstVersion) {
            tsCancelEditing (targetFile, fileID, [currentVersionContent, (finalMark == "P"? false : true)], false, false);
        }
        isCurrentVersionChanged = true;
    }
    if (isCurrentVersionChanged || !finalMark || (finalMark == "P"? false : true) != isFinal) {
        if (!currentVersionFile.parent.exists)
            currentVersionFile.parent.create ();
        writeFile (currentVersionFile, digitsFileIDTriple[0] + ":" + (isFinal? "F" : "P"));
    }

    //remove the modified message if exist
    var modifiedMessageFile = new File (tsDataPath + "/Messages/Modified/" + fileDotID);
    if (isToPhysical) {
        if (modifiedMessageFile.exists)
            modifiedMessageFile.remove ();
    }
    else if (isFirstVersion || isCurrentVersionChanged) {
        if (!modifiedMessageFile.exists) {
            if (!modifiedMessageFile.parent.exists)
                modifiedMessageFile.parent.create ();
            writeFile (modifiedMessageFile, currentTime);
        }
    }

    //Delete missed and out reports
    var missedRecordFile = new Folder (tsDataPath + "/IDs" + fileID + "/Workshop/MissedReport");
    if (missedRecordFile.exists)
        missedRecordFile.remove ();
    var outRecordFile = new Folder (tsDataPath + "/IDs" + fileID + "/Workshop/OutReport");
    if (outRecordFile.exists)
        outRecordFile.remove ();

    //deleting old pdfs
    var oldPrevPDFFile;
    var oldFinalPDFFile;
    if (isInDesign) {
        oldPrevPDFFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPDFPath) + "/ver" + digitsFileIDTriple[0] + " " + File.decode (targetFile.name).slice (0, File.decode (targetFile.name).length -5) + ".pdf"); 
        if (oldPrevPDFFile.exists) {
            if (!isWithPDF) {
                oldPrevPDFFile.remove ();
            }
        }
        oldFinalPDFFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsFinalPDFPath) + "/" + File.decode (targetFile.name).slice (0, File.decode (targetFile.name).length -5) + ".pdf"); 
        if (oldFinalPDFFile.exists) {
            oldFinalPDFFile.remove ();
        }
    }

    //copying working copy to version 
    var versionName = "ver" + digitsFileIDTriple[0] + " " + File.decode (targetFile.name);
    
    if (digitsFileIDTriple[1].exists) {
        digitsFileIDTriple[1].readonly = false;
        digitsFileIDTriple[1].remove ();
    }
    else {
        if (!versionsFolder.exists) {
            if (!versionsFolder.create ())
                return false;
        }
    }
    var targetThumbnail = new Thumbnail (targetFile);
    if (targetFile.length > 500000000) {
        tsCopyToList.push ([targetThumbnail, versionsFolder, versionName]);
    }
    else {
        try {
            targetThumbnail.copyTo (versionsFolder);
            File (versionsFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (targetFile.name)).rename (versionName);
        }
        catch (e) {
            /*Error*/$.writeln ("Error " + $.line);
        }
    }
    //alerting new changes
    
    if (!versionTimeFile.parent.exists)
        versionTimeFile.parent.create ();
    writeFile (versionTimeFile, currentTime);

    var versionDotID = fileDotID + ".ver" + digitsFileIDTriple[0];
    var isRequired = false;
    
    if (isToPhysical) {
        //mark Workflow/Checked In
        var targetVersionFile = new File (versionsFolder.fsName.replace(/\\/g, '/') + "/" + versionName);
        var checkedInRootFolder = Folder (tsRootFolderPath + "/Workflow/Checked In");
        var checkedInDate = new Date (currentTime);
        var month = checkedInDate.getMonth () + 1;
        var day = checkedInDate.getDate ();
        var hours = checkedInDate.getHours();
        var minutes = checkedInDate.getMinutes();
        month = month > 9? month.toString () : "0" + month.toString ();
        day = day > 9? day.toString () : "0" + day.toString ();
        var AmPm = "am";
        if (hours > 12) {
            AmPm = "pm";
            hours = hours - 12;
        }
        hours = hours > 9? hours.toString () : "0" + hours.toString ();
        minutes = minutes > 9? minutes.toString () : "0" + minutes.toString ();
        var dayName;
        switch (checkedInDate.getDay ()) {
            case 0:
                dayName = "Sunday";
                break;
            case 1:
                dayName = "Monday";
                break;
            case 2:
                dayName = "Tuesday";
                break;
            case 3:
                dayName = "Wednesday";
                break;
            case 4:
                dayName = "Thursday";
                break;
            case 5:
                dayName = "Friday";
                break;
            case 6:
                dayName = "Saturday";
                break;
        }
    
        var senderName = tsUserName;
        
        var shortcutFile = new File (checkedInRootFolder.fsName.replace(/\\/g, '/') + "/" + checkedInDate.getFullYear() + "." + month + "/" + day + "." + dayName + "/" + senderName + targetVersionFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, ""));
        shortcutFile.parent.create ();
        shortcutFile.createAlias (targetVersionFile);
        //end
        
        for (var wsp = 0; wsp < targetTwin[0].length; wsp++) {
            if (targetTwin[0][wsp][0] != "SELF") {
                var verSelf = new Folder (tsScopesList[targetTwin[0][wsp][0]][1][5].parent.fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0]);
                var allOldSelf = verSelf.getFiles (isUnhiddenFolder);
                for (var aos = 0; aos < allOldSelf.length; aos++)
                    deleteForcelyFolders (allOldSelf[aos], true);
                var waitingFolder = new Folder (verSelf.fsName.replace(/\\/g, '/') + "/" + currentTime + "/Waited");
                waitingFolder.create ();
                for (var wrc = 0; wrc < targetTwin[0][wsp][1].length; wrc++) {
                    writeFile (File (waitingFolder.fsName.replace(/\\/g, '/') + "/" + recipientsList[targetTwin[0][wsp][1][wrc]][0]), "TS");
                    isRequired = true;
                }
                if (targetFile.length > 500000000) {
                    tsCopyToList.push ([targetThumbnail, waitingFolder.parent, "File"]);
                }
                else {
                    try {
                        targetThumbnail.copyTo (waitingFolder.parent);
                        File (waitingFolder.parent.fsName.replace(/\\/g, '/') + "/" + File.decode (targetFile.name)).rename ("File");
                    }
                    catch (e) {
                        /*Error*/$.writeln ("Tree Shade Error " + $.line + ": " + e);
                    }
                }
            }
            else {
                for (var wrc = 0; wrc < targetTwin[0][wsp][1].length; wrc++) {
                    var verScope = new Folder (recipientsList[targetTwin[0][wsp][1][wrc]][1].fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0]);
                    var allOldScope = verScope.getFiles (isUnhiddenFolder);
                    for (var aoc = 0; aoc < allOldScope.length; aoc++)
                        deleteForcelyFolders (allOldScope[aoc], true);
                    var selfFile = new File (verScope.fsName.replace(/\\/g, '/') + "/" + currentTime + "/File");
                    selfFile.parent.create ();
                    if (targetFile.length > 500000000) {
                        tsCopyToList.push ([targetThumbnail, selfFile.parent, "File"]);
                    }
                    else {
                        try {
                            targetThumbnail.copyTo (selfFile.parent);
                            File (selfFile.parent.fsName.replace(/\\/g, '/') + "/" + File.decode (targetFile.name)).rename ("File");
                        }
                        catch (e) {
                            /*Error*/$.writeln ("Tree Shade Error " + $.line + ": " + e);
                        }
                    }
                    isRequired = true;
                }
            }
        }
    }

    var packageLinksContent;
    var manualPDFFile = null;
    if (isInDesign) {
        packageLinksContent = tsCheckInLinksRelations (fileID, "ver" + digitsFileIDTriple[0], currentTime, reportLines);
        if (isWithPDF) {
            manualPDFFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + "/pdf/" + File.decode (targetFile.name).slice (0, File.decode (targetFile.name).lastIndexOf (".")) + ".pdf");
            if (manualPDFFile.exists) {
                if (!tsIsShade (manualPDFFile)) {
                    if (!oldPrevPDFFile.parent.exists)
                        oldPrevPDFFile.parent.create ();
                    if (oldPrevPDFFile.exists)
                        File (oldPrevPDFFile.fsName.replace(/\\/g, '/')).remove ();
                    manualPDFFile.copy (oldPrevPDFFile);
                }
            }
            else {
                manualPDFFile = null;
            }
        }
        if (tsPagesPath != "") {
            var workingPagesFolder = null;
            var workingFiles = null;
            var versionPagesFolder = null;
            var versionPagesZeroFolder = null;
            if (isWithPages) {
                workingPagesFolder = new Folder (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsPagesPath + "/Workshop"));
                workingFiles = new Array;
                if (workingPagesFolder.exists)
                    workingFiles = workingPagesFolder.getFiles (isUnhiddenFile);
                if (workingFiles.length == 0) {
                    isWithPages = false;
                }
                if (tsVersionsOutputZero != "ONLY_ZERO") {
                    versionPagesFolder = new Folder (digitsFileIDTriple[1].fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages).slice (0, -5));
                    if (versionPagesFolder.exists) {
                        var toBeDeletedFiles = versionPagesFolder.getFiles (isUnhiddenFile);
                        for (var t = 0; t < toBeDeletedFiles.length; t++) {
                            toBeDeletedFiles[t].remove ();
                        }
                        if (!isWithPages)
                            versionPagesFolder.remove();
                    }
                    else if (isWithPages) {
                        versionPagesFolder.create ();
                    }
                }
                if (tsVersionsOutputZero == "ONLY_ZERO" || tsVersionsOutputZero == "WITH_ZERO") {
                    var tempZeroFol = new Folder (digitsFileIDTriple[1].fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages).slice (0, -5));
                    versionPagesZeroFolder = new Folder (tempZeroFol.fsName.replace(/\\/g, '/').slice (0, tempZeroFol.fsName.replace(/\\/g, '/').lastIndexOf ("/ver")) + "/ver00" + tempZeroFol.fsName.replace(/\\/g, '/').slice (tempZeroFol.fsName.replace(/\\/g, '/').lastIndexOf ("/ver") + 6));
                    if (versionPagesZeroFolder.exists) {
                        var toBeDeletedFiles = versionPagesZeroFolder.getFiles (isUnhiddenFile);
                        for (var t = 0; t < toBeDeletedFiles.length; t++) {
                            toBeDeletedFiles[t].remove ();
                        }
                        if (!isWithPages)
                        versionPagesZeroFolder.remove();
                    }
                    else if (isWithPages) {
                        versionPagesZeroFolder.create ();
                    }
                }
            }
            var physicalPrevTwin = new Array;
            //physicalPrevTwin from tsPhysicalPDFList
            //tsPhysicalPDFList[x][0] the pdf version file to be copied
            //tsPhysicalPDFList[x][1] array of target pdf physical files in scopes
            //tsPhysicalPDFList[x][2] the target pdf final
            //tsPhysicalPDFList[x][3] the manual pdf file to be removed
            //tsPhysicalPDFList[x][4] the pdf version file to be copied size
            //tsPhysicalPDFList[x][5] is copying done
            var physicalPagesFolders = new Array;
            if (isRequired) {
                if (isWithPages) {
                    for (var psp = 0; psp < targetTwin[0].length; psp++) {
                        if (targetTwin[0][psp][0] != "SELF") {
                            physicalPagesFolders.push (Folder (tsScopesList[targetTwin[0][psp][0]][1][5].parent.fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0] + "/" + currentTime + "/Pages"));
                            if (!physicalPagesFolders[physicalPagesFolders.length - 1].exists)
                                physicalPagesFolders[physicalPagesFolders.length - 1].create ();
                            var physicalCountFile = new File (tsScopesList[targetTwin[0][psp][0]][1][5].parent.fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0] + "/" + currentTime + "/Count");
                            writeFile (physicalCountFile, workingFiles.length);
                        }
                        else {
                            for (var prc = 0; prc < targetTwin[0][psp][1].length; prc++) {
                                physicalPagesFolders.push (Folder (recipientsList[targetTwin[0][psp][1][prc]][1].fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0] + "/" + currentTime + "/Pages"));
                                if (!physicalPagesFolders[physicalPagesFolders.length - 1].exists)
                                    physicalPagesFolders[physicalPagesFolders.length - 1].create ();
                                var physicalCountFile = new File (recipientsList[targetTwin[0][psp][1][prc]][1].fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0] + "/" + currentTime + "/Count");
                                writeFile (physicalCountFile, workingFiles.length);
                            }
                        }
                    }
                }
                if (isWithPDF) {
                    var physicalPrevPDFFiles = new Array;
                    physicalPrevTwin.push (oldPrevPDFFile);
                    for (var ysp = 0; ysp < targetTwin[0].length; ysp++) {
                        if (targetTwin[0][ysp][0] != "SELF") {
                            physicalPrevPDFFiles.push (File (tsScopesList[targetTwin[0][ysp][0]][1][5].parent.fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0] + "/" + currentTime + "/PrevPDF"));
                        }
                        else {
                            for (var yrc = 0; yrc < targetTwin[0][ysp][1].length; yrc++) {
                                physicalPrevPDFFiles.push (File (recipientsList[targetTwin[0][ysp][1][yrc]][1].fsName.replace(/\\/g, '/') + "/.tssync" + fileID + "/ver" + digitsFileIDTriple[0] + "/" + currentTime + "/PrevPDF"));
                            }
                        }
                    }
                    physicalPrevTwin.push (physicalPrevPDFFiles);
                    if (isFinal) {
                        physicalPrevTwin.push (oldFinalPDFFile);
                    }
                    else {
                        physicalPrevTwin.push (null);
                    }
                    physicalPrevTwin.push (manualPDFFile);
                }
            }
            else {
                if (isWithPDF) {
                    physicalPrevTwin.push (oldPrevPDFFile);
                    physicalPrevTwin.push (null);
                    if (isFinal) {
                        physicalPrevTwin.push (oldFinalPDFFile);
                    }
                    else {
                        physicalPrevTwin.push (null);
                    }
                    physicalPrevTwin.push (manualPDFFile);
                }
            }
            if (isWithPDF) {
                physicalPrevTwin.push (0); //tsPhysicalPDFList[x][4] the pdf version file to be copied size
                physicalPrevTwin.push (false); //tsPhysicalPDFList[x][5] is copying done
                tsPhysicalPDFList.push (physicalPrevTwin);  
            }
            if (isWithPages) {
                for (var w = 0; w < workingFiles.length; w++) {
                    if (!(workingFiles[w] instanceof File))
                        continue;
                    if (!workingFiles[w].exists)
                        continue;
                    var pageThumbnail = new Thumbnail (workingFiles[w]);
                    if (versionPagesFolder)
                        pageThumbnail.copyTo (versionPagesFolder);
                    if (versionPagesZeroFolder)
                        pageThumbnail.copyTo (versionPagesZeroFolder);
                    if (isRequired) {
                        for (var fpf = 0; fpf < physicalPagesFolders.length; fpf++) {
                            pageThumbnail.copyTo (physicalPagesFolders[fpf]);
                        }
                    }
                }
            }
        }
    } 
    var downloadFileContent;
    var darkOrWhite = "Dark";
    var extraPackaging = "None";
    if (isWithPDF && isWithPages) {
        extraPackaging = "With All";
    }
    else if (isWithPDF) {
        extraPackaging = "With PDF";
    }
    else if (isWithPages) {
        extraPackaging = "With Pages";
    }
    var abstractFsName = targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
    var requiredFolder = new Folder (tsDataPath + "/IDs" + fileID + "/Required");
    if (isRequired) {
        if (!requiredFolder.exists)
            requiredFolder.create ();
    }
    var thumbnailFile = null;
    var workingThumbFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + tsGetTreeShadeThumb (File.decode (targetFile.name)) + File.decode (targetFile.name) + ".jpg");
    var isWorkingThumbFabricated = false;
    var isWorkingThumbExist = false;
    if (workingThumbFile.exists) {
        isWorkingThumbExist = true;
        if (tsGetMetadata (workingThumbFile, "TS_THUMB_FABRICATED")) {
            isWorkingThumbFabricated = true;
        }
    }
    if (isWorkingThumbFabricated) {
        thumbnailFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/V/" + currentTime + "/Thumbnail.jpg");
        if (!thumbnailFile.parent.exists)
            thumbnailFile.parent.create();
        workingThumbFile.copy (thumbnailFile);                         
    }
    else if (isCSFile (targetFile)) {
        if (!isWorkingThumbExist && !workingThumbFile.parent.exists) {
            workingThumbFile.parent.create();
        }
        var thumbObj = new Thumbnail (targetFile);
        thumbObj.core.thumbnail.thumbnail.exportTo(workingThumbFile, 0); 
    }
    if (!isToPhysical && isCurrentVersionChanged) {
        var underEditingFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/V/" + currentTime + "/UnderEditing");
        if (!underEditingFile.parent.exists)
            underEditingFile.parent.create ();
        writeFile (underEditingFile, "TS");
    }
    var previousID = readFile (File (tsDataPath + "/IDs" + fileID + "/Previous ID"));
    var originalID = readFile (File (tsDataPath + "/IDs" + fileID + "/Original ID"));
    if (!previousID) previousID = "NO_ID";
    if (!originalID) originalID = "NO_ID";
    for (var twin = 0; twin < targetTwin.length; twin++) {
        if (twin == 1 || !isToPhysical) {
            if (thumbnailFile == null) {
                thumbnailFile = false;
                if (isCSFile (targetFile)) {
                    thumbnailFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + digitsFileIDTriple[0] + "/V/" + currentTime + "/Thumbnail.jpg");
                    if (!thumbnailFile.parent.exists)
                        thumbnailFile.parent.create();
                    var thumbObj = new Thumbnail (targetFile);
                    thumbObj.core.thumbnail.thumbnail.exportTo(thumbnailFile, 0);  
                }
            }
            darkOrWhite = "Dark";
            if (!isToPhysical) 
                darkOrWhite = "Under Editing";
            downloadFileContent = (isFinal ? "Final" : "Proof");
            downloadFileContent += ":" + darkOrWhite + ":" + extraPackaging + ":" + previousID + ":" + originalID;
            downloadFileContent += "\n" + (currentVersionContent? currentVersionContent : "New"); //1
            downloadFileContent += "\n" + pathTime; //2
            downloadFileContent += "\n" + abstractFsName; //3
            
            if (packageLinksContent) {
                downloadFileContent += "\n" + packageLinksContent;
            }
        }
        for (var sp = 0; sp < targetTwin[twin].length; sp++) {
            if (twin == 0 && isToPhysical) {
                if (targetTwin[twin][sp][0] != "SELF") {
                    darkOrWhite = "W" + tsScopesList[targetTwin[twin][sp][0]][0];
                    for (var rrc = 0; rrc < targetTwin[twin][sp][1].length; rrc++) {
                        var recordRequiredFile = new File (requiredFolder.fsName.replace(/\\/g, '/') + "/" + recipientsList[targetTwin[twin][sp][1][rrc]][0]);
                        if (!recordRequiredFile.exists)
                            writeFile (recordRequiredFile, "TS");
                    }
                }
                else {
                    darkOrWhite = "WSELF";
                }
                downloadFileContent = (isFinal ? "Final" : "Proof");
                downloadFileContent += ":" + darkOrWhite + ":" + extraPackaging + ":" + previousID + ":" + originalID;
                downloadFileContent += "\n" + (currentVersionContent? currentVersionContent : "New"); //1
                downloadFileContent += "\n" + pathTime; //2
                downloadFileContent += "\n" + abstractFsName; //3
                
                if (packageLinksContent) {
                    downloadFileContent += "\n" + packageLinksContent;
                }
            }
            
            for (var rc = 0; rc < targetTwin[twin][sp][1].length; rc++) {
                if (twin == 0 && isToPhysical) {
                    if (requestedID == recipientsList[targetTwin[twin][sp][1][rc]][0]) {
                        if (targetTwin[twin][sp][0] != "SELF") {
                            darkOrWhite = "L" + tsScopesList[targetTwin[twin][sp][0]][0];
                        }
                        else {
                            darkOrWhite = "LSELF";
                        }
                        downloadFileContent = (isFinal ? "Final" : "Proof");
                        downloadFileContent += ":" + darkOrWhite + ":" + extraPackaging + ":" + previousID + ":" + originalID;
                        downloadFileContent += "\n" + (currentVersionContent? currentVersionContent : "New"); //1
                        downloadFileContent += "\n" + pathTime; //2
                        downloadFileContent += "\n" + abstractFsName; //3
                        if (packageLinksContent) {
                            downloadFileContent += "\n" + packageLinksContent;
                        }
                    }
                }
                var messageTitle = "";
                if (thumbnailFile) {
                    messageTitle = versionDotID + "." + currentTime + ".jpg";
                    var cloudThumbnailFile = new File (recipientsList[targetTwin[twin][sp][1][rc]][1].fsName.replace(/\\/g, '/') + "/Thumbnails/" + messageTitle);
                    if (!cloudThumbnailFile.parent.exists)
                        cloudThumbnailFile.parent.create ();
                    thumbnailFile.copy (cloudThumbnailFile);
                }
                else {
                    messageTitle = versionDotID + "." + currentTime;
                }
                tsIsSendingDone = false;
                var sendingBoxesItem = new Array;
                sendingBoxesItem.push ("Download");
                sendingBoxesItem.push (messageTitle);
                sendingBoxesItem.push (downloadFileContent);
                recipientsList[targetTwin[twin][sp][1][rc]][8][1].push (sendingBoxesItem);
            }
        }
    }

    if (isFirstVersion) 
        return "CREATE_NEW";
    else
        return "CHECKEDIN";
}

function tsGetPath (fileID_Path_newID) {
    /**///$.writeln ($.line);
    fileID_Path_newID.push (null);
    fileID_Path_newID.push (null);
    var pathRecordFolder;
    var isDirected = false;
    var isFailed = false;
    var newID = fileID_Path_newID[0];
    var pathTimeFile = null;
    var pathTime = null;
    do {
        pathTimeFile = new File (tsDataPath + "/IDs" + newID + "/Path/Change Time");
        pathTime = readFile (pathTimeFile);
        if (!pathTime) {
            isFailed = true;
            fileID_Path_newID[1] = null;
            if (fileID_Path_newID[0] != newID)
                fileID_Path_newID[2] = newID;
        }
        else {
            pathRecordFile = new File (tsDataPath + "/IDs" + newID + "/Path/V/" + pathTime + "/Value");
            if (pathRecordFile.exists) {
                fileID_Path_newID[1] = readEncodedFile (pathRecordFile);
            }
            if (fileID_Path_newID[1]) {
                if (fileID_Path_newID[1][0] == ':') {
                    isDirected = true;
                    newID = fileID_Path_newID[1].slice (1);
                }
                else {
                    isDirected = false;
                    if (fileID_Path_newID[0] != newID)
                        fileID_Path_newID[2] = newID;
                }
            }
            else {
                isFailed = true;
                fileID_Path_newID[1] = null;
                if (fileID_Path_newID[0] != newID)
                    fileID_Path_newID[2] = newID;
            }
        }
    } while (isDirected && !isFailed);
    return pathTime;
}

function tsChangePath (fileID, newPath, newTime) {
    /**///$.writeln ($.line);
    var pathTimeFile = new File (tsDataPath + "/IDs" + fileID + "/Path/Change Time");
    if (!pathTimeFile.parent.exists)
        pathTimeFile.parent.create ();
    writeFile (pathTimeFile, newTime);
    var valueFile = new File (tsDataPath + "/IDs" + fileID + "/Path/V/" + newTime + "/Value");
    if (!valueFile.parent.exists)
        valueFile.parent.create ();
    writeEncodedFile (valueFile, newPath);
    return true;
}

function tsCheckOut (targetFile, isFinal) {
    /**///$.writeln ($.line);
    var workshopFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsWorkshopPath) + "/" + File.decode (targetFile.name).slice (6));
    var digitsFileIDTriple = getWorkshopVersionInfo (workshopFile, null);
    if (!digitsFileIDTriple) {
        return false;
    }
    var resultValueTwin = new Array;
    var versionDigits = File.decode (targetFile.name).slice (3, 5);
    var versionTime = readFile (File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/ver" + versionDigits + "/Modifying Time"));
    if (versionTime) {
        versionTime = parseInt (versionTime, 10);
    }
    else {
        versionTime = 0;
    }
    if (!targetFile || !workshopFile)
        return false;
    if (digitsFileIDTriple[0] != versionDigits) {
        var result = "NEW";
        /*if (digitsFileIDTriple[0] != "new")
            result = tsCheckIn (workshopFile, digitsFileIDTriple, false, true, true, true, false, false, null);*/
        var currentVersionFile = new File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/CV");
        if (!currentVersionFile.parent.exists)
            currentVersionFile.parent.create ();
        writeFile (currentVersionFile, versionDigits + (isFinal? ":F" : ":P"));
        if (result == "NEW") {
            resultValueTwin.push ("NEW");
            resultValueTwin.push (targetFile);
        }
        if (result == "ALREADY_CHECKEDIN") {
            resultValueTwin.push ("ALREADY_CHECKEDIN");
            resultValueTwin.push (digitsFileIDTriple[1]);
        }
        else {
            resultValueTwin.push ("CHECKEDIN");
            resultValueTwin.push (digitsFileIDTriple[1]);
        }
    }
    else {
        if (workshopFile.modified.getTime () == targetFile.modified.getTime ()) {
            if (isFinal) {
                var currentVersionFile = new File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/CV");
                if (!currentVersionFile.parent.exists)
                    currentVersionFile.parent.create ();
                writeFile (currentVersionFile, versionDigits + (isFinal? ":F" : ":P"));
            }
            resultValueTwin.push ("ALREADY_CHECKEDOUT");
            resultValueTwin.push (null);
            return resultValueTwin;
        }
        resultValueTwin.push ("CHECKEDOUT");
        resultValueTwin.push (null);
    }
    var tsVersionsToWorkshopItem = new Array; //to be add to tsVersionsToWorkshopList
    tsVersionsToWorkshopItem.push (0); //tsVersionsToWorkshopList[x][0] count
    tsVersionsToWorkshopItem.push (new Thumbnail (targetFile)); //tsVersionsToWorkshopList[x][1] file to be copied thumbnail
    tsVersionsToWorkshopItem.push (workshopFile); //tsVersionsToWorkshopList[x][2] destination file
    tsVersionsToWorkshopItem.push (null); //tsVersionsToWorkshopList[x][3] destination file length
    tsVersionsToWorkshopItem.push (digitsFileIDTriple[2]); //tsVersionsToWorkshopList[x][4] fileID
    tsVersionsToWorkshopItem.push (versionTime); //tsVersionsToWorkshopList[x][5] versionTime
    tsVersionsToWorkshopList.push (tsVersionsToWorkshopItem);
    if (isInDesignFile (targetFile)) {
        //copy pages
        var versionPagesFolder = new Folder (targetFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages).slice (0, -5));
        if (tsVersionsOutputZero == "ONLY_ZERO") {
            versionPagesFolder = Folder (versionPagesFolder.fsName.replace(/\\/g, '/').slice (0, versionPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver")) + "/ver00" + versionPagesFolder.fsName.replace(/\\/g, '/').slice (versionPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver") + 6));
        }
        var workingPagesFolder = new Folder (workshopFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsPagesPath + "/Workshop"));
        var oldPages = workingPagesFolder.getFiles (isUnhiddenFile);
        for (var o = 0; o < oldPages.length; o++) {
            oldPages[o].remove ();
        }
        var newPages = versionPagesFolder.getFiles (isUnhiddenFile);
        if (newPages.length > 0) {
            workingPagesFolder.create ();
            for (var n = 0; n < newPages.length; n++) {
                newPages[n].copy (workingPagesFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (newPages[n].name));
            }
        }
        //checkOutLinksRelations
        var docID = digitsFileIDTriple[2].replace (/\//g,"\.");
        docID = docID.slice (1);
        var linksReportFile = new File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/Workshop/LinksReport");
        var linksReportContent = readFile (linksReportFile);
        var newReportContent = tsUserID;
        if (linksReportContent) {
            var oldReportLines = linksReportContent.split ("\n");
            for (var c = 1; c < oldReportLines.length; c++) {
                var placingFile = new File (tsDataPath + "/IDs" + oldReportLines[c] + "/Workshop/Places/" + docID);
                placingFile.remove ();
            }
        }
        var versionLinksReportLines;
        if (versionTime) {
            var versionLinksReportContent = readFile (File (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/ver" + versionDigits + "/V/" + versionTime + "/LinksReport"));
            if (versionLinksReportContent) {
                versionLinksReportLines = versionLinksReportContent.split ("\n");
            }
        }
        if (versionLinksReportLines) {
            newReportContent = versionLinksReportLines[0];
            for (var e = 1; e < versionLinksReportLines.length; e++) {
                var linkID = versionLinksReportLines[e].slice (0, versionLinksReportLines[e].lastIndexOf ("/"));
                newReportContent += "\n" + linkID;
                var placesFile = new File (tsDataPath + "/IDs" + versionLinksReportLines[e] + "/Places/" + docID + ".ver" + versionDigits + "." + versionTime);
                var workingLinkRecordFile = new File (tsDataPath + "/IDs" + linkID + "/Workshop/Places/" + docID);
                if (!workingLinkRecordFile.parent.exists)
                    workingLinkRecordFile.parent.create ();
                placesFile.copy (workingLinkRecordFile);
            }
        }
        if (!linksReportFile.parent.exists)
            linksReportFile.parent.create ();
        writeFile (linksReportFile, newReportContent);
    }
    return resultValueTwin;
}

function getWorkshopVersionInfo (targetFile, fileID) {
    /**///$.writeln ($.line);
    var versionDigits;
    var versionFile;
    if (!fileID)
        fileID = tsGetID (targetFile);
    if (fileID) {
        var currentVersionFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
        var recordContent = readFile (currentVersionFile);
        if (recordContent) {
            versionDigits = recordContent.split (":")[0];
            versionFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + versionDigits + " " + File.decode (targetFile.name));
            var digitsFileIDTriple = new Array;
            digitsFileIDTriple.push (versionDigits);
            digitsFileIDTriple.push (versionFile);
            digitsFileIDTriple.push (fileID);
            return digitsFileIDTriple;
        }
        else {
            versionDigits = "01";
            versionFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + versionDigits + " " + File.decode (targetFile.name));
            var digitsFileIDTriple = new Array;
            digitsFileIDTriple.push ("new");
            digitsFileIDTriple.push (versionFile);
            digitsFileIDTriple.push (fileID);
            return digitsFileIDTriple;
        }
    }
    return null;
}

function tsImportFile (sourceFile, destinationFolder, isToBeLocked, importedLinkAndDocID, isDuplicate, conflictOption) {
    /**///$.writeln ($.line);
    if (!sourceFile.exists) {
        return [""];
    }
    sourceFile.readonly = false;
    var actualDestination;
    var destinationFile;
    var fileID = tsGetID (sourceFile);
    if (fileID) {
        var fileID_Path_newID = [fileID];
        tsGetPath (fileID_Path_newID);
        if (fileID_Path_newID[1]) {
            var destinationExtention = File.decode (sourceFile.name).lastIndexOf (".") == -1? "" : File.decode (sourceFile.name).slice (File.decode (sourceFile.name).lastIndexOf ("."));
            var sourceExtention = fileID_Path_newID[1].lastIndexOf (".") == -1? "" : fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("."));
            if (destinationExtention == sourceExtention) {
                destinationFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                actualDestination = destinationFile.parent;
            }
        }
    }
    if (actualDestination) {
        if (actualDestination.fsName.replace(/\\/g, '/') != destinationFolder.fsName.replace(/\\/g, '/'))
            isToBeLocked = false;
    }
    else {
        actualDestination = destinationFolder;
        destinationFile = new File (actualDestination.fsName.replace(/\\/g, '/') + "/" + File.decode (sourceFile.name));
    }
    if (!actualDestination.exists) {
        actualDestination.create ();
    }
    if (isToBeLocked) {
        var copyingLockFile = new File (actualDestination.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
        writeFile (copyingLockFile, tsClientID);
    }
    if (File.decode (destinationFile.name).search(/ver\d\d /i) == 0) {
        destinationFile = new File (destinationFile.parent.fsName.replace(/\\/g, '/') + "/" + File.decode (destinationFile.name).slice (6));
    }
    var newPathIDList = null;
    var isLabelPlaced = (!destinationFile.exists);
    newPathIDList = tsChangeFile (sourceFile, destinationFile, isDuplicate, conflictOption, true);
    if (!fileID) {
        if (newPathIDList) {
            var traceFile = new File (tsDataPath + "/Traces/Outside" + sourceFile.fsName.replace(/\\/g, '/'));
            if (!traceFile.parent.exists)
                traceFile.parent.create ();
            writeFile (traceFile, "TS_ID:" + newPathIDList[1]);
        }
    }
    if (newPathIDList) {
        if (importedLinkAndDocID) {
            if (newPathIDList.length > 0) {
                newPathIDList[0] = newPathIDList[0].replace (tsWorkshopPath, "");
            }
            newPathIDList.push (importedLinkAndDocID);
            if (isLabelPlaced) {
                var fileThumbnail = new Thumbnail (new File (newPathIDList[0]));
                fileThumbnail.label = "Placed";
            }
        }
    }
    else {
        newPathIDList = [""];
    }
    return newPathIDList;
}

function tsImportFolder (sourceFolder, destinationFolder, conflictOption) {
    /**///$.writeln ($.line);
    if (!sourceFolder.exists)
        return false;
    var allFiles = sourceFolder.getFiles (isAcceptedFile);
    for (var c = 0; c < allFiles.length; c++) {
        tsImportFile (allFiles[c], destinationFolder, true, null, false, conflictOption);
    }
    var allFolder = sourceFolder.getFiles (isAcceptedFolder);
    for (var c = 0; c < allFolder.length; c++) {
        tsImportFolder (allFolder[c], Folder (destinationFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (allFolder[c].name)), conflictOption);
    }
    var copyingLockFile = new File (destinationFolder.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
    copyingLockFile.remove ();
    return true;
}

function checkInSelection (isFinal) {
    /**///$.writeln ($.line);
    var PDFExportingFile = new File (tsDataPath + "/No PDF Exporting");
    tsIsStartPDFExporting = !PDFExportingFile.exists;
    var allFiles = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        getToBeCheckedFiles (app.document.selections[c].spec, allFiles);
    }
    for (var a = 0; a < allFiles.length; a++) {
        var digitsFileIDTriple = getWorkshopVersionInfo (allFiles[a], null);
        if (digitsFileIDTriple) {
            var checkInTest = tsIsNeedCheckIn (allFiles[a], digitsFileIDTriple[2]);
            if (!checkInTest && digitsFileIDTriple[1].exists) {
                if (allFiles.length == 1) {
                    alert ("The file is already checked in.");
                }  
                continue;
            }
            if (isInDesignFile (allFiles[a])) {
                if (!tsIsIgnoreVersionOwner && checkInTest != "new") {
                    var modifierFile = new Folder (tsDataPath + "/IDs" + digitsFileIDTriple[2] + "/ver" + digitsFileIDTriple[0] + "/V/" + checkInTest + "/Modifier");
                    if (modifierFile.exists) {
                        //jump to new version
                        var maxNumber = 0;
                        var allVersions = Folder (tsDataPath + "/IDs" + digitsFileIDTriple[2]).getFiles ("ver??");
                        if (allVersions.length > 0) {
                            maxNumber = parseInt (File.decode (allVersions[allVersions.length-1].name).slice (3), 10);
                        }
                        maxNumber += 1;
                        digitsFileIDTriple[0] = maxNumber < 10? "0" + maxNumber : "" + maxNumber;
                    }   
                }
                var PDFPreviewIndex = -1;
                for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                    if (allFiles[a].fsName.replace(/\\/g, '/') == tsAlertPDFPreviewList[ppl][0]) {
                        PDFPreviewIndex = ppl;
                        break;
                    }
                }
                if (PDFPreviewIndex == -1) {
                    tsAlertPDFPreviewList.push ([
                        allFiles[a].fsName.replace(/\\/g, '/'), //The document full path
                        digitsFileIDTriple[2], //fileID
                        digitsFileIDTriple[0], //versionNumber
                        isFinal, //isWithFinal
                        0, //count down
                        0 //skips count
                    ]);
                }
            }
            else {
                tsCheckIn (allFiles[a], digitsFileIDTriple, isFinal, true, true, true, allFiles.length == 1? true : false, true, null);
            }
        }
    }
}

function createNewVersionForSelection (result) {
    /**///$.writeln ($.line);
    var PDFExportingFile = new File (tsDataPath + "/No PDF Exporting");
    tsIsStartPDFExporting = !PDFExportingFile.exists;
        
    var selectionArray = new Array;
    var fileIDs = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        var fileID = tsGetID (app.document.selections[c].spec);
        if (fileID) {
            fileIDs.push (fileID);
            selectionArray.push (app.document.selections[c]);
        }
    }
    var versionsFolder = new Folder (app.document.thumbnail.spec.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath));
    if (!versionsFolder.exists)
        versionsFolder.create ();
    var lastNumbers = new Array;
    var maxNumber = 0;
    for (var i = 0; i < fileIDs.length; i++) {
        lastNumbers.push (0);
        var IDFolder = new Folder (tsDataPath + "/IDs" + fileIDs[i]);
        var allVersions = IDFolder.getFiles ("ver??");
        if (allVersions.length > 0) {
            lastNumbers[i] = parseInt (File.decode (allVersions[allVersions.length-1].name).slice (3), 10);
            if (lastNumbers[i] > maxNumber)
                maxNumber = lastNumbers[i];
        }
    }
    maxNumber += 1;
    if (maxNumber < 10)
        maxNumber = "0" + maxNumber.toString ();
    else
        maxNumber = maxNumber.toString ();
    for (var i = 0; i < selectionArray.length; i++) {
        var filePart = new File(versionsFolder.fsName.replace(/\\/g, '/') + "/ver" + maxNumber + " " + File.decode (selectionArray[i].spec.name));
        var digitsFileIDTriple = new Array;
        digitsFileIDTriple.push (maxNumber);
        digitsFileIDTriple.push (filePart);
        digitsFileIDTriple.push (fileIDs[i]);
        if (isInDesignFile (selectionArray[i].spec) && !result) {
            var PDFPreviewIndex = -1;
            for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                if (selectionArray[i].spec.fsName.replace(/\\/g, '/') == tsAlertPDFPreviewList[ppl][0]) {
                    PDFPreviewIndex = ppl;
                    break;
                }
            }
            if (PDFPreviewIndex == -1) {
                tsAlertPDFPreviewList.push ([
                    selectionArray[i].spec.fsName.replace(/\\/g, '/'), //The document full path
                    digitsFileIDTriple[2], //fileID
                    digitsFileIDTriple[0], //versionNumber
                    false, //isWithFinal
                    0, //count down
                    0 //skips count
                ]);
            }
        }
        else {
            tsCheckIn (selectionArray[i].spec, digitsFileIDTriple, false, !result, !result, !result, selectionArray.length == 1? true : false, true, null);
        }
    }
    if (result) {
        for (var lc = 0; lc < selectionArray.length; lc++) {
            if (selectionArray[lc].label = "") {
                selectionArray[lc].label = "Need To Be Checked In";
                selectionArray[lc].refresh ();
            }
        }
        if (selectionArray.length == 1) {
            selectionArray[0].open ();
        }
    }
}

function alertPDFPreview (targetFile, fileID, versionNumber, isWithFinal) {
    /**///$.writeln ($.line);
    //remove old version pdf file
    File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPDFPath) + "/ver" + versionNumber + " " + File.decode (targetFile.name).slice (0, -5) + ".pdf").remove (); 
    var finalCharMark = isWithFinal? "F" : "P";
    finalCharMark = "P"; //ommit this line to export final pdf also
    var fileDotID = fileID.replace (/\//g,"\.");
    fileDotID = fileDotID.slice (1);
    alertFile = new File (tsDataPath + "/Messages/PDFPreview/" + finalCharMark + "." + fileDotID + "." + versionNumber);
    if (!alertFile.parent.exists)
        alertFile.parent.create ();
    //switch to InDesign
    var nowTime = new Date().getTime();
    if (nowTime - lastSwitchingTime > 5000) {
        lastSwitchingTime = nowTime;
        if (tsIsSwitchWithInDesign) {
            var targetInDesign = BridgeTalk.getSpecifier ("indesign");
            if (targetInDesign && targetInDesign.appStatus != "not installed") {
                var talkInDesign = new BridgeTalk;
                talkInDesign.target = targetInDesign;
                talkInDesign.body = "app.activate ();";
                talkInDesign.send ();
            }
        }
    }
    writeFile (alertFile, nowTime);
}

function tsInitialize () {
    /**///$.writeln ($.line);
    var isTSFirstTime = false;
    var rootFolderPathFile = new File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Path for " + tsClientID);
    tsRootFolderPath = readEncodedFile (rootFolderPathFile);
    var rootFolderPathFileJustCreated = false;
    var cloudLocationsFolder = null;
    if (!tsRootFolderPath) {
        if (tsInitializeAlerts) {
            return false;
        }
        rootFolderPathFileJustCreated = true;
        if (rootFolderPathFile.exists) {
            /*Error*/alert ("Tree Shade Couldn't Read Root Folder Path File.");
        }
        var rootLocation = Folder.myDocuments.selectDlg ("Welcome in Tree Shade! \nPlease create and select root folder for Tree Shade.");
        if (!rootLocation) {
            tsInitializeAlerts = true;
            okNowYouCanQuit = true;
            return false;
        }
            
        tsRootFolderPath = rootLocation.fsName.replace(/\\/g, '/');
        writeEncodedFile (rootFolderPathFile, tsRootFolderPath);
    }
    else {
        var nowTime = new Date().getTime();
        if (nowTime - rootFolderPathFile.modified.getTime () < 60000) {
            //isToInsertInDesignLabel = true;
        }
    }

    cloudLocationsFolder = Folder (tsRootFolderPath + "/Workflow/Cloud Locations");
    tsSettingFile = new File (tsRootFolderPath + "/Settings/" + tsClientID + " Initial Parameters");
    tsUserSettingFile = new File (tsRootFolderPath + "/Settings/" + tsClientID + " Preferences");
    if (!tsSettingFile.exists) {
        if (rootFolderPathFileJustCreated) {
            isTSFirstTime = true;
        }
        tsWorkshopPath = tsRootFolderPath + "/Workshop";
        tsPagesPath = tsRootFolderPath + "/Pages"; 
        tsDataPath = tsRootFolderPath + "/.Data";
        var versionsOutputToWorkshopFile = new File (tsDataPath + "/Versions Output to Workshop Mark");
        if (versionsOutputToWorkshopFile.exists) {
            tsVersionsOutputZero = readFile (versionsOutputToWorkshopFile);
            tsIsVersionsOutputToWorkshop = true;
            tsTreeShadeThumb = "/";
        }
        tsVersionsPath = tsRootFolderPath + "/Versions";
        tsFinalPDFPath = tsRootFolderPath + "/Final PDF";
        if (tsIsVersionsOutputToWorkshop) {
            tsVersionsPDFPath = tsWorkshopPath;
            tsVersionsPages = tsWorkshopPath;
        }
        else {
            tsVersionsPDFPath = tsRootFolderPath + "/Versions PDFs";
            tsVersionsPages = tsPagesPath + "/Versions";
        }
        var switchWithInDesignFile = new File (tsDataPath + "/Switch With InDesign Mark");
        if (switchWithInDesignFile.exists) {
            tsIsSwitchWithInDesign = true;
        }
        var ignoreVersionOwnerFile = new File (tsDataPath + "/Ignore Version Owner Mark");
        if (ignoreVersionOwnerFile.exists) {
            tsIsIgnoreVersionOwner = true;
        }
        tsTrashPath = tsRootFolderPath + "/Trash";
        
        Folder (tsWorkshopPath).create ();
        Folder (tsPagesPath).create ();
        Folder (tsDataPath).create ();
        var toUpdateFolder = Folder (tsDataPath + "/Messages/To Update");
        toUpdateFolder.create ();
        Folder (tsVersionsPath).create ();
        Folder (tsFinalPDFPath).create ();
        Folder (tsVersionsPDFPath).create ();
        Folder (tsTrashPath).create ();
        var rootCloudLocationMarkerFile = File (tsRootFolderPath + "/Root TSCL.txt");
        if (!rootCloudLocationMarkerFile.exists)
            writeFile (rootCloudLocationMarkerFile, "The parent folder for this file is a Tree Shade Cloud Location.");
        if (!cloudLocationsFolder.exists) {
            cloudLocationsFolder.create ();
        }
        var cloudLocationsRootShortcut = new File (cloudLocationsFolder.fsName.replace(/\\/g, '/') + "/Root");
        cloudLocationsRootShortcut.createAlias (rootCloudLocationMarkerFile);

        var settingContent = tsWorkshopPath + "\n" + tsPagesPath + "\n" + tsDataPath + "\n" + tsVersionsPath + "\n" + tsFinalPDFPath + "\n" + tsVersionsPDFPath + "\n" + tsTrashPath;
        if (!tsSettingFile.parent.exists)
            tsSettingFile.parent.create ();
        writeEncodedFile (tsSettingFile, settingContent);
    }
    else {
        var settingFileLines = readEncodedFile (tsSettingFile).split ("\n");
        if (settingFileLines.length == 7) {
            tsWorkshopPath = settingFileLines[0];
            tsPagesPath = settingFileLines[1];
            tsDataPath = settingFileLines[2];
            var versionsOutputToWorkshopFile = new File (tsDataPath + "/Versions Output to Workshop Mark");
            if (versionsOutputToWorkshopFile.exists) {
                tsVersionsOutputZero = readFile (versionsOutputToWorkshopFile);
                tsIsVersionsOutputToWorkshop = true;
                tsTreeShadeThumb = "/";
            }
            tsVersionsPath = settingFileLines[3];
            tsFinalPDFPath = settingFileLines[4];
            if (tsIsVersionsOutputToWorkshop) {
                tsVersionsPDFPath = tsWorkshopPath;
                tsVersionsPages = tsWorkshopPath;
            }
            else {
                tsVersionsPDFPath = settingFileLines[5];
                tsVersionsPages = tsPagesPath + "/Versions";
            }
            var switchWithInDesignFile = new File (tsDataPath + "/Switch With InDesign Mark");
            if (switchWithInDesignFile.exists) {
                tsIsSwitchWithInDesign = true;
            }
            var ignoreVersionOwnerFile = new File (tsDataPath + "/Ignore Version Owner Mark");
            if (ignoreVersionOwnerFile.exists) {
                tsIsIgnoreVersionOwner = true;
            }
            tsTrashPath = settingFileLines[6];
        }
        else {
            try { 
                tsSettingFile.remove ();  
            }
            catch (e) {
                if (!tsInitializeAlerts) {
                    alert ("The setting file for Tree Shade extension has been spoiled, but couldn't be deleted.");
                    tsInitializeAlerts = true;
                }
                okNowYouCanQuit = true;
                return false;
            }
            if (!tsInitializeAlerts) {
                alert ("The setting file for Tree Shade extension has been spoiled.");
                tsInitializeAlerts = true;
            }
            okNowYouCanQuit = true;
            return false;
        }
    }

    if (tsDataPath) {
        var respondToManuallyDeletedFile = new File (tsDataPath + "/Respond To Manually Deleted Mark");
        if (respondToManuallyDeletedFile.exists) {
            tsIsRespondToManuallyDeleted = true;
        }
        else {
            tsIsRespondToManuallyDeleted = false;
        }
    }

    var targetInDesign = BridgeTalk.getSpecifier ("indesign");
    if (targetInDesign && targetInDesign.appStatus != "not installed") {
        var talkInDesign = new BridgeTalk;
        talkInDesign.target = targetInDesign;
        var versionsOutputVal = "";
        if (tsIsVersionsOutputToWorkshop) {
            versionsOutputVal = "TRUE";
        }
        var switchWithInDesignVal = "";
        if (tsIsSwitchWithInDesign) {
            switchWithInDesignVal = "TRUE";
        }
        talkInDesign.body = "app.insertLabel ('Tree Shade Path for " + tsClientID + "', '" + tsRootFolderPath + "');";
        talkInDesign.body += "\n" + "app.insertLabel ('TS_VERSIONS_OUTPUT_TO_WORKSHOP', '" + versionsOutputVal + "');";
        talkInDesign.body += "\n" + "app.insertLabel ('TS_SWITCH_WITH_INDESIGN', '" + switchWithInDesignVal + "');";
        talkInDesign.send ();
    }

    if (rootFolderPathFileJustCreated) {
        var textEditorFile = new File (tsDataPath + "/Text Editor.htm");
        File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Text Editor.htm").copy (textEditorFile);
        
        var messagesSoundFile = new File (tsRootFolderPath + "/Workflow/Messages/^ Open me to browse new messages.mp3");
        messagesSoundFile.parent.create ();
        File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Messages Alarm Sound.mp3").copy (messagesSoundFile);
        
        app.preferences.Label1 = "Modified By Another Collaborator";
        app.preferences.Label2 = "Need To Be Checked In";
        app.preferences.Label3 = "Placed";
        app.preferences.Label4 = "Current";
        app.preferences.Label5 = "Final";
    }

    //Copying Initial files
    var interfaceMainSourceFolder = Folder (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Initial");
    var filesListWithSubs = new Array;
    retrieveFilesListWithSubs (interfaceMainSourceFolder, filesListWithSubs, "", "");
    for (var flws = 0; flws < filesListWithSubs.length; flws++) {
        var theDesFullPath = tsRootFolderPath + "/Workshop/Initial/";
        if (filesListWithSubs[flws][1] != "") {
            theDesFullPath += filesListWithSubs[flws][1] + "/";
        }
        theDesFullPath += File.decode (filesListWithSubs[flws][0].name);
        tsChangeFile (filesListWithSubs[flws][0], File (theDesFullPath), true, 1, false);
    }

    //Copying node.js Interface Files
    var isToCopyInterfaceMain = false;
    var isToCopyInterfaceForm = false;
    var isToCopyInterfaceIcon = false;
    var interfaceMainDesFile = File (tsRootFolderPath + "/main.js");
    var interfaceMainDesMark = File (tsRootFolderPath + "/Interface/Mark/main.txt");
    var interfaceMainSourceFile = File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Interface Main.html");
    var interfaceFormDesFile = File (tsRootFolderPath + "/Interface/http-form.html");
    var interfaceFormDesMark = File (tsRootFolderPath + "/Interface/Mark/http-form.txt");
    var interfaceFormSourceFile = File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Interface Form.html");
    var interfaceIconDesFile = File (tsRootFolderPath + "/Interface/favicon.png");
    var interfaceIconDesMark = File (tsRootFolderPath + "/Interface/Mark/favicon.txt");
    var interfaceIconSourceFile = File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Interface Icon.png");
    if (interfaceMainSourceFile.exists) {
        if (!interfaceMainDesFile.exists) {
            interfaceMainDesFile.parent.create ();
            isToCopyInterfaceMain = true;
        }
        else if (interfaceMainDesMark.exists && (interfaceMainDesFile.modified.getTime () - interfaceMainDesMark.modified.getTime() < 1000)) {
            if (interfaceMainSourceFile.modified.getTime () > interfaceMainDesFile.modified.getTime ()) {
                interfaceMainDesFile.parent.create ();
                isToCopyInterfaceMain = true;
            }
        }
        if (isToCopyInterfaceMain) {
            interfaceMainSourceFile.copy (interfaceMainDesFile);
            interfaceMainDesMark.parent.create ();
            writeFile (interfaceMainDesMark, new Date().getTime());
        }
    }
    if (interfaceFormSourceFile.exists) {
        if (!interfaceFormDesFile.exists) {
            interfaceFormDesFile.parent.create ();
            isToCopyInterfaceForm = true;
        }
        else if (interfaceFormDesMark.exists && (interfaceFormDesFile.modified.getTime () - interfaceFormDesMark.modified.getTime() < 1000)) {
            if (interfaceFormSourceFile.modified.getTime () > interfaceFormDesFile.modified.getTime ()) {
                interfaceFormDesFile.parent.create ();
                isToCopyInterfaceForm = true;
            }
        }
        if (isToCopyInterfaceForm) {
            interfaceFormSourceFile.copy (interfaceFormDesFile);
            interfaceFormDesMark.parent.create ();
            writeFile (interfaceFormDesMark, new Date().getTime());
        }
    }
    if (interfaceIconSourceFile.exists) {
        if (!interfaceIconDesFile.exists) {
            interfaceIconDesFile.parent.create ();
            isToCopyInterfaceIcon = true;
        }
        else if (interfaceIconDesMark.exists && (interfaceIconDesFile.modified.getTime () - interfaceIconDesMark.modified.getTime() < 1000)) {
            if (interfaceIconSourceFile.modified.getTime () > interfaceIconDesFile.modified.getTime ()) {
                interfaceIconDesFile.parent.create ();
                isToCopyInterfaceIcon = true;
            }
        }
        if (isToCopyInterfaceIcon) {
            interfaceIconSourceFile.copy (interfaceIconDesFile);
            interfaceIconDesMark.parent.create ();
            writeFile (interfaceIconDesMark, new Date().getTime());
        }
    }

    var prefixFile = new File (tsDataPath + "/IDsPrefix");
    if (!prefixFile.exists) {
        tsPrefixID = "00";
        writeFile (prefixFile, tsPrefixID);
    }
    else {
        tsPrefixID = readFile (prefixFile);
    }

    tsUserImage = Folder (tsRootFolderPath).getFiles ("I'm *.jpg");
    if (tsUserImage.length == 1) {
        tsUserImage = tsUserImage[0];
        var userInfo = tsGetUserInfo (tsUserImage);
        if (!userInfo) {
            if (!tsInitializeAlerts) {
                alert ("Tree Shade: Could't read the Metadata User Info from his Image:\n" + tsUserImage.fsName.replace(/\\/g, '/'));
                tsInitializeAlerts = true;
            }
            okNowYouCanQuit = true;
            return false;
        }
        tsUserID = userInfo[0];
        tsUserName = userInfo[1];
        tsUserEmail = userInfo[2];
        var keyDateValue = userInfo[3].split (":");
        tsUserKeyDate = parseInt (keyDateValue[0], 10);
        if (keyDateValue.length > 1)
            tsUserKeyValue = keyDateValue[1];
    }
    else if (tsUserImage.length > 1) {
        if (!tsInitializeAlerts) {
            alert ("Tree Shade: There is more than one of user Images in local data folder.");
            tsInitializeAlerts = true;
        }
        okNowYouCanQuit = true;
        return false;
    }
    else {
        if (Folder (tsRootFolderPath).exists) {
            if (tsUserSettingFile.exists) {
                if (!tsInitializeAlerts) {
                    alert ("Tree Shade: The user Image is missed!");
                    tsInitializeAlerts = true;
                }
                okNowYouCanQuit = true;
                return false;
            }
        }
    }
    if (!tsUserID) {
        tsUserID = TSProduceID ();
        tsUserName = prompt ("User Name:", tsClientID);
        tsUserEmail = prompt ("User Email:", "");
        tsUserImage = new File (tsRootFolderPath + "/I'm " + tsUserName + ".jpg");
        File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/User Image Template.jpg").copy (tsUserImage);
        if (!tsUpdateUserInfo (tsUserImage, [tsUserID, tsUserName, tsUserEmail, new Date().getTime()])) {
            if (!tsInitializeAlerts) {
                alert ("Tree Shade: Could't write to the Metadata of User Image:\n" + tsUserImage.fsName.replace(/\\/g, '/'));
                tsInitializeAlerts = true;
            }
            okNowYouCanQuit = true;
            return false;
        }
    }
    if (!tsUserSettingFile.exists) {
        var userSettingContent = "Scanning" + "\n" + tsUserID + "\n" + "BBB" + "\n" + "CCC" + "\n" + tsChangeTemplate + "\n" + "false";
        if (!tsSettingFile.parent.exists) {
            try {
                tsSettingFile.parent.create();
            }
            catch (e) {
                if (!tsInitializeAlerts) {
                    alert ("Tree Shade\nCouldn't create the Initial Parameters folder.");
                    tsInitializeAlerts = true;
                }
                okNowYouCanQuit = true;
                return false;
            }
        }
        writeEncodedFile (tsUserSettingFile, userSettingContent); 
    }
    else {
        var userSettingFileLines = readEncodedFile (tsUserSettingFile).split ("\n");
        if (userSettingFileLines.length == 6) {
            tsUserTask = userSettingFileLines[0];
            //tsUserID = userSettingFileLines[1];
            tsRecentNewFromPath = userSettingFileLines[2];
            tsTemplatesPath = userSettingFileLines[3];
            tsChangeTemplate = userSettingFileLines[4];
            tsIsStaticIDs = (userSettingFileLines[5] == "true")? true : false;
        }
        else {
            try { tsUserSettingFile.remove ();  }
            catch (e) {
                if (!tsInitializeAlerts) {
                    alert ("The user setting file for Tree Shade extension has spoiled, but couldn't be deleted.");
                    tsInitializeAlerts = true;
                }
                okNowYouCanQuit = true;
                return false;
            }
        }
    }
    
    //tsCloudPaths
    //tsCloudPaths[x][0] The Folder Path
    tsSetCloudPaths ();
        
    var PDFExportingFile = new File (tsDataPath + "/No PDF Exporting");
    tsIsStartPDFExporting = !PDFExportingFile.exists;

    if (!tsInitializeDone) {
        CSExtensionList.push (".psd");
        CSExtensionList.push (".png");
        CSExtensionList.push (".jpg");
        CSExtensionList.push (".jpeg");
        CSExtensionList.push (".tif");
        CSExtensionList.push (".tiff");
        CSExtensionList.push (".ai");
        CSExtensionList.push (".eps");
        CSExtensionList.push (".pdf");
        CSExtensionList.push (".indd");
        CSExtensionList.push (".indt");
        CSExtensionList.push (".ait");
        CSExtensionList.push (".swf");
        CSExtensionList.push (".psb");
        CSExtensionList.push (".mov");
        CSExtensionList.push (".mp4");
        CSExtensionList.push (".aep");
        CSExtensionList.push (".svg");
        createPlugInMenu (false);
        createContextMenu ();
    }
    var tsChangeShortcutsFile = new File (tsDataPath + "/Change Shortcuts.txt");
    tsChangeShortcutsFile.encoding = "UTF8";
    if (tsChangeShortcutsFile.exists) {
        tsChangeShortcuts = readFile (tsChangeShortcutsFile);
        tsChangeShortcuts = tsChangeShortcuts.split ("\n");
    }
    else {
        tsChangeShortcuts = ["c Copy Picked Files and Folders Here: .$/<L><D>",
                             "m Move Picked Files and Folders Here: .$/<L>",
                             "b Move Back: ..$/<L>"
                            ];
    }
    okNowYouCanQuit = false;
    tsInitializeDone = true;
    return true;
}

function tsSetCloudPaths () {
    tsCloudPaths = new Array;
    var cloudLocationsFolder = Folder (tsRootFolderPath + "/Workflow/Cloud Locations");
    var allShortcuts = cloudLocationsFolder.getFiles (isUnhiddenShortcutFile);
    for (var asc = 0; asc < allShortcuts.length; asc++) {
        var actualFile = allShortcuts[asc].resolve ();
        if (actualFile) {
            if (actualFile.exists) {
                var cloudLocationRepeated = false;
                for (var cps = 0; cps < tsCloudPaths.length; cps++) {
                    if (tsCloudPaths[cps][0] == actualFile.parent.fsName.replace(/\\/g, '/')) {
                        cloudLocationRepeated = true;
                        break;
                    }
                }
                if (!cloudLocationRepeated) {
                    var tsCloudPathsItem = new Array;
                    tsCloudPathsItem.push (actualFile.parent.fsName.replace(/\\/g, '/')); //The Folder Path
                    tsCloudPaths.push (tsCloudPathsItem);
                }
                else {
                    actualFile.remove ();
                    allShortcuts[asc].remove ();
                }
            }
        }
    }
    return true;
}

function initializeAmbushingTask () {
    /**///$.writeln ($.line);
    var labourFile = new File (tsDataPath + "/Scanning/Labour");
    var nowTime = new Date().getTime();
    if (labourFile.exists) {
        if (true) { //nowTime - labourFile.modified.getTime () > 600000
            //alert ("Last scanning client shut down incorrectly.");
            labourFile.remove ();
            var vacancyFile = new File (tsDataPath + "/Scanning/Vacancy");
            writeFile (vacancyFile, tsClientID);
        }
    }
    else {
        var vacancyFile = new File (tsDataPath + "/Scanning/Vacancy");
        if (!vacancyFile.parent.exists)
            vacancyFile.parent.create ();
        writeFile (vacancyFile, tsClientID);
    }
}

function solveSourcePath (targetFile, relationPath) {
    relationPath = tsSolveDateTime (relationPath);
    if (relationPath.indexOf ("/") == -1) {
        relationPath = "./" + relationPath;
    }
    if (relationPath.indexOf ("//") == 0) {
        relationPath = relationPath.replace("//", tsWorkshopPath + "/");
    }
    var prefixDotsIndex = relationPath.search (/\.+\//);
    while (prefixDotsIndex != -1) {
        var deepCount = 2;
        var dotsFirstMatch = relationPath.match (/\.+\//)[0];
        var relativeFile = targetFile;
        var targetParent = relativeFile.parent;
        for (var pml = 0; pml < dotsFirstMatch.length - deepCount; pml++) {
            if (!targetParent.parent) {
                break;
            }
            targetParent = targetParent.parent;
        }
        relationPath = relationPath.replace (dotsFirstMatch, targetParent.fsName.replace(/\\/g, '/') + "/");
        prefixDotsIndex = relationPath.search (/\.+\//);
    }
    var nameDotsIndex = relationPath.search (/<\.+>/);
    while (nameDotsIndex != -1) {
        var deepCount = 3;
        var dotsFirstMatch = relationPath.match (/<\.+>/)[0];
        var relativeFile = targetFile;
        var targetParent = relativeFile.parent;
        for (var pml = 0; pml < dotsFirstMatch.length - deepCount; pml++) {
            if (!targetParent.parent) {
                break;
            }
            targetParent = targetParent.parent;
        }
        var parentFolderName = "";
        if (targetParent && targetParent.name) {
            parentFolderName = File.decode (targetParent.name);
        }
        relationPath = relationPath.replace (dotsFirstMatch, parentFolderName);
        nameDotsIndex = relationPath.search (/<\.+>/);
    }
    if (relationPath.search (/<AP>/i) != -1) {
        var fileAP = targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
        if (fileAP == "") {
            relationPath = relationPath.replace(/\/?<AP>/gi, fileAP);
        }
        else {
            relationPath = relationPath.replace(/<AP>/gi, fileAP);
        }
    }
    var apDotIndex = relationPath.search (/<AP.+>/i);
    while (apDotIndex != -1) {
        var endIndex = -1;
        var apDotFirstMatch = relationPath.match (/<AP.+>/i)[0];
        var relativeFile = targetFile;
        var fileAPDot = relativeFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
        var apDotSep = apDotFirstMatch.slice (3, endIndex);
        fileAPDot = fileAPDot.replace (/\//g, apDotSep);
        relationPath = relationPath.replace (/<AP.+>/i, fileAPDot);
        apDotIndex = relationPath.search (/<AP.+>/i);
    }
    if (relationPath.search (/<FD>/i) != -1) {
        var targetName = File.decode (targetFile.name);
        targetName = tsGetDisplayName (targetName);
        if (targetName == null) targetName = '';
        relationPath = relationPath.replace(/<FD>/gi, targetName);
    }
    if (relationPath.search (/<FN>/i) != -1) {
        var targetName = File.decode (targetFile.name);
        if (targetName.indexOf (".") > 0)
            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
        relationPath = relationPath.replace(/<FN>/gi, targetName);
    }
    if (relationPath.search (/<FNS>/i) != -1) {
        var targetName = File.decode (targetFile.name);
        if (targetName.indexOf (".") > 0)
            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
        if (targetName[0] == '[') {
            var suggestName = targetName;
            if (suggestName.indexOf ("]") != -1)
                suggestName = suggestName.slice (suggestName.indexOf ("]") + 1);
            while (suggestName[0] == ' ')
                suggestName = suggestName.slice (1);
            if (suggestName != "") {
                targetName = suggestName;
            }
        }
        else if (targetName[0] == '-') {
            var suggestName = targetName;
            suggestName = suggestName.slice (1);
            while (suggestName[0] == ' ')
                suggestName = suggestName.slice (1);
            if (suggestName != "") {
                targetName = suggestName;
            }
        }
        relationPath = relationPath.replace(/<FNS>/gi, targetName);
    }
    var fnDotIndex = relationPath.search (/<FN.+>/i);
    while (fnDotIndex != -1) {
        var endIndex = -1;
        var fnDotFirstMatch = relationPath.match (/<FN.+>/i)[0];
        var relativeFile = targetFile;
        var targetName = File.decode (relativeFile.name);
        if (targetName.indexOf (".") > 0)
            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
        if (targetName[0] == '[') {
            if (targetName.indexOf ("]") != -1)
            targetName = targetName.slice (targetName.indexOf ("]") + 1);
            while (targetName[0] == ' ')
                targetName = targetName.slice (1);
        }
        if (targetName != "") {
            var fnDotSep = fnDotFirstMatch.slice (3, endIndex);
            targetName = targetName.split (fnDotSep).join ("/");
            relationPath = relationPath.replace (/<FN.+>/i, targetName);
        }
        else {
            relationPath = relationPath.replace (/\/?<FN.+>/i, targetName);
        }
        fnDotIndex = relationPath.search (/<FN.+>/i);
    }
    if (relationPath.search (/<FC>/i) != -1) {
        var autoCheckInContent = readFile (targetFile);
        if (autoCheckInContent) {
            relationPath = relationPath.replace(/<FC>/gi, autoCheckInContent);
        }
    }
    if (relationPath.search (/<FF>/i) != -1) {
        var firstFolderName = null;
        var toLookInFolder = Folder (relationPath.slice (0, relationPath.search (/\/<FF>/i)));
        if (toLookInFolder.exists) {
            var firstFolder = toLookInFolder.getFiles (isAcceptedFolder);
            if (firstFolder.length > 0) {
                firstFolderName = File.decode (firstFolder[0].name);
            }
        }
        if (firstFolderName) {
            relationPath = relationPath.replace(/<FF>/gi, firstFolderName);
        }
        else {
            relationPath = relationPath.replace(/<FF>/gi, "0001");
        }
    }
    if (relationPath.search (/<LF>/i) != -1) {
        var lastFolderName = null;
        var toLookInFolder = Folder (relationPath.slice (0, relationPath.search (/\/<LF>/i)));
        if (toLookInFolder.exists) {
            var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
            if (lastFolder.length > 0) {
                lastFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
            }
        }
        if (lastFolderName) {
            relationPath = relationPath.replace(/<LF>/gi, lastFolderName);
        }
        else {
            relationPath = relationPath.replace(/<LF>/gi, "0001");
        }
    }
    return relationPath;
}

function tsMainTask () {
    /**///$.writeln ($.line);
    mainLoopIndex++;
    if (mainLoopIndex > 3) {
        mainLoopIndex = 0;
    }
    try {
        if (app.document) {
            if (app.document.navbars) {
                if (app.document.navbars.filesystem) {
                    if (app.document.navbars.filesystem.top) {
                        if (app.document.navbars.filesystem.top.mainLoopRun) {
                            app.document.navbars.filesystem.top.mainLoopRun.text = mainLoop[mainLoopIndex];
                        }
                    }
                }
            }
        }
    }
    catch (e) {
        //$.writeln ("Error " + $.line);
    }
    if (tsTaskStage == 0) { //Initializing
        if (tsInitializeStep++ > 3) {
            tsInitializeStep = 0;
            if (!tsInitialize ()) {
                //app.cancelTask (tsMainTaskID);
                return false;
            }
            if (app.document.navbars.filesystem.top.goToTree) {
                if (tsWorkshopPath == "") {
                    app.document.navbars.filesystem.top.goToTree.enabled = false;
                }
                if (tsPagesPath == "") {
                    app.document.navbars.filesystem.top.goToPages.enabled = false;
                }
                if (tsVersionsPath == "") {
                    app.document.navbars.filesystem.top.goToVersions.enabled = false;
                }
                if (tsFinalPDFPath == "") {
                    app.document.navbars.filesystem.top.goToFinalPDF.enabled = false;
                }
                if (tsVersionsPDFPath == "") {
                    app.document.navbars.filesystem.top.goToVersionsPDF.enabled = false;
                }
                if (tsTrashPath == "") {
                    app.document.navbars.filesystem.top.goToTrash.enabled = false;
                }
            }
            if (tsUserTask == "Scanning") {
                initializeAmbushingTask ();
            }
            tsTaskStage++;
        }
    }
    else if (tsTaskStage == 1 && tsUserTask == "Scanning") { //Ambushing
        if (tsAmbushingStep++ > 8) {
            tsAmbushingStep = 0;
            if (!okNowYouCanQuit) {
                if (closingRequested) {
                    //finishing process
                    finalizeBeforeQuitOrChangeRoot (true);
                }
                else {
                    var vacancyFile = new File (tsDataPath + "/Scanning/Vacancy");
                    if (vacancyFile.exists) {
                        if (vacancyFile.remove ()) {
                            var labourFile = new File (tsDataPath + "/Scanning/Labour");
                            writeFile (labourFile, tsClientID);
                            tsTaskStage++;
                            tsBuildMessagesLists ();
                            
                            //building freezing scapes
                            var allRootFolders = Folder (tsWorkshopPath).getFiles (isUnhiddenFolder);
                            for (var a = 0; a < allRootFolders.length; a++) {
                                var copyingLockFile = new File (allRootFolders[a].fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
                                if (!copyingLockFile.exists)
                                    writeFile (copyingLockFile, "TS");
                            }
                        
                            //removing old queries
                            if (!isNoDeleteTSQueries) {
                                var oldQueries = Folder (tsRootFolderPath + "/Workflow/Queries").getFiles (isAcceptedFolder);
                                for (var qw = 0; qw < oldQueries.length; qw++) {
                                    deleteForcelyFolders (oldQueries[qw], true);
                                }
                            }
                            
                            //loading tsScanningQueue
                            var scanningQueueFile = new File (tsDataPath + "/TS_SQ");
                            var scanningQueueContent = readEncodedFile (scanningQueueFile);
                            if (scanningQueueContent) {
                                tsScanningQueue = scanningQueueContent.split ("\n");
                            }

                            //tsAutoCheckInFilesList
                            //tsAutoCheckInFilesList[acfl][0] File ID
                            //tsAutoCheckInFilesList[acfl][1] Relation Method (Reference code or 'PLACING_DOCS')
                            //tsAutoCheckInFilesList[acfl][2] Duplicate Source if the relation file is missed (File ID)
                            //tsAutoCheckInFilesList[acfl][3] 'C' create new, 'P' path change, 'D' delete, 'M' modification, combinations 'CPDM', 'CD', 'PM'... 
                            //tsAutoCheckInFilesList[acfl][4] File Object
                            //tsAutoCheckInFilesList[acfl][5] last modified date, if null then it's added to be path once
                            //tsAutoCheckInFilesList[acfl][6] is path changed or file deleted... true or false
                            //tsAutoCheckInFilesList[acfl][7] the old path if path changed

                            var autoCheckInFilesFolder  = new Folder (tsRootFolderPath + "/Workflow/Auto Check In Files");
                            if (!autoCheckInFilesFolder.exists) {
                                autoCheckInFilesFolder.create ();
                            }
                            var filesRecordFiles = autoCheckInFilesFolder.getFiles (isAcceptedFile);
                            for (var frf = 0; frf < filesRecordFiles.length; frf++) {
                                var filesRecordContent = readEncodedFile (filesRecordFiles[frf]);
                                if (filesRecordContent) {
                                    filesRecordContent = filesRecordContent.split ("\n");
                                    if (filesRecordContent.length > 3) {
                                        var autoCheckInWorkshopFile = new File (tsWorkshopPath + "/" + File.decode (filesRecordFiles[frf].name).replace(/\s➔\s/g, "/"));
                                        tsAutoCheckInFilesList.push (filesRecordContent);
                                        tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (autoCheckInWorkshopFile);
                                        tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (0);
                                        tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (false);
                                        tsAutoCheckInFilesList[tsAutoCheckInFilesList.length - 1].push (null);
                                    }
                                }
                            }
                            
                            //loading tsConsiderSwapList
                            //tsConsiderSwapList
                            //tsConsiderSwapList[x][0] adding time
                            //tsConsiderSwapList[x][1] file path
                            //tsConsiderSwapList[x][2] file name
                            var considerSwapListFile = new File (tsDataPath + "/TS_CS");
                            var considerSwapListContent = readEncodedFile (considerSwapListFile);
                            if (considerSwapListContent) {
                                var considerSwapListLines = considerSwapListContent.split ("\n");
                                for (var csl = considerSwapListLines.length - 1; csl >= 0; csl--) {
                                    var considerSwapSplitted = considerSwapListLines[csl].split (":");
                                    tsConsiderSwapList.push ([parseInt (considerSwapSplitted[0], 10), considerSwapSplitted[1], considerSwapSplitted[2]]);
                                }
                            }
                        
                            //Set unfinished downloading
                            var downloadMessages = Folder (tsDataPath + "/Messages/Downloading").getFiles (isUnhiddenFile);
                            
                            for (var m = downloadMessages.length - 1; m >= 0; m--) {
                                //getting the information
                                var versionDotID = File.decode (downloadMessages[m].name).slice (0, File.decode (downloadMessages[m].name).lastIndexOf ("."));
                                var fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                                var versionID = "/" + versionDotID.replace (/\./g, "\/");
                                var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                                var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
                                var modificationTime = File.decode (downloadMessages[m].name).slice (File.decode (downloadMessages[m].name).lastIndexOf (".") + 1);
                                modificationTime = parseInt (modificationTime, 10);
                                //getting own time
                                var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
                                var versionTime = readFile (versionTimeFile);
                                if (!versionTime) {
                                    versionTime = "0";
                                }
                                versionTime = parseInt (versionTime, 10);
                                if (modificationTime < versionTime) {
                                    downloadMessages[m].remove ();
                                    continue;
                                }
                                var versionDigits = versionPrefix.slice (versionPrefix.length-2);
                                var messageContent = readFile (downloadMessages[m]);
                                if (!messageContent)
                                    continue;
                                var messageContentSplitted = messageContent.split ("\n");
                                var firstLineSplitted = messageContentSplitted[0].split (":");
                                var isFinal = (firstLineSplitted[0] == "Final" ? true : false);
                                var isWithPages = ((firstLineSplitted[2] == "With Pages" || firstLineSplitted[2] == "With All")? true : false);
                                var isWithPDF = ((firstLineSplitted[2] == "With PDF" || firstLineSplitted[2] == "With All")? true : false);
                                var oldVersionDigits = messageContentSplitted[1];
                                var senderID = messageContentSplitted[2]; 
                                var fileID_Path_newID = [fileID];
                                tsGetPath (fileID_Path_newID);
                                if (!fileID_Path_newID[1]) {
                                    downloadMessages[m].remove ();
                                    continue;
                                }
                                var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                var targetVersionFile = new File (tsVersionsPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + "/ver" + versionDigits + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1));
                                var isInDesign = isInDesignFile (workshopFile);
                                //Here               
                                if (tsDownloadingList.length > 100) {
                                    continue;
                                }
                                var downloadData = new Array;
                                downloadData.push (0); //[0] interval: determine the span which the file take to traited again
                                downloadData.push (0); //[1] counter: to the interval
                                downloadData.push (fileID); //fileID with slashs
                                
                                //building [3] array
                                downloadData.push (new Array);
                                downloadData[3].push (versionDigits); //[3][0] version digits
                                downloadData[3].push (new Array); //[3][1] array [modificationTime, isUpToDate]
                                downloadData[3][1].push (parseInt (modificationTime, 10)); //[3][1] modificationTime as integer not string
                                downloadData[3][1].push (true); //isUpToDate
                                downloadData[3].push (isFinal); //[3][2] isFinal
                                downloadData[3].push (oldVersionDigits); //[3][3] oldVersionDigits
                                downloadData[3].push (senderID); //[3][4] senderID
        
                                //building [4] array
                                downloadData.push (new Array);
                                downloadData[4].push (false);
        
                                var downloadingPathPart;
                                if (firstLineSplitted[1].slice (1) == "SELF") {
                                    var senderIndex = getSenderIndex (senderID);
                                    if (senderIndex == -1)
                                        continue;
                                    downloadingPathPart = sendersList[senderIndex][0][1].fsName.replace(/\\/g, '/');
                                }
                                else {
                                    var scopeIndex = getScopeIndex (firstLineSplitted[1].slice (1));
                                    if (scopeIndex == -1) {
                                        continue;
                                    }
                                    downloadingPathPart = tsScopesList[scopeIndex][1][5].parent.fsName.replace(/\\/g, '/');
                                }
                                
                                var physicalFile = new File (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/File");
                                downloadData[4].push (physicalFile);
                                downloadData[4].push (fileID_Path_newID[1]);
                                downloadData[4].push (false);
                                if (isInDesign) {
                                    //InDesign files information
                                    if (isWithPages) {
                                        downloadData.push (new Array);
                                        downloadData[5].push (false); //[5][0] is count file downloaded
                                        var countFile = new File (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/Count");
                                        downloadData[5].push (countFile);
        
                                        downloadData.push (new Array);
                                        downloadData[6].push (false); //[6][0] is pages folder downloaded
                                        var pagesFolder = new Folder (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/Pages");
                                        downloadData[6].push (pagesFolder);
                                        
                                        downloadData.push (new Array);
                                        downloadData[7].push (false); //[7][0] are all pages downloaded
                                    }
                                    else {
                                        downloadData.push (new Array);
                                        downloadData[5].push (true); //[5][0] is count file downloaded
                                        downloadData.push (0);
                                        downloadData.push (0);
                                    }
                                    
                                    if (isWithPDF) {
                                        downloadData.push (new Array);
                                        downloadData[8].push (false); //[8][0] is prevPDF file downloaded
                                        var physicalPrevPDF = new File (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/PrevPDF");
                                        downloadData[8].push (physicalPrevPDF);
                                    }
                                    else {
                                        downloadData.push (new Array);
                                        downloadData[8].push (true); //[8][0] is prevPDF file downloaded
                                    }
                                }
                                var downloadingWorkflowName = downloadData[4][2].replace (/\//g, " ➔ ");
                                downloadingWorkflowName = downloadingWorkflowName.slice (2);
                                var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                                if (!downloadingWorkflowFile.parent.exists)
                                    downloadingWorkflowFile.parent.create ();
                                writeFile (downloadingWorkflowFile, "TS_ID:" + downloadData[2]);
                                tsDownloadingList.push (downloadData);
                                var isToAlert = true;
                                try {
                                    app.document.navbars.filesystem.top.Downloading.text;
                                }
                                catch (e) { isToAlert = false; }
                                if (isToAlert) {
                                    app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                                }
                            }
                        }
                        else {
                            /*Error*/$.writeln ("Error " + $.line);
                        }
                    }
                }
            }
        }
    }
    else if (tsTaskStage == 2) {
        if (tsCopyToStep++ > 16) {
            tsCopyToStep = 0;
            //tsCopyToList
            //tsCopyToList[x][0] Source thumbnail
            //tsCopyToList[x][1] Target folder
            //tsCopyToList[x][2] New Name
            if (!app.isProcessingJob()) {
                if (tsCopyToList.length > 0) {
                    try {
                        var isCopied = tsCopyToList[0][0].copyTo (tsCopyToList[0][1]);
                        if (tsCopyToList[0][2]) {
                            File (tsCopyToList[0][1].fsName.replace(/\\/g, '/') + "/" + File.decode (tsCopyToList[0][0].spec.name)).rename (tsCopyToList[0][2]);
                        }
                    }
                    catch (e) {
                        /*Error*/$.writeln ("Tree Shade Error " + $.line + ": " + e);
                    }
                    tsCopyToList.splice (0, 1);
                }
            }
        }
        if (tsMessagesStep++ > 63) {
            tsMessagesStep = 0;
            //tsGroupedOrdersList 
            //tsGroupedOrdersList[go][0][0] sender index
            //tsGroupedOrdersList[go][0][1] steps
            //tsGroupedOrdersList[go][0][2] step
            //tsGroupedOrdersList[go][0][3] group id
            //tsGroupedOrdersList[go][0][4] files count
            //tsGroupedOrdersList[go][0][5] orders message
            //tsGroupedOrdersList[go][0][6] count of receivers
            //tsGroupedOrdersList[go][1] files' orders list
            //tsGroupedOrdersList[go][1][gof][0] fileID
            //tsGroupedOrdersList[go][1][gof][1] versionPrefix
            //tsGroupedOrdersList[go][1][gof][2] file
            //tsGroupedOrdersList[go][1][gof][3] file orders    
            
            for (var g = tsGroupedOrdersList.length - 1; g >= 0; g--) {
                tsGroupedOrdersList[g][0][2]++;
            }
            
            for (var gg = tsGroupedOrdersList.length - 1; gg >= 0; gg--) {
                if (tsGroupedOrdersList[gg][0][2] > tsGroupedOrdersList[gg][0][1]) {
                    if (tsGroupedOrdersList[gg][0][4] == tsGroupedOrdersList[gg][1].length) {
                        for (var ol = 0; ol < tsGroupedOrdersList[gg][1].length; ol++) {
                            for (var gofo = 0; gofo < tsGroupedOrdersList[gg][1][ol][3].length; gofo++) {
                                var orderParts = tsGroupedOrdersList[gg][1][ol][3][gofo].split (":");
                                if (orderParts[0] == "Produce") {
                                    if (orderParts.length > 1) {
                                        var newPathIDList = tsChangeFile (tsGroupedOrdersList[gg][1][ol][2], File (tsWorkshopPath + orderParts[1]), true, 5, false);
                                        if (newPathIDList) {
                                            var digitsFileIDTriple = getWorkshopVersionInfo (File (newPathIDList[0]), newPathIDList[1]);
                                            if (digitsFileIDTriple) {
                                                var PDFPreviewIndex = -1;
                                                for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                                                    if (newPathIDList[0] == tsAlertPDFPreviewList[ppl][0]) {
                                                        PDFPreviewIndex = ppl;
                                                        break;
                                                    }
                                                }
                                                if (PDFPreviewIndex == -1) {
                                                    tsAlertPDFPreviewList.push ([
                                                        newPathIDList[0], //The document full path
                                                        digitsFileIDTriple[2], //fileID
                                                        digitsFileIDTriple[0], //versionNumber
                                                        false, //isWithFinal
                                                        0, //count down
                                                        0 //skips count
                                                    ]);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        tsGroupedOrdersList.splice (gg, 1);
                    }
                    else if (tsGroupedOrdersList[gg][0][2] > 60) {
                        tsGroupedOrdersList.splice (gg, 1);
                    }
                }
            }
            
            //tsOrdersList[a][0] sender index
            //tsOrdersList[a][1] steps
            //tsOrdersList[a][2] step
            //tsOrdersList[a][3] versionFullDotID
            //tsOrdersList[a][4] is requested
            //tsOrdersList[a][5] is working of version
            //tsOrdersList[a][6] count of receivers
            //tsOrdersList[a][7] is to set remote under editing
            //tsOrdersList[a][8] the order body
            
            for (var a = tsOrdersList.length - 1; a >= 0; a--) {
                tsOrdersList[a][2]++;
            }
            
            for (var aa = tsOrdersList.length - 1; aa >= 0; aa--) {
                if (tsOrdersList[aa][2] > tsOrdersList[aa][1]) {
                    var senderName = sendersList[tsOrdersList[aa][0]][0][0];
                    if (sendersList[tsOrdersList[aa][0]][0][3] != -1) {
                        senderName = recipientsList[sendersList[tsOrdersList[aa][0]][0][3]][5];
                    }
                    if (tsOrdersList[aa][3] == "") {
                        alert (senderName + ":\n\n" + tsOrdersList[aa][8]);
                        tsOrdersList.splice (aa, 1);
                        continue;
                    }
                    else {
                        var versionDotID = tsOrdersList[aa][3].slice (0, tsOrdersList[aa][3].lastIndexOf ("."));
                        var fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                        var versionID = "/" + versionDotID.replace (/\./g, "\/");
                        var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                        var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
                        var modificationTime = tsOrdersList[aa][3].slice (tsOrdersList[aa][3].lastIndexOf (".") + 1);                    
                        var versionDigits = versionPrefix.slice (versionPrefix.length-2);
                        var currentVersionDigits = "01";
                        modificationTime = parseInt (modificationTime, 10);
                        var fileID_Path_newID = [fileID];
                        var pathTime = tsGetPath (fileID_Path_newID);
                        //getting own time
                        var hereTime = 0;
                        if (versionPrefix == "pth00") {
                            hereTime = pathTime;
                            if (!hereTime) {
                                hereTime = 0;
                            }
                        }
                        else {
                            var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
                            hereTime = readFile (versionTimeFile);
                            if (!hereTime) {
                                hereTime = "0";
                            }
                            else {
                                hereTime = parseInt (hereTime, 10);
                            }
                        }
                        var currentTime = new Date ().getTime ();
                        if (modificationTime < hereTime) {
                            tsOrdersList.splice (aa, 1);
                            continue;
                        }
                        else if (modificationTime == hereTime) {
                            //////
                            var isFileOK = false;
                            var targetActualFile = null;
                            //collect data
                            
                            if (!fileID_Path_newID[1]) {
                                tsOrdersList.splice (aa, 1);
                                continue;
                            }
                            if (versionPrefix == "pth00") {
                                if (File (tsWorkshopPath + fileID_Path_newID[1]).exists) {
                                    isFileOK = true;
                                }
                            }
                            else {
                                if (tsOrdersList[aa][5] == "1") {//it's working target
                                    var currentVersionRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                                    currentVersionDigits = readFile (currentVersionRecordFile);
                                    if (!currentVersionDigits)
                                        currentVersionDigits = "New";
                                    else {
                                        currentVersionDigits = currentVersionDigits.split (":")[0];
                                        if (currentVersionDigits == versionDigits) {
                                            targetActualFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                        }
                                    }
                                }
                                else {
                                    targetActualFile = new File (tsVersionsPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + "/ver" + versionDigits + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1));
                                }
                                if (targetActualFile) {
                                    if (targetActualFile.exists) {
                                        if (!tsIsShade (targetActualFile)) {
                                            isFileOK = true;
                                        }
                                    }
                                }
                            }
                            if (isFileOK) {
                                if (tsOrdersList[aa][8][0] == '#') {
                                    //tsGroupedOrdersList 
                                    //tsGroupedOrdersList[go][0][0] sender index
                                    //tsGroupedOrdersList[go][0][1] steps
                                    //tsGroupedOrdersList[go][0][2] step
                                    //tsGroupedOrdersList[go][0][3] group id
                                    //tsGroupedOrdersList[go][0][4] files count
                                    //tsGroupedOrdersList[go][0][5] orders message
                                    //tsGroupedOrdersList[go][0][6] count of receivers
                                    //tsGroupedOrdersList[go][1] files' orders list
                                    //tsGroupedOrdersList[go][1][gof][0] fileID
                                    //tsGroupedOrdersList[go][1][gof][1] versionPrefix
                                    //tsGroupedOrdersList[go][1][gof][2] file
                                    //tsGroupedOrdersList[go][1][gof][3] file orders
                                    var ordersLines = tsOrdersList[aa][8].split ("\n");
                                    var ordersHead = ordersLines[0].split (":");
                                    var ordersMessage = ordersHead.length > 2? ordersHead[2] : null;
                                    if (ordersLines.length > 1) {
                                        ordersLines.splice (0, 1);
                                    }
                                    else {
                                        ordersLines = new Array;
                                    }
                                    var goIndex = -1;
                                    for (var go = 0; go < tsGroupedOrdersList.length; go++) {
                                        if (tsGroupedOrdersList[go][0][3] == ordersHead[0]) {
                                            goIndex = go;
                                            break;
                                        }
                                    }
                                    if (goIndex == -1) {
                                        goIndex = tsGroupedOrdersList.length;
                                        var tsGroupedOrdersItem = new Array;
                                        tsGroupedOrdersItem.push ([tsOrdersList[aa][0], 1, 0, ordersHead[0], parseInt (ordersHead[1], 10), ordersMessage, tsOrdersList[aa][6]]);
                                        tsGroupedOrdersItem.push (new Array);
                                        tsGroupedOrdersList.push (tsGroupedOrdersItem);
                                    }
                                    else if (!tsGroupedOrdersList[goIndex][0][5] && ordersMessage) {
                                        tsGroupedOrdersList[goIndex][0][5] = ordersMessage;
                                    }
                                    tsGroupedOrdersList[goIndex][1].push ([fileID, versionPrefix, File (tsWorkshopPath + fileID_Path_newID[1]), ordersLines]);
                                }
                                else {
                                    //put the message
                                    var messagesRootFolder = Folder (tsRootFolderPath + "/Workflow/Messages");
                                    var now = new Date ();
                                    var month = now.getMonth () + 1;
                                    var day = now.getDate ();
                                    var hours = now.getHours();
                                    var minutes = now.getMinutes();
                                    month = month > 9? month.toString () : "0" + month.toString ();
                                    day = day > 9? day.toString () : "0" + day.toString ();
                                    var AmPm = "am";
                                    if (hours > 12) {
                                        AmPm = "pm";
                                        hours = hours - 12;
                                    }
                                    hours = hours > 9? hours.toString () : "0" + hours.toString ();
                                    minutes = minutes > 9? minutes.toString () : "0" + minutes.toString ();
                                    var dayName;
                                    switch (now.getDay ()) {
                                        case 0:
                                            dayName = "Sunday";
                                            break;
                                        case 1:
                                            dayName = "Monday";
                                            break;
                                        case 2:
                                            dayName = "Tuesday";
                                            break;
                                        case 3:
                                            dayName = "Wednesday";
                                            break;
                                        case 4:
                                            dayName = "Thursday";
                                            break;
                                        case 5:
                                            dayName = "Friday";
                                            break;
                                        case 6:
                                            dayName = "Saturday";
                                            break;
                                    }
                                    var displayID = fileDotID.slice (1);
                                    displayID = displayID.slice (displayID.indexOf (".") + 1);
                                    var thisDay = "/" + now.getFullYear() + "." + month + "/" + day + "." + dayName + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")) + " (" + displayID + ")" +  "/" + senderName + " At " + hours + "." + minutes + AmPm + " (" + versionPrefix + ") ";
                                    
                                    var shortcutFile = new File (messagesRootFolder.fsName.replace(/\\/g, '/') + thisDay + tsOrdersList[aa][8]);
                                    shortcutFile.parent.create ();
                                    shortcutFile.createAlias (targetActualFile);
                                    if (!isNewMessage) {
                                        isNewMessage = true;
                                        //alarm
                                        if ((app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (messagesRootFolder.fsName.replace(/\\/g, '/') + "/") != 0) {
                                            if (startScanAtZero == 0) {
                                                var alarmFile = new File (messagesRootFolder.fsName.replace(/\\/g, '/') + "/^ Open me to browse new messages.mp3");
                                                if (alarmFile.exists) {
                                                    tsToBeSelectedThumbnail = new Thumbnail (alarmFile);
                                                    tsLoadStage = 1;
                                                    app.document.thumbnail = tsToBeSelectedThumbnail.parent;
                                                }
                                            }
                                            else {
                                                var wantToSee = confirm ("You have new messages. Do you want to see?");
                                                if (wantToSee) {
                                                    var now = new Date ();
                                                    var month = now.getMonth () + 1;
                                                    var day = now.getDate ();
                                                    month = month > 9? month.toString () : "0" + month.toString ();
                                                    day = day > 9? day.toString () : "0" + day.toString ();
                                                    var dayName;
                                                    switch (now.getDay ()) {
                                                        case 0:
                                                            dayName = "Sunday";
                                                            break;
                                                        case 1:
                                                            dayName = "Monday";
                                                            break;
                                                        case 2:
                                                            dayName = "Tuesday";
                                                            break;
                                                        case 3:
                                                            dayName = "Wednesday";
                                                            break;
                                                        case 4:
                                                            dayName = "Thursday";
                                                            break;
                                                        case 5:
                                                            dayName = "Friday";
                                                            break;
                                                        case 6:
                                                            dayName = "Saturday";
                                                            break;
                                                    }
                                                    var targetMessagesFolder = new Folder (tsRootFolderPath + "/Workflow/Messages/" + now.getFullYear() + "." + month + "/" + day + "." + dayName);
                                                    if (targetMessagesFolder.exists) {
                                                        app.document.thumbnail = new Thumbnail (targetMessagesFolder);
                                                        isNewMessage = false;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                tsOrdersList.splice (aa, 1);
                                continue;
                            }
                        }
                        if (!tsOrdersList[aa][4]) {
                            tsOrdersList[aa][4] = true;
                            if (versionPrefix == "pth00") { //to load the file path
                            }
                            else {
                                if (currentTime - modificationTime > 1800000) {
                                    if (sendersList[tsOrdersList[aa][0]][0][3] != -1) {
                                        tsIsSendingDone = false;
                                        var sendingBoxesItem = new Array;
                                        sendingBoxesItem.push ("IRequest");
                                        sendingBoxesItem.push (versionDotID + "." + modificationTime);
                                        sendingBoxesItem.push ("A");
                                        recipientsList[sendersList[tsOrdersList[aa][0]][0][3]][8][1].push (sendingBoxesItem);
                                    }
                                    else {
                                        tsOrdersList.splice (aa, 1);
                                        continue;
                                    }
                                }
                            }
                        }
                        else {
                            if (tsOrdersList[aa][2] > 60) {
                                tsOrdersList.splice (aa, 1);
                                continue;
                            }
                        }
                        continue;
                    }
                }
            }
        }
        if (tsAlertPDFPreviewStep++ > 1) {
            tsAlertPDFPreviewStep = 0;
            for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                //[0] The document full path
                //[1] fileID
                //[2] versionNumber
                //[3] isWithFinal
                //[4] count down
                //[5] skips count
                if (tsAlertPDFPreviewList[ppl][4]-- < 1) {
                    var PDFPreviewFile = File (tsAlertPDFPreviewList[ppl][0]);
                    if (!PDFPreviewFile.exists) {
                        tsAlertPDFPreviewList.splice (ppl, 1);
                        continue;
                    }
                    alertPDFPreview (PDFPreviewFile, tsAlertPDFPreviewList[ppl][1], tsAlertPDFPreviewList[ppl][2], tsAlertPDFPreviewList[ppl][3]);
                    tsAlertPDFPreviewList.splice (ppl, 1);
                }
            }            
        }
        if (tsAlertPathChangedStep++ > 7) {
            tsAlertPathChangedStep = 0;
            //tsChangeAfterCloseList
            //tsChangeAfterCloseList[cac][0] counter
            //tsChangeAfterCloseList[cac][1] targetFilePath
            //tsChangeAfterCloseList[cac][2] destinationFilePath
            //tsChangeAfterCloseList[cac][3] cancelOrOverwriteOrSolve
            //tsChangeAfterCloseList[cac][4] is tested
            //tsChangeAfterCloseList[cac][5] was opened
            //tsChangeAfterCloseList[cac][6] was modified
            for (var cac = tsChangeAfterCloseList.length - 1; cac >= 0; cac--) {
                tsChangeAfterCloseList[cac][0]++;
                var isDealDone = false;
                if (tsChangeAfterCloseList[cac][4]) { //is tested
                    if (tsChangeAfterCloseList[cac][5]) { //was opened
                        if (tsChangeAfterCloseList[cac][6]) { //was modified
                            var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                            var talkInDesign = new BridgeTalk;
                            talkInDesign.target = targetInDesign;
                            talkInDesign.onResult = function (returnBtObj)
                            { setInDesignScript (returnBtObj.body); }
                            talkInDesign.body = 
                                "testExisting ();" +
                                "function testExisting () {" +
                                    "for (var a = 0; a < app.documents.length; a++) " +
                                    "{" + 
                                        "var resultPath = app.documents[a].filePath.fsName.replace(/\\/g, '/');" + //replace(/\\/g, '/')
                                        "if (resultPath + '/' + app.documents[a].name == '" + tsChangeAfterCloseList[cac][1] + "') {" +
                                            "return '';" +
                                        "}" +
                                    "}" +
                                    "return '" + tsChangeAfterCloseList[cac][1] + "';" +
                                "}";
                            talkInDesign.send ();
                            function setInDesignScript (theBody) {
                                if (theBody) {
                                    for (var cac = tsChangeAfterCloseList.length - 1; cac >= 0; cac--) {
                                        if (theBody == tsChangeAfterCloseList[cac][1]) {
                                            var newPathIDList = tsChangeFile (File (tsChangeAfterCloseList[cac][1]), File (tsChangeAfterCloseList[cac][2]), false, tsChangeAfterCloseList[cac][3], false);
                                            if (newPathIDList) {
                                                var isToReopenAlready = false;
                                                var newPath = newPathIDList[0].replace (tsWorkshopPath, "");
                                                for (var rar = tsReopenAfterRenameList.length - 1; rar >= 0; rar--) {
                                                    if (newPath == tsReopenAfterRenameList[rar]) {
                                                        isToReopenAlready = true;
                                                        break;
                                                    }
                                                }
                                                if (!isToReopenAlready) {
                                                    tsReopenAfterRenameList.push (newPath);
                                                }
                                            }
                                            tsChangeAfterCloseList.splice (cac, 1);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        else { //the file is saved already
                            isDealDone = true;
                        }
                    }
                    else { //the file is closed
                        isDealDone = true;
                    }
                }
                else {
                }
                if (isDealDone) {
                    var newPathIDList = tsChangeFile (File (tsChangeAfterCloseList[cac][1]), File (tsChangeAfterCloseList[cac][2]), false, tsChangeAfterCloseList[cac][3], false);
                    if (newPathIDList && tsChangeAfterCloseList[cac][5]) {
                        var isToReopenAlready = false;
                        var newPath = newPathIDList[0].replace (tsWorkshopPath, "");
                        for (var rar = tsReopenAfterRenameList.length - 1; rar >= 0; rar--) {
                            if (newPath == tsReopenAfterRenameList[rar]) {
                                isToReopenAlready = true;
                                break;
                            }
                        }
                        if (!isToReopenAlready) {
                            tsReopenAfterRenameList.push (newPath);
                        }
                    }
                    tsChangeAfterCloseList.splice (cac, 1);
                }
            }
            
            for (var q = tsIDTimePathStepIsUserOldPathList.length - 1; q >= 0; q--) {
                tsIDTimePathStepIsUserOldPathList[q][3] = tsIDTimePathStepIsUserOldPathList[q][3] + 1;
                if (tsIDTimePathStepIsUserOldPathList[q][3] > 1) {
                    for (var rar = tsReopenAfterRenameList.length - 1; rar >= 0; rar--) {
                        if (tsReopenAfterRenameList[rar] == tsIDTimePathStepIsUserOldPathList[q][2]) {
                            tsReopenAfterRenameList.splice (rar, 1);
                            var toReopenDocument = new File (tsWorkshopPath + tsIDTimePathStepIsUserOldPathList[q][2]);
                            if (toReopenDocument.exists) {
                                var toReopenThumbnail = new Thumbnail (toReopenDocument);
                                toReopenThumbnail.open ();
                            }
                            break;
                        }
                    }
                    tsIDTimePathStepIsUserOldPathList.splice (q, 1);
                    continue;
                }
                if (tsIDTimePathStepIsUserOldPathList[q][3] == 0) {
                    if (tsIDTimePathStepIsUserOldPathList[q][4]) {
                        var fileDotID = tsIDTimePathStepIsUserOldPathList[q][0].replace (/\//g,"\.");
                        fileDotID = fileDotID.slice (1);
                        var pathChangedTwin = new Array;
                        if (tsIDTimePathStepIsUserOldPathList[q][2].length > 0) {
                            if (tsIDTimePathStepIsUserOldPathList[q][2][0] != ":") {
                                pathChangedTwin = getTotalGoal (tsIDTimePathStepIsUserOldPathList[q][2], null, tsIDTimePathStepIsUserOldPathList[q][0], false);
                            }
                            else {
                                pathChangedTwin = getTotalGoal (tsIDTimePathStepIsUserOldPathList[q][5], null, tsIDTimePathStepIsUserOldPathList[q][0], false);
                            }
                        }

                        //tsAutoCheckInFilesList
                        //tsAutoCheckInFilesList[acfl][0] File ID
                        //tsAutoCheckInFilesList[acfl][1] Relation Method (Reference code or 'PLACING_DOCS')
                        //tsAutoCheckInFilesList[acfl][2] Duplicate Source if the relation file is missed (File ID)
                        //tsAutoCheckInFilesList[acfl][3] 'C' create new, 'P' path change, 'D' delete, 'M' modification, combinations 'CPDM', 'CD', 'PM'... 
                        //tsAutoCheckInFilesList[acfl][4] File Object
                        //tsAutoCheckInFilesList[acfl][5] last modified date, if null then it's added to be path once as what will happen here
                        //tsAutoCheckInFilesList[acfl][6] is path changed or file deleted... true or false
                        //tsAutoCheckInFilesList[acfl][7] the old path if path changed

                        if (tsIDTimePathStepIsUserOldPathList[q][2][0] != ':' && !tsIDTimePathStepIsUserOldPathList[q][5]) { //new file
                            var theAutoCheckInFile = File (tsWorkshopPath + tsIDTimePathStepIsUserOldPathList[q][2]);
                            var autoCheckInFolItem = null;
                            var autoCheckInMarkFile = new File (tsDataPath + "/IDs" + tsIDTimePathStepIsUserOldPathList[q][0] + "/Auto Check In Mark");
                            var autoCheckInMarkContent = readEncodedFile (autoCheckInMarkFile);
                            if (autoCheckInMarkContent) {
                                autoCheckInFolItem = autoCheckInMarkContent.split ("\n");
                            }
                            else {
                                var testedAutoName = tsIDTimePathStepIsUserOldPathList[q][2].slice (tsIDTimePathStepIsUserOldPathList[q][2].lastIndexOf ("/") + 1);
                                if (testedAutoName.search (/ts_key/i) != -1) {
                                    autoCheckInMarkContent = tsIDTimePathStepIsUserOldPathList[q][0] + "\n" + "./*.indd" + "\n" + "<P>./*.indd" + "\n" + "CP";
                                    writeEncodedFile (autoCheckInMarkFile, autoCheckInMarkContent);
                                    autoCheckInFolItem = autoCheckInMarkContent.split ("\n");
                                }
                            }
                            if (autoCheckInFolItem && autoCheckInFolItem.length > 3) {
                                autoCheckInFolItem[0] = tsIDTimePathStepIsUserOldPathList[q][0];
                                tsAutoCheckInFilesList.push ([autoCheckInFolItem[0], autoCheckInFolItem[1], autoCheckInFolItem[2], autoCheckInFolItem[3], theAutoCheckInFile, 0, null, null]);
                            }
                        }
                        else {
                            for (var acfl = tsAutoCheckInFilesList.length - 1; acfl >= 0; acfl--) {
                                if (tsIDTimePathStepIsUserOldPathList[q][0] == tsAutoCheckInFilesList[acfl][0]) {
                                    tsAutoCheckInFilesList[acfl][6] = true;
                                    if (tsIDTimePathStepIsUserOldPathList[q][5]) { //old path is relative
                                        tsAutoCheckInFilesList[acfl][7] = tsIDTimePathStepIsUserOldPathList[q][5];
                                    }
                                    break;
                                }
                            }
                        }

                        for (var auno = 0; auno < pathChangedTwin.length; auno++) {
                            for (var asp = 0; asp < pathChangedTwin[auno].length; asp++) {
                                for (var arc = 0; arc < pathChangedTwin[auno][asp][1].length; arc++) {
                                    if (tsIDTimePathStepIsUserOldPathList[q][2][0] != ':') {
                                        var isWithThumbnail = false;
                                        if (!tsIDTimePathStepIsUserOldPathList[q][5]) {
                                            isWithThumbnail = true;
                                        }
                                        var alertPathFile = new File (tsWorkshopPath + tsIDTimePathStepIsUserOldPathList[q][2]);
                                        if (alertPathFile.exists) {
                                            tsUploadFilePath (alertPathFile, tsIDTimePathStepIsUserOldPathList[q][1], tsIDTimePathStepIsUserOldPathList[q][0], pathChangedTwin[auno][asp][1][arc], isWithThumbnail);
                                        }
                                    } 
                                    else {
                                        var previousID = readFile (File (tsDataPath + "/IDs" + fileID + "/Previous ID"));
                                        var originalID = readFile (File (tsDataPath + "/IDs" + fileID + "/Original ID"));
                                        if (!previousID) previousID = "NO_ID";
                                        if (!originalID) originalID = "NO_ID";

                                        var withThumbPart = "NO_THUMB";
                                        tsIsSendingDone = false;
                                        var sendingBoxesItem = new Array;
                                        sendingBoxesItem.push ("PathChanged");
                                        sendingBoxesItem.push (fileDotID + "." + tsIDTimePathStepIsUserOldPathList[q][1]);
                                        sendingBoxesItem.push (tsIDTimePathStepIsUserOldPathList[q][2] + "**" + withThumbPart + "**" + previousID + "**" + originalID);
                                        recipientsList[pathChangedTwin[auno][asp][1][arc]][8][1].push (sendingBoxesItem); 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (tsPhysicalPDFStep++ > 9) {
            tsPhysicalPDFStep = 0;
            //scanning method
            if (startScanAtZero > 0) {
                startScanAtZero--;
            }
            if (tsIsWideScanning && !tsIsWideScanningUltimate) {
                if (startScanAtZero == 0) {
                    if (tsIsScanningStopped != 1) {
                        tsIsScanningStopped = 1;
                    }
                }
                else {
                    if (tsIsScanningStopped != 2) {
                        tsIsScanningStopped = 2;
                    }
                }
            }

            for (var a = tsPhysicalPDFList.length - 1; a >= 0; a--) {
                if (tsPhysicalPDFList[a][0] instanceof File) {
                    tsPhysicalPDFList[a][0] = new File (tsPhysicalPDFList[a][0].fsName.replace(/\\/g, '/')); //if you commet this then strange thing will happen!
                    if (tsPhysicalPDFList[a][0].exists) {
                        if (tsPhysicalPDFList[a][5]) {
                            if (tsPhysicalPDFList.length == 1) {
                                var targetExportedThumb = new Thumbnail (tsPhysicalPDFList[a][0]);
                                tsToBeSelectedThumbnail = targetExportedThumb;
                                tsLoadStage = 1;
                                app.document.thumbnail = targetExportedThumb.parent;
                            }
                            tsPhysicalPDFList.splice (a, 1);
                            continue;
                        }
                        if (tsPhysicalPDFList[a][0].length == 0)
                            continue;
                        if (tsPhysicalPDFList[a][4] != tsPhysicalPDFList[a][0].length) {
                            tsPhysicalPDFList[a][4] = tsPhysicalPDFList[a][0].length;
                            continue;
                        }
                        if (!tsIsShade (tsPhysicalPDFList[a][0])) {
                            if (tsPhysicalPDFList[a][1]) {
                                for (var ph = 0; ph < tsPhysicalPDFList[a][1].length; ph++) {
                                    if (!tsPhysicalPDFList[a][1][ph].parent.exists) {
                                        tsPhysicalPDFList[a][1][ph].parent.create ();
                                    }
                                    tsPhysicalPDFList[a][0].copy (tsPhysicalPDFList[a][1][ph]);
                                }
                            }
                            if (tsPhysicalPDFList[a][2]) {
                                if (!tsPhysicalPDFList[a][2].parent.exists)
                                    tsPhysicalPDFList[a][2].parent.create ();
                                tsPhysicalPDFList[a][0].copy (tsPhysicalPDFList[a][2]);
                            }
                            if (tsPhysicalPDFList[a][3]) {
                                if (tsPhysicalPDFList[a][3] instanceof File) {
                                    if (tsPhysicalPDFList[a][3].exists) {
                                        tsPhysicalPDFList[a][3].remove ();
                                    }
                                }
                            }
                            tsPhysicalPDFList[a][5] = true; //copying is done
                        }
                    }
                }
                else {
                    tsPhysicalPDFList.splice (a, 1);
                }
            }
        }
        if (tsFakeModifiedStep++ > 5) {
            tsFakeModifiedStep = 0;
            //tsOldModifiedFileIDList
            //tsOldModifiedFileIDList[c][0] old date
            //tsOldModifiedFileIDList[c][1] file object
            //tsOldModifiedFileIDList[c][2] file ID
            //tsOldModifiedFileIDList[c][3] counter
            for (var c = tsOldModifiedFileIDList.length - 1; c >= 0; c--) {
                tsOldModifiedFileIDList[c][3]++;
                if (tsOldModifiedFileIDList[c][1].exists) {
                    var currentModified = tsOldModifiedFileIDList[c][1].modified.getTime ();
                    if (tsOldModifiedFileIDList[c][0] == currentModified) {
                        if (tsOldModifiedFileIDList[c][3] > 4)
                            tsOldModifiedFileIDList.splice (c, 1);
                        continue;
                    }
                    var fakeDateFile = new File (tsDataPath + "/IDs" + tsOldModifiedFileIDList[c][2] + "/Workshop/FakeDate");
                    var isOldFakeAlso = false;
                    if (fakeDateFile.exists) {
                        var oldFake = readFile (fakeDateFile);
                        if (oldFake) {
                            oldFake = parseInt (oldFake, 10);
                            if (oldFake == tsOldModifiedFileIDList[c][0]) {
                                isOldFakeAlso = true;
                            }
                        }
                    }
                    else {
                        fakeDateFile.parent.create ();
                    }
                    writeFile (fakeDateFile, currentModified); 
                    if (!isOldFakeAlso) {
                        var beforeFakeFile = new File (tsDataPath + "/IDs" + tsOldModifiedFileIDList[c][2] + "/Workshop/BeforeFake");
                        beforeFakeFile.parent.create ();
                        writeFile (beforeFakeFile, tsOldModifiedFileIDList[c][0].toString ());
                    }
                }
                tsOldModifiedFileIDList.splice (c, 1);
            }

            //emptyFoldersList
            //emptyFoldersList[0] tsWorkshopPath List
            //emptyFoldersList[1] non tsWorkshopPath List
            emptyFoldersStep++;
            if (emptyFoldersStep > 2) {
                emptyFoldersStep = 0;
                for (var eft = emptyFoldersList[0].length - 1; eft >= 0; eft--) {
                    var treeFolder = new Folder (tsWorkshopPath + emptyFoldersList[0][eft]);
                    var parentAbsolutePath = (emptyFoldersList[0][eft].indexOf ("/") == -1)? null : emptyFoldersList[0][eft].slice (0, emptyFoldersList[0][eft].lastIndexOf ("/"));
                    var isToAddParent = false;
                    if (treeFolder.exists) {
                        if (tsDeleteEmptyFolders (treeFolder)) {
                            var pagesWorkshopFolder = new Folder (tsPagesPath + "/Workshop" + emptyFoldersList[0][eft]);
                            var pagesVersionsFolder = new Folder (tsVersionsPages + emptyFoldersList[0][eft]);
                            var versionsFolder = new Folder (tsVersionsPath + emptyFoldersList[0][eft]);
                            var finalFolder = new Folder (tsFinalPDFPath + emptyFoldersList[0][eft]);
                            var previewFolder = new Folder (tsVersionsPDFPath + emptyFoldersList[0][eft]);
                            var dataShadesFolder = new Folder (tsDataPath + "/Shades" + emptyFoldersList[0][eft]);
                            var dataShotsFolder = new Folder (tsDataPath + "/Shots" + emptyFoldersList[0][eft]);
                            tsDeleteEmptyFolders (pagesWorkshopFolder);
                            tsDeleteEmptyFolders (pagesVersionsFolder);
                            tsDeleteEmptyFolders (versionsFolder);
                            tsDeleteEmptyFolders (finalFolder);
                            tsDeleteEmptyFolders (previewFolder);
                            deleteForcelyFolders (dataShadesFolder, true);
                            deleteForcelyFolders (dataShotsFolder, true);
                            if (parentAbsolutePath) {
                                isToAddParent = true;
                            }
                        }
                    }
                    else if (parentAbsolutePath) {
                        isToAddParent = true;
                    }
                    emptyFoldersList[0].splice (eft, 1);
                    if (isToAddParent) {
                        emptyFoldersList[0].unshift (parentAbsolutePath);
                        eft++;
                    }
                }
                for (var efn = emptyFoldersList[1].length - 1; efn >= 0; efn--) {
                    var toBeDeletedFolder = new Folder (emptyFoldersList[1][efn]);
                    if (toBeDeletedFolder.exists)
                        tsDeleteEmptyFolders (toBeDeletedFolder);
                    emptyFoldersList[1].splice (efn, 1);
                }
            }

            //tsConsiderSwapList
            //tsConsiderSwapList[x][0] adding time
            //tsConsiderSwapList[x][1] file path
            //tsConsiderSwapList[x][2] file name
            tsConsiderSwapStep++;
            if (tsConsiderSwapStep > 2) {
                tsConsiderSwapStep = 0;
                var currentTime = new Date ().getTime ();
                for (var cs = tsConsiderSwapList.length - 1; cs >= 0; cs--) {
                    if (!File (tsConsiderSwapList[cs][1] + "/" + tsConsiderSwapList[cs][2].slice (10)).exists) {
                        File (tsConsiderSwapList[cs][1] + "/" + tsConsiderSwapList[cs][2]).rename (tsConsiderSwapList[cs][2].slice (10));
                        tsConsiderSwapList.splice (cs, 1);
                    }
                    else if (currentTime - tsConsiderSwapList[cs][0] > 1800000) {
                        tsConsiderSwapList.splice (cs, 1);
                    }
                }
            }
            //tsVersionsToWorkshopList
            //tsVersionsToWorkshopList[x][0] count
            //tsVersionsToWorkshopList[x][1] file to be copied thumbnail
            //tsVersionsToWorkshopList[x][2] destination file
            //tsVersionsToWorkshopList[x][3] destination file length
            //tsVersionsToWorkshopList[x][4] fileID
            //tsVersionsToWorkshopList[x][5] Version Time
            tsVersionsToWorkshopStep++;
            if (tsVersionsToWorkshopStep > 1) {
                for (var vw = tsVersionsToWorkshopList.length -1 ; vw >= 0; vw--) {
                    tsVersionsToWorkshopList[vw][0]++;
                    if (tsVersionsToWorkshopList[vw][3] == null || tsVersionsToWorkshopList[vw][3] < 0) {
                        if (tsVersionsToWorkshopList[vw][3] == -1) { //the file is removed
                            if (tsVersionsToWorkshopList[vw][2].exists) {
                                continue;
                            }
                        }
                        var fileID = tsVersionsToWorkshopList[vw][4];
                        if (!fileID) {
                            fileID = tsGetID (tsVersionsToWorkshopList[vw][1].spec);
                            if (!fileID) {
                                continue;
                            }
                            tsVersionsToWorkshopList[vw][4] = fileID;
                        }
                        if (isInDesignFile (tsVersionsToWorkshopList[0][1].spec)) {
                            var docDotID = fileID.replace (/\//g,"\.");
                            docDotID = docDotID.slice (1);
                            var openedMarkFile = new File (tsDataPath + "/Opened Documents/" + docDotID);
                            if (openedMarkFile.exists) {
                                if (tsVersionsToWorkshopList[vw][3] == -2) { //the closing
                                    continue;
                                }
                                var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                                var talkInDesign = new BridgeTalk;
                                var conflictFolder = new Folder (tsVersionsToWorkshopList[vw][2].parent.fsName.replace(/\\/g, '/') + "/Conflict Documents");
                                talkInDesign.target = targetInDesign;
                                talkInDesign.body = 
                                    "testExisting ();\n" +
                                    "function testExisting () {\n" +
                                        "for (var a = 0; a < app.documents.length; a++) {\n" +
                                            "var targetDoc = app.documents[a];" + "\n" +
                                            "var docID = targetDoc.metadataPreferences.getProperty('http://ns.dulajun.com/treeshade/', 'TS_ID');\n" +
                                            "if (docID == '" + fileID + "') {\n" +
                                                "if (targetDoc.modified) {" + "\n" +
                                                    "Folder ('" + conflictFolder.fsName.replace(/\\/g, '/') + "').create ();" + "\n" +
                                                    "targetDoc.saveACopy (File ('" + conflictFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (tsVersionsToWorkshopList[vw][2].name) + "'));" + "\n" +
                                                "}" + "\n" +
                                                "targetDoc.close (SaveOptions.NO);" + "\n" +
                                            "}" + "\n" +
                                        "}" + "\n" +
                                        "return docList;\n" +
                                    "}\n";
                                talkInDesign.send ();
                                tsVersionsToWorkshopList[vw][3] = -2; // -2 the file is closed
                                continue;
                            }
                            else {
                                tsVersionsToWorkshopList[vw][3] = -2; // the file is closed
                            }
                        }
                        //process
                        if (tsVersionsToWorkshopList[vw][3] == null || tsVersionsToWorkshopList[vw][3] == -2) { //if the file is not an open document or if the document is closed
                            if (!tsVersionsToWorkshopList[vw][2].parent.exists) {
                                tsVersionsToWorkshopList[vw][2].parent.create ();
                            }
                            else if (tsVersionsToWorkshopList[vw][2].exists) {
                                tsVersionsToWorkshopList[vw][2].readonly = false;
                                tsVersionsToWorkshopList[vw][2].remove (); 
                                tsVersionsToWorkshopList[vw][3] = -1;
                                //continue;
                            }
                        }
                        tsVersionsToWorkshopList[vw][3] = 0;
                        if (tsVersionsToWorkshopList[vw][1].spec.length > 500000000) {
                            tsCopyToList.push ([tsVersionsToWorkshopList[vw][1], tsVersionsToWorkshopList[vw][2].parent, File.decode (tsVersionsToWorkshopList[vw][2].name)]);
                        }
                        else {
                            try {
                                tsVersionsToWorkshopList[vw][1].copyTo (tsVersionsToWorkshopList[vw][2].parent);
                            }
                            catch (e) {
                                /*Error*/$.writeln ("\n******\nTree Shade Error\n" + e);
                                /*Error*/$.writeln ("tsVersionsToWorkshopList[vw][1] " + tsVersionsToWorkshopList[vw][1]);
                                /*Error*/$.writeln ("tsVersionsToWorkshopList[vw][2] " + tsVersionsToWorkshopList[vw][2]);
                            }
                            File (tsVersionsToWorkshopList[vw][2].parent.fsName.replace(/\\/g, '/') + "/" + File.decode (tsVersionsToWorkshopList[vw][1].spec.name)).rename (File.decode (tsVersionsToWorkshopList[vw][2].name));
                        }
                        if (tsVersionsToWorkshopList[vw][5]) { //Version Time
                            var versionTime = tsVersionsToWorkshopList[vw][5];
                            tsMarkFakeModified (versionTime-1, tsVersionsToWorkshopList[vw][2], tsVersionsToWorkshopList[vw][4]);
                        }
                    }
                    else {
                        if (tsVersionsToWorkshopList[vw][3] == tsVersionsToWorkshopList[vw][2].length && tsVersionsToWorkshopList[vw][3] != 0) {
                            if (!isCSFile (tsVersionsToWorkshopList[vw][2]))
                                tsUpdateID (tsVersionsToWorkshopList[vw][2], tsVersionsToWorkshopList[vw][4]);
                            checkInDesignRequest (tsVersionsToWorkshopList[vw][4]);
                            tsVersionsToWorkshopList.splice (vw, 1);
                            continue;
                        }
                        tsVersionsToWorkshopList[vw][3] = tsVersionsToWorkshopList[vw][2].length;
                    }
                }
                tsVersionsToWorkshopStep = 0;
            }
            //tsLinksLoadList[0] waiting list before check list
            //tsLinksLoadList[1] to be checked and to be requested list
            //tsLinksLoadList[2] requested list
            //tsLinksLoadList[crl][lll][0] counter
            //tsLinksLoadList[crl][lll][1] link tsIDVer
            //tsLinksLoadList[crl][lll][2] is to load actual file
            //tsLinksLoadList[crl][lll][3] creatorName
            
            tsLinksLoadStep++;
            if (tsLinksLoadStep > 5) {
                for (var lllc = tsLinksLoadList[0].length - 1; lllc >= 0; lllc--) {
                    tsLinksLoadList[0][lllc][0]++;
                    if (tsLinksLoadList[0][lllc][0] > 3) {
                        tsLinksLoadList[0][lllc][0] = 0;
                        tsLinksLoadList[1].push (tsLinksLoadList[0][lllc]);
                        tsLinksLoadList[0].splice (lllc, 1);
                    }
                }
                for (var lllr = tsLinksLoadList[1].length - 1; lllr >= 0; lllr--) {
                    var isToBeRequested = false;
                    var fileID_Path_newID = [tsLinksLoadList[1][lllr][1].slice (0, tsLinksLoadList[1][lllr][1].lastIndexOf ("/"))];
                    var pathTime = tsGetPath (fileID_Path_newID);
                    if (fileID_Path_newID[1]) {
                        var workshopFile = File (tsWorkshopPath + fileID_Path_newID[1]);
                        if (workshopFile.exists) {
                            if (tsLinksLoadList[1][lllr][2] && tsIsShade (workshopFile)) {
                                isToBeRequested = true;
                            }
                        }
                        else {
                            isToBeRequested = true;
                        }
                    }
                    else {
                        isToBeRequested = true;
                    }
                    if (isToBeRequested) {
                        tsLoadFile (tsLinksLoadList[1][lllr][1].slice (0, tsLinksLoadList[1][lllr][1].lastIndexOf ("/")), tsLinksLoadList[1][lllr][1].slice (tsLinksLoadList[1][lllr][1].lastIndexOf ("/") + 1), tsLinksLoadList[1][lllr][3], tsLinksLoadList[1][lllr][2]);
                    }
                    tsLinksLoadList[2].push (tsLinksLoadList[1][lllr]);
                    tsLinksLoadList[1].splice (lllr, 1);
                }
                if (tsLinksLoadList[2].length > 500) {
                    tsLinksLoadList[2].splice (0, tsLinksLoadList[2].length - 500);
                }
                tsLinksLoadStep = 0;
            }
        }
        if (tsMessagesCleanStep++ > 5260) {
            tsMessagesCleanStep = 0;
            if (tsScopesList.length != 0) {
                if (cleanningIndex == tsScopesList.length) {
                    cleanningIndex = 0;
                }
                var isOccupied = false;
                var isToWaitToNext = false;
                //check vacancy
                var cleanVacancyFile = new File (tsScopesList[cleanningIndex][1][5].parent.fsName.replace(/\\/g, '/') + "/cleanVacancy");
                if (cleanVacancyFile.exists) {
                    var cleanerName = readFile (cleanVacancyFile);
                    if (cleanerName != tsUserID) {
                        var nowTime = new Date ().getTime ();
                        if (nowTime - cleanVacancyFile.modified.getTime () > 10800000) {
                            isToWaitToNext = true;
                        }
                        else
                            isOccupied = true;
                    }
                }
                else {
                    isToWaitToNext = true;
                }
                
                if (!isOccupied) {
                    if (!isToWaitToNext) {
                        //clean Physical
                        tsIsPhysicalFinished = tsCleanPhysical (tsScopesList[cleanningIndex][3]);
                    }
                    writeFile (cleanVacancyFile, tsUserID);
                    cleanVacancyFile.hidden = true;
                }
                cleanningIndex++;
            }
        }
        //producing work sheet pdfs
        if (tsProducingWorkSheetSteps++ > 4687) { 
            tsProducingWorkSheetSteps = 0;
            var dailyFileContents = new Array ();
            for (var sl = 0; sl < tsScopesList.length; sl++) {
                var dailyReportFile = new File (tsScopesList[sl][1][5].parent.fsName.replace(/\\/g, '/') + "/Auto Work Time Reporting Settings");
                if (dailyReportFile.exists) {
                    var dailyFileContent = readEncodedFile (dailyReportFile);
                    if (dailyFileContent) {
                        dailyFileContents.push (dailyFileContent.split ("\n"));
                    }
                }
            }
            if (dailyFileContents.length > 0) {
                var isMonthlyProduced = false;
                var nowSheetTime = new Date ();
                var numberOfDays = 4;
                var dateSheets = new Array ();
                for (var nod = 1; nod <= numberOfDays; nod++) {
                    var dateSheet = new Date (nowSheetTime.getTime () - (86400000 * nod));
                    dateSheets.push (dateSheet);
                }
                for (var ds = 0; ds < dateSheets.length; ds++) {
                    var month = dateSheets[ds].getMonth () + 1;
                    var day = dateSheets[ds].getDate ();
                    var year = dateSheets[ds].getFullYear();
                    month = (month > 9)? month.toString () : "0" + month.toString ();
                    day = (day > 9)? day.toString () : "0" + day.toString ();
                    year = year.toString ();
                    for (var dfc = 0; dfc < dailyFileContents.length; dfc++) {
                        var messageLine = dailyFileContents[dfc][0] + "." + year + "." + month + "." + day;
                        var messageFile = new File (tsDataPath + "/Messages/DailySheets/" + messageLine);
                        if (messageFile.exists)
                            continue;
                        if (dailyFileContents[dfc][1].indexOf ("<TREE_PATH>") == 0)
                            dailyFileContents[dfc][1] = dailyFileContents[dfc][1].replace ("<TREE_PATH>", tsWorkshopPath);
                        var dayTotalFile = new File (tsDataPath + "/Sheets Summary/" + dailyFileContents[dfc][0] + "/" + year + "." + month + "." + day);
                        if (dayTotalFile.exists) {
                            continue;
                        }
                        if (!messageFile.parent.exists)
                            messageFile.parent.create ();
                    
                        var shiftBounds = dailyFileContents[dfc][2].split (",");
                        shiftBounds = shiftBounds[0];
                        shiftBounds = shiftBounds.split ("-");
                        shiftBounds[0] = shiftBounds[0].split (":");
                        shiftBounds[1] = shiftBounds[1].split (":");
                        var requestArray = new Array;
                        requestArray.push ("Work Time"); 
                        requestArray.push (year + "/" + month + "/" + day + "/" + shiftBounds[0][0] + "/" + shiftBounds[0][1]);
                        requestArray.push (year + "/" + month + "/" + day + "/" + shiftBounds[1][0] + "/" + shiftBounds[1][1]);
                        requestArray.push (dailyFileContents[dfc][0]);
                        var finalResult = getWorkingTable (requestArray);
                        finalResult = fillTimeGaps (finalResult);
                        writeEncodedFile (messageFile, tsUserName + "\n" + dailyFileContents[dfc][1] + "\n" + finalResult);
                        //monthly report
                        /*if (!isMonthlyProduced) {
                            if (nowSheetTime.getDate () < dateSheets[ds].getDate ()) { //it's new month
                                requestArray = new Array;
                                requestArray.push ("Work Time");
                                requestArray.push (year + "/" + month + "/" + "/01" + "/00" + "/00");
                                requestArray.push (year + "/" + month + "/" + day + "/23" + "/55");
                                requestArray.push (dailyFileContents[dfc][0]);
                                finalResult = getWorkingTable (requestArray);
                                messageLine = dailyFileContents[dfc][0] + "." + year + "." + month;
                                messageFile = new File (tsDataPath + "/Messages/DailySheets/" + messageLine);
                                writeEncodedFile (messageFile, tsUserName + "\n" + dailyFileContents[dfc][1] + "\n" + finalResult);
                                isMonthlyProduced = true;
                            }
                        }*/
                    }
                }
            }
        }
        if (tsScanningStep++ > 9) {
            tsScanningStep = 0;
            for (var oneLoop = 0; oneLoop < 1; oneLoop++) {
                if (!okNowYouCanQuit) {
                    var labourFile = new File (tsDataPath + "/Scanning/Labour");
                    writeFile (labourFile, tsClientID);
                }
                if (true) { //!app.isProcessingJob()
                    if (closingRequested) {
                        //finishing process
                        finalizeBeforeQuitOrChangeRoot (true);
                    }
                    else if (tsChangeRootRequested) {
                        finalizeBeforeQuitOrChangeRoot (false);
                    }
                    var isToAlert = true;
                    try {
                        app.document.navbars.filesystem.top.updatingLinks.text;
                    }
                    catch (e) { isToAlert = false; }
                    if (isToAlert) {
                        var updatingLinks = new Folder (tsDataPath + "/Messages/PDFPreview");
                        var linksCount = 0;
                        if (updatingLinks.exists) {
                            linksCount = updatingLinks.getFiles (isUnhiddenFile).length;
                        }
                        app.document.navbars.filesystem.top.updatingLinks.text = "To Check In: " + linksCount;
                        app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                        //switch to InDesign
                        if (tsIsSwitchWithInDesign && linksCount > 0) {
                            var nowTime = new Date().getTime();
                            if (nowTime - tsSelectionChangedByUserDate > 120000 && nowTime - lastSwitchingTime > 120000 && nowTime - tsLoadedPreviousDate > 120000) {
                                lastSwitchingTime = nowTime;
                                var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                                if (targetInDesign && targetInDesign.appStatus != "not installed") {
                                    var talkInDesign = new BridgeTalk;
                                    talkInDesign.target = targetInDesign;
                                    talkInDesign.body = "app.activate ();";
                                    talkInDesign.send ();
                                }
                            }
                        }
                    }
                    if (tsFoldersChanged.length == 0) {
                        if (!closingRequested) {
                            if (growingFolders.length == 0) {
                                /*if (!isOddStage && tsIsScanningStopped == 1) {
                                    break;
                                }*/
                                isOddStage = !isOddStage;
                                if (isOddStage) {
                                    realizeDeletedFiles (suspectedOdd);
                                    suspectedOdd = new Array;
                                }
                                else {
                                    realizeDeletedFiles (suspectedEven);
                                    suspectedEven = new Array;
                                }
                            }
                            else {
                            }
                            isBlackSide = !isBlackSide;
                            if (isBlackSide) {
                                if (tsIsScanningStopped == 2) {
                                    for (var sq = tsScanningQueue.length - 1; sq >= 0; sq--) {
                                        var blackFolder = new Folder (tsDataPath + "/Shots" + tsScanningQueue[sq]);
                                        if (blackFolder.exists) {
                                            getGlobalBlackChanges (blackFolder, true);
                                        }
                                    }
                                }
                                else {
                                    getGlobalBlackChanges (new Folder (tsDataPath + "/Shots"), false);
                                }
                            }
                            else {
                                if (tsIsScanningStopped == 2) {
                                    for (var sq = tsScanningQueue.length - 1; sq >= 0; sq--) {
                                        var whiteFolder = new Folder (tsWorkshopPath + tsScanningQueue[sq]);
                                        if (whiteFolder.exists)
                                            getGlobalWhiteChanges (whiteFolder, true);
                                    }
                                }
                                else {
                                    getGlobalWhiteChanges (new Folder (tsWorkshopPath), false);
                                }
                            } 
                            break;
                        }
                    }
                    else {
                    }
                    do {
                        var tempFolder = Folder (tsFoldersChanged[0]);
                        if (!tempFolder.exists) {
                            tsFoldersChanged.splice (0, 1);
                            updateProgress ();
                        }
                        else {
                            break;
                        }
                    } while (tsFoldersChanged.length > 0);
                    if (tsFoldersChanged.length > 0) {
                        shootFolder (Folder (tsFoldersChanged[0]));
                        tsFoldersChanged.splice (0, 1);
                        updateProgress ();
                    }
                }
                else {
                }
            }
        }
        if (tsDownloadingStep++ > 60) {
            tsDownloadingStep = 0;
            /**///$.writeln ($.line);
            //tsDownloadingList: 
            //[0] interval: determine the span which the file take to traited again
            //[1] counter: to the interval
            
            //[2] fileID with slashs
            //[3][0] version digits
            //[3][1][0] modificationTime
            //[3][1][1] isUpToDate
            //[3][2] isFinal
            //[3][3] oldVersionDigits
            //[3][4] senderID
            //[3][5] currentVersionDigits (pushed to the [3] array before checkOutFromCloud)
            //[3][6] name of the file (pushed to the [3] array before checkOutFromCloud)
            //[3][7] absolutePath of the file (pushed to the [3] array before checkOutFromCloud)
            //[3][8] version file (on versions folder) 
            //[3][9] version file (on versions folder) length (file size) for comparing to determine if it had completed copying to versions folder
            
            //[4][0] is version file downloaded
            //[4][1] version file
            //[4][2] file path
            //[4][3] is with thumbnail
            
            //InDesign files information
            
            //[5][0] is count file downloaded
            //[5][1] count file
            
            //[6][0] is pages folder downloaded
            //[6][1] pages folder
            
            //[7][0] are all pages downloaded
            //[7][1] array of the pages. [7][1][i] is a page no. i (this array is produced and added here)
            
            //[8][0] is prevPDF file downloaded
            //[8][1] prevPDF file
            var thisTime = new Date().getTime ();
            for (var d = tsDownloadingList.length - 1; d >= 0; d--) {
                if (tsDownloadingList[d][0] == tsDownloadingList[d][1]) {
                    tsDownloadingList[d][1] = 0;
                    var fileDotID = tsDownloadingList[d][2].replace (/\//g,"\.");
                    fileDotID = fileDotID.slice (1);
                    if (!tsDownloadingList[d][3][1][1]) { //the time is passed
                        //delete downloading message
                        var downloadingMessageFile = new File (tsDataPath + "/Messages/Downloading/" + fileDotID + ".ver" + tsDownloadingList[d][3][0] + "." + tsDownloadingList[d][3][1][0]);
                        downloadingMessageFile.remove ();
                        var downloadingWorkflowName = tsDownloadingList[d][4][2].replace (/\//g, " ➔ ");
                        downloadingWorkflowName = downloadingWorkflowName.slice (2);
                        var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                        downloadingWorkflowFile.remove ();
                        tsDownloadingList.splice (d, 1);
                        var isToAlert = true;
                        try {
                            app.document.navbars.filesystem.top.Downloading.text;
                        }
                        catch (e) { isToAlert = false; }
                        if (isToAlert) {
                            app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                        }
                        continue;
                    }

                    var isPDFDone = true;
                    var isCheckOutDone = true;
                    var isSecondaryStage = false;
                    
                    if (tsDownloadingList[d].length > 5) {
                        if (tsDownloadingList[d][8].length > 2) {
                            isSecondaryStage = true;
                            tsDownloadingList[d][8][2] += 1;
                            if (tsDownloadingList[d][8][1].exists) {
                                tsDownloadingList[d][8][1].copy (tsDownloadingList[d][8][3]);
                                
                                tsDownloadingList[d][8].splice (2, 2);
                            }
                            else {
                                isPDFDone = false;
                            }
                        }
                    }
                    if (tsDownloadingList[d][3].length > 5) {
                        isSecondaryStage = true;
                        var isCheckableNow = true;
                        var targetVersionPages;
                        var targetVersionPagesFolder;
                        var newLength = tsDownloadingList[d][3][8].length;
                        if (newLength  == tsDownloadingList[d][3][9]) { //copying to versions folder is completed
                            if (newLength > 0) {     
                                if (tsDownloadingList[d].length > 5) { //it is InDesign file
                                    if (tsDownloadingList[d][5].length > 1) {
                                        var zeroTempDigits = tsDownloadingList[d][3][0];
                                        if (tsVersionsOutputZero == "ONLY_ZERO") {
                                            zeroTempDigits = "00";
                                        }
                                        targetVersionPagesFolder = new Folder (tsVersionsPages + tsDownloadingList[d][3][7] + "/ver" + zeroTempDigits + " " + tsDownloadingList[d][3][6].slice (0, -5));
                                        targetVersionPages = targetVersionPagesFolder.getFiles (isUnhiddenFile);
                                        if (targetVersionPages.length != tsDownloadingList[d][7][1].length) {
                                            isCheckableNow = false;
                                        }
                                    }
                                }
                            }
                            else {
                                isCheckableNow = false;
                            }
                        }
                        else {
                            tsDownloadingList[d][3][9] = newLength;
                            isCheckableNow = false;
                        }
                        if (isCheckableNow) {
                            //changing CV
                            if (tsDownloadingList[d][3][0] != tsDownloadingList[d][3][5] || tsDownloadingList[d][3][10] != tsDownloadingList[d][3][2]) {
                                var currentVersionFile = new File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/CV");
                                if (!currentVersionFile.parent.exists)
                                    currentVersionFile.parent.create ();
                                writeFile (currentVersionFile, tsDownloadingList[d][3][0] + ":" + (tsDownloadingList[d][3][2]? "F" : "P"));
                            }
                            var verToworThumbnail = new Thumbnail (tsDownloadingList[d][3][8]);
                            tsVersionsToWorkshopItem = new Array; //to be added to tsVersionsToWorkshopList
                            tsVersionsToWorkshopItem.push (0); //tsVersionsToWorkshopList[x][0] count
                            tsVersionsToWorkshopItem.push (verToworThumbnail); //tsVersionsToWorkshopList[x][1] file to be copied thumbnail
                            tsVersionsToWorkshopItem.push (new File (tsWorkshopPath + tsDownloadingList[d][3][7] + "/" + tsDownloadingList[d][3][6])); //tsVersionsToWorkshopList[x][2] destination file
                            tsVersionsToWorkshopItem.push (null); //tsVersionsToWorkshopList[x][3] destination file length
                            tsVersionsToWorkshopItem.push (tsDownloadingList[d][2]); //tsVersionsToWorkshopList[x][4] fileID
                            tsVersionsToWorkshopItem.push (tsDownloadingList[d][3][1][0]); //tsVersionsToWorkshopList[x][5] Version Time
                            tsVersionsToWorkshopList.push (tsVersionsToWorkshopItem);
                            if (tsDownloadingList[d].length > 5) {
                                //copy pages
                                var workingPagesFolder = new Folder (tsPagesPath + "/Workshop" + tsDownloadingList[d][3][7] + "/" + tsDownloadingList[d][3][6]);
                                var oldPages = workingPagesFolder.getFiles (isUnhiddenFile);
                                for (var o = 0; o < oldPages.length; o++) {
                                    oldPages[o].remove ();
                                }
                                if (tsDownloadingList[d][5].length > 1) {
                                    var newPages = targetVersionPagesFolder.getFiles (isUnhiddenFile);
                                    if (newPages.length > 0) {
                                        workingPagesFolder.create ();
                                        for (var n = 0; n < newPages.length; n++) {
                                            newPages[n].copy (workingPagesFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (newPages[n].name));
                                        }
                                    }
                                }
                                //checkOutLinksRelations
                                var docID = tsDownloadingList[d][2].replace (/\//g,"\.");
                                docID = docID.slice (1);
                                var linksReportFile = new File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/Workshop/LinksReport");
                                var linksReportContent = readFile (linksReportFile);
                                var newReportContent = tsClientID;
                                if (linksReportContent) {
                                    var oldReportLines = linksReportContent.split ("\n");
                                    for (var c = 1; c < oldReportLines.length; c++) {
                                        var placingFile = new File (tsDataPath + "/IDs" + oldReportLines[c] + "/Workshop/Places/" + docID);
                                        placingFile.remove ();
                                    }
                                }
                                var versionLinksReportLines;
                                var versionLinksReportContent = readFile (File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/ver" + tsDownloadingList[d][3][0] + "/V/" + tsDownloadingList[d][3][1][0] + "/LinksReport"));
                                if (versionLinksReportContent) {
                                    versionLinksReportLines = versionLinksReportContent.split ("\n");
                                }
                                if (versionLinksReportLines) {
                                    newReportContent = versionLinksReportLines[0];
                                    for (var e = 1; e < versionLinksReportLines.length; e++) {
                                        var linkID = versionLinksReportLines[e].slice (0, versionLinksReportLines[e].lastIndexOf ("/"));
                                        newReportContent += "\n" + linkID;
                                        var placesFile = new File (tsDataPath + "/IDs" + versionLinksReportLines[e] + "/Places/" + docID + ".ver" + tsDownloadingList[d][3][0] + "." + tsDownloadingList[d][3][1][0]);
                                        var workingLinkRecordFile = new File (tsDataPath + "/IDs" + linkID + "/Workshop/Places/" + docID);
                                        if (!workingLinkRecordFile.parent.exists)
                                            workingLinkRecordFile.parent.create ();
                                        placesFile.copy (workingLinkRecordFile);
                                    }
                                }
                                if (!linksReportFile.parent.exists)
                                    linksReportFile.parent.create ();
                                writeFile (linksReportFile, newReportContent);
                            }
                            tsDownloadingList[d][3].splice (5);
                        }
                        else {
                            isCheckOutDone = false;
                        }
                    }
                    if (isSecondaryStage) {
                        if (isPDFDone && isCheckOutDone) {
                            var waitingFile = new File (tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').slice (0, tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/Waited/" + tsUserID);
                            if (waitingFile.fsName.replace(/\\/g, '/').indexOf ("/Dialogs/") == -1 && waitingFile.fsName.replace(/\\/g, '/').indexOf ("/.Pairs/") == -1) {
                                waitingFile.remove ();
                            }
                            else {
                                deleteForcelyFolders (waitingFile.parent.parent, true);
                            }
                            var downloadingWorkflowName = tsDownloadingList[d][4][2].replace (/\//g, " ➔ ");
                            downloadingWorkflowName = downloadingWorkflowName.slice (2);
                            var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                            downloadingWorkflowFile.remove ();
                            tsDownloadingList.splice (d, 1);
                            var isToAlert = true;
                            try {
                                app.document.navbars.filesystem.top.Downloading.text;
                            }
                            catch (e) { isToAlert = false; }
                            if (isToAlert) {
                                app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                            }
                            continue;
                        }
                    }
                    else {
                        //test existing of files
                        var isAllExist = true;
                        var isCheckable = true;
                        if (!tsDownloadingList[d][4][0]) {
                            if (tsDownloadingList[d][4][1].exists) {
                                tsDownloadingList[d][4][0] = true;
                            }
                            else {
                                isAllExist = false;
                                isCheckable = false;
                            }
                        }
                        if (tsDownloadingList[d].length > 5) { //It's InDesign File
                            if (!tsDownloadingList[d][5][0]) {
                                if (tsDownloadingList[d][5][1].exists) {
                                    tsDownloadingList[d][5][0] = true;
                                    var count = readFile (tsDownloadingList[d][5][1]);
                                    if (count) {
                                        tsDownloadingList[d][5].push (count);
                                    }
                                }
                                else {
                                    isAllExist = false;
                                    isCheckable = false;
                                }
                            }
                            if (tsDownloadingList[d][5].length > 1) {
                                if (!tsDownloadingList[d][6][0]) {
                                    if (tsDownloadingList[d][6][1].exists) {
                                        tsDownloadingList[d][6][0] = true;
                                    }
                                    else {
                                        isAllExist = false;
                                        isCheckable = false;
                                    }
                                }
                                if (!tsDownloadingList[d][7][0]) {
                                    if (tsDownloadingList[d][5][0] && tsDownloadingList[d][6][0]) {
                                        var allPages = tsDownloadingList[d][6][1].getFiles (isAcceptedSyncedFile);
                                        var count = null;
                                        if (tsDownloadingList[d][5].length > 2) {
                                            count = tsDownloadingList[d][5][2];
                                        }
                                        if (!count) {
                                            count = readFile (tsDownloadingList[d][5][1]);
                                            if (!count) {
                                                /*Error*/$.writeln ("Error " + $.line);
                                                continue;
                                            }
                                        }
                                        count = parseInt (count, 10);
                                        if (allPages.length == count) {
                                            tsDownloadingList[d][7][0] = true;
                                            tsDownloadingList[d][7].push (allPages);
                                        }
                                    }
                                    if (!tsDownloadingList[d][7][0]) {
                                        isAllExist = false;
                                        isCheckable = false;
                                    }
                                }
                            }
                            if (!tsDownloadingList[d][8][0]) {
                                if (tsDownloadingList[d][8][1].exists) {
                                    tsDownloadingList[d][8][0] = true;
                                }
                                else {
                                    isAllExist = false;
                                }
                            }
                        }
                        if (isCheckable) { //Copy and may checkout to working version
                            var fileID_Path_newID = [tsDownloadingList[d][2]];
                            tsGetPath (fileID_Path_newID);
                            var isToFinish = true;
                            if (fileID_Path_newID[1]) {
                                var fileName = fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1);
                                var absolutePath = fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/"));
                                
                                //copying version file
                                var targetVersionFile = new File (tsVersionsPath + absolutePath + "/ver" + tsDownloadingList[d][3][0] + " " + fileName);
                                if (targetVersionFile.exists) {
                                    targetVersionFile.readonly = false;
                                    targetVersionFile.remove ();
                                }
                                else {
                                    Folder (tsVersionsPath + absolutePath).create ();
                                }
                                var toCopyThumbnail = new Thumbnail (tsDownloadingList[d][4][1]);
                                if (tsDownloadingList[d][4][1].length > 500000000) {
                                    tsCopyToList.push ([toCopyThumbnail, Folder (tsVersionsPath + absolutePath), "ver" + tsDownloadingList[d][3][0] + " " + fileName]);
                                }
                                else {
                                    try {
                                        toCopyThumbnail.copyTo (Folder (tsVersionsPath + absolutePath));
                                    }
                                    catch (error) {
                                        /*Error*/$.writeln (error); 
                                        /*Error*/$.writeln ("Line: " + $.line);
                                        /*Error*/$.writeln (tsVersionsPath + absolutePath + "/ver" + tsDownloadingList[d][3][0] + " " + fileName);
                                        /*Error*/$.writeln (tsDownloadingList[d][4][1] instanceof File);
                                        /*Error*/$.writeln (tsDownloadingList[d][4][1].exists);
                                        /*Error*/$.writeln (tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/'));
                                    }
                                    File (tsVersionsPath + absolutePath + "/File").rename ("ver" + tsDownloadingList[d][3][0] + " " + fileName);
                                }
                                targetVersionFile = new File (tsVersionsPath + absolutePath + "/ver" + tsDownloadingList[d][3][0] + " " + fileName);
                                
                                //if InDesign
                                if (tsDownloadingList[d].length > 5) {
                                    //cleaning Pages
                                    if (tsVersionsOutputZero != "ONLY_ZERO") {
                                        var pagesFolder = new Folder (tsVersionsPages + absolutePath + "/ver" + tsDownloadingList[d][3][0] + " " + fileName.slice (0, -5));
                                        if (pagesFolder.exists) {
                                            var oldPages = pagesFolder.getFiles ();
                                            for (var o = 0; o < oldPages.length; o++) {
                                                oldPages[o].remove ();
                                            }
                                        }
                                        if (tsDownloadingList[d][5].length > 1) {
                                            //copying pages
                                            if (!pagesFolder.exists) {
                                                pagesFolder.create ();
                                            }
                                            for (var pg = 0;pg < tsDownloadingList[d][7][1].length; pg++) {
                                                tsDownloadingList[d][7][1][pg].copy (File (pagesFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (tsDownloadingList[d][7][1][pg].name)));
                                            }
                                        }
                                    }
                                    if (tsVersionsOutputZero == "ONLY_ZERO" || tsVersionsOutputZero == "WITH_ZERO") {
                                        var pagesZeroFolder = new Folder (tsVersionsPages + absolutePath + "/ver00" + " " + fileName.slice (0, -5));
                                        if (pagesZeroFolder.exists) {
                                            var oldPages = pagesZeroFolder.getFiles ();
                                            for (var o = 0; o < oldPages.length; o++) {
                                                oldPages[o].remove ();
                                            }
                                        }
                                        if (tsDownloadingList[d][5].length > 1) {
                                            //copying pages
                                            if (!pagesZeroFolder.exists) {
                                                pagesZeroFolder.create ();
                                            }
                                            for (var pg = 0;pg < tsDownloadingList[d][7][1].length; pg++) {
                                                tsDownloadingList[d][7][1][pg].copy (File (pagesZeroFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (tsDownloadingList[d][7][1][pg].name)));
                                            }
                                        }
                                    }                                    
                                    //cleaning PrevPDF
                                    var prevPDFFile = new File (tsVersionsPDFPath + absolutePath + "/ver" + tsDownloadingList[d][3][0] + " " +  fileName.slice (0, fileName.lastIndexOf (".")) + ".pdf");
                                    if (!prevPDFFile.parent.exists)
                                        prevPDFFile.parent.create ();
                                    else
                                        prevPDFFile.remove ();
                                    
                                    if (isAllExist) {
                                        //copying PrevPDF
                                        if (tsDownloadingList[d][8].length > 1) {
                                            if (!prevPDFFile.parent.exists)
                                                prevPDFFile.parent.create ();
                                            tsDownloadingList[d][8][1].copy (prevPDFFile);
                                        }  
                                    }
                                    else {
                                        //add third cell to 8th tsDownloadingList element as a mark
                                        isToFinish = false;
                                        tsDownloadingList[d][8].push (0);
                                        tsDownloadingList[d][8].push (prevPDFFile);
                                    }
                                }
                                
                                //tsCheckOut if final or update working if it is current version
                                //[2] fileTitleSplitted[1] or fileID with slashs
                                //[3][0] version digits
                                //[3][1][0] modificationTime
                                //[3][1][1] isUpToDate 
                                var isOverTime = false;
                                for (var ve = 0; ve < tsDownloadingList.length; ve++) {
                                    if (ve != d) {
                                        if (tsDownloadingList[ve][3][1][1]) {
                                            if (tsDownloadingList[ve][2] == tsDownloadingList[d][2]) {
                                                if (tsDownloadingList[ve][3][0] == tsDownloadingList[d][3][0]) {
                                                    if (tsDownloadingList[ve][3][1][0] >= tsDownloadingList[d][3][1][0]) {
                                                        isOverTime = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }                   
                            
                                if (!isOverTime) {
                                    var isToUpdateWorkshop = false;                            
                                    var currentVersionRecordFile = new File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/CV");
                                    var isOldFinal = false;
                                    var currentVersionDigits = readFile (currentVersionRecordFile);
                                    if (!currentVersionDigits)
                                        currentVersionDigits = "New";
                                    else {
                                        var splittedCV = currentVersionDigits.split (":");
                                        currentVersionDigits = splittedCV[0];
                                        isOldFinal = (splittedCV[1] == "F"? true : false);
                                    }                             

                                    if (currentVersionDigits == tsDownloadingList[d][3][0]) {
                                        isToUpdateWorkshop = true;
                                    }
                                    else {
                                        //getting current version time
                                        var currentVersionTime = 0;
                                        if (currentVersionDigits != "New") {
                                            var currentVersionTimeFile = new File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/ver" + currentVersionDigits + "/Modifying Time");
                                            currentVersionTime = readFile (currentVersionTimeFile);
                                            if (currentVersionTime) {
                                                currentVersionTime = parseInt (currentVersionTime, 10);
                                                if (tsDownloadingList[d][3][1][0] > currentVersionTime) {
                                                    var underEditingFile = new File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/ver" + currentVersionDigits + "/V/" + currentVersionTime + "/UnderEditing");
                                                    if (!underEditingFile.exists)
                                                        isToUpdateWorkshop = true;
                                                }
                                            }
                                        }
                                        else {
                                            isToUpdateWorkshop = true;
                                        }
                                    }
                                
                                    //Workflow/Checked In
                                    var checkedInRootFolder = Folder (tsRootFolderPath + "/Workflow/Checked In");
                                    var checkedInDate = new Date (tsDownloadingList[d][3][1][0]);
                                    var month = checkedInDate.getMonth () + 1;
                                    var day = checkedInDate.getDate ();
                                    var hours = checkedInDate.getHours();
                                    var minutes = checkedInDate.getMinutes();
                                    month = month > 9? month.toString () : "0" + month.toString ();
                                    day = day > 9? day.toString () : "0" + day.toString ();
                                    var AmPm = "am";
                                    if (hours > 12) {
                                        AmPm = "pm";
                                        hours = hours - 12;
                                    }
                                    hours = hours > 9? hours.toString () : "0" + hours.toString ();
                                    minutes = minutes > 9? minutes.toString () : "0" + minutes.toString ();
                                    var dayName;
                                    switch (checkedInDate.getDay ()) {
                                        case 0:
                                            dayName = "Sunday";
                                            break;
                                        case 1:
                                            dayName = "Monday";
                                            break;
                                        case 2:
                                            dayName = "Tuesday";
                                            break;
                                        case 3:
                                            dayName = "Wednesday";
                                            break;
                                        case 4:
                                            dayName = "Thursday";
                                            break;
                                        case 5:
                                            dayName = "Friday";
                                            break;
                                        case 6:
                                            dayName = "Saturday";
                                            break;
                                    }
                                
                                    var recipientIndex = tsGetRecipientIndex ();
                                    var senderName = tsDownloadingList[d][3][4];
                                    if (recipientIndex != -1)
                                        senderName = recipientsList[recipientIndex][5];
                                    
                                    var shortcutFile = new File (checkedInRootFolder.fsName.replace(/\\/g, '/') + "/" + checkedInDate.getFullYear() + "." + month + "/" + day + "." + dayName + "/" + senderName + targetVersionFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, ""));
                                    shortcutFile.parent.create ();
                                    shortcutFile.createAlias (targetVersionFile);
                                                                        
                                    //Producing Thumbnail
                                    if (isCSFile (targetVersionFile) && !tsDownloadingList[d][4][3]) {
                                        //tsCheckedInThumbnailsList[x][0] counter
                                        //tsCheckedInThumbnailsList[x][1] version File then Thumbnail
                                        //tsCheckedInThumbnailsList[x][2] thumbnailFile
                                        //tsCheckedInThumbnailsList[x][3] workingThumbnailFile
                                        var workingThumbnailFile = null;
                                        if (isToUpdateWorkshop) {
                                            workingThumbnailFile = new File (tsWorkshopPath + absolutePath + tsGetTreeShadeThumb (fileName) + fileName + ".jpg");
                                        }
                                        var checkedInThumbnailsItem = new Array;
                                        checkedInThumbnailsItem.push (0);
                                        checkedInThumbnailsItem.push (targetVersionFile);
                                        var thumbnailFile = new File (tsDataPath + "/IDs" + tsDownloadingList[d][2] + "/ver" + tsDownloadingList[d][3][0] + "/V/" + tsDownloadingList[d][3][1][0] + "/Thumbnail.jpg");
                                        checkedInThumbnailsItem.push (thumbnailFile);
                                        checkedInThumbnailsItem.push (workingThumbnailFile);
                                        tsCheckedInThumbnailsList.push (checkedInThumbnailsItem);
                                    }
                            
                                    if (isToUpdateWorkshop) {
                                        isToFinish = false;
                                        tsDownloadingList[d][3].push (currentVersionDigits);
                                        tsDownloadingList[d][3].push (fileName);
                                        tsDownloadingList[d][3].push (absolutePath);
                                        tsDownloadingList[d][3].push (targetVersionFile);
                                        tsDownloadingList[d][3].push (targetVersionFile.length);
                                        tsDownloadingList[d][3].push (isOldFinal);
                                    }
                                }
                            }
                            //delete downloading message
                            var downloadingMessageFile = new File (tsDataPath + "/Messages/Downloading/" + fileDotID + ".ver" + tsDownloadingList[d][3][0] + "." + tsDownloadingList[d][3][1][0]);
                            downloadingMessageFile.remove ();
                            var downloadingWorkflowName = tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').replace (tsVersionsPath, "") + File.decode (tsDownloadingList[d][4][1].name).slice (6);
                            downloadingWorkflowName = downloadingWorkflowName.slice (2);
                            var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                            downloadingWorkflowFile.remove ();
                            
                            //removing Waited Mark if it was required
                            if (isToFinish) {
                                var waitingFile = new File (tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').slice (0, tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/Waited/" + tsUserID);
                                if (waitingFile.fsName.replace(/\\/g, '/').indexOf ("/Dialogs/") == -1 && waitingFile.fsName.replace(/\\/g, '/').indexOf ("/.Pairs/") == -1) {
                                    waitingFile.remove ();
                                }
                                else {
                                    deleteForcelyFolders (waitingFile.parent.parent, true);
                                }
                                var downloadingWorkflowName = tsDownloadingList[d][4][2].replace (/\//g, " ➔ ");
                                downloadingWorkflowName = downloadingWorkflowName.slice (2);
                                var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                                downloadingWorkflowFile.remove ();
                                tsDownloadingList.splice (d, 1);
                                var isToAlert = true;
                                try {
                                    app.document.navbars.filesystem.top.Downloading.text;
                                }
                                catch (e) { isToAlert = false; }
                                if (isToAlert) {
                                    app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                                }
                                continue;
                            }
                        }
                    }
                    if (tsDownloadingList[d][3].length < 6) {
                        // delete downloading item if it was on process from long time (more than a day)
                        if (thisTime - tsDownloadingList[d][3][1][0] > 86400000) {
                            //delete downloading message
                            var waitingFile = new File (tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').slice (0, tsDownloadingList[d][4][1].fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/Waited/" + tsUserID);
                            if (waitingFile.fsName.replace(/\\/g, '/').indexOf ("/Dialogs/") == -1 && waitingFile.fsName.replace(/\\/g, '/').indexOf ("/.Pairs/") == -1) {
                                waitingFile.remove ();
                            }
                            else {
                                deleteForcelyFolders (waitingFile.parent.parent, true);
                            }
                            var downloadingMessageFile = new File (tsDataPath + "/Messages/Downloading/" + fileDotID + ".ver" + tsDownloadingList[d][3][0] + "." + tsDownloadingList[d][3][1][0]);
                            downloadingMessageFile.remove ();
                            var downloadingWorkflowName = tsDownloadingList[d][4][2].replace (/\//g, " ➔ ");
                            downloadingWorkflowName = downloadingWorkflowName.slice (2);
                            var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                            downloadingWorkflowFile.remove ();
                            tsDownloadingList.splice (d, 1);
                            var isToAlert = true;
                            try {
                                app.document.navbars.filesystem.top.Downloading.text;
                            }
                            catch (e) { isToAlert = false; }
                            if (isToAlert) {
                                app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                            }
                            continue;
                        }
                    }
                    if (tsDownloadingList[d][0] < 4)
                        tsDownloadingList[d][0] = tsDownloadingList[d][0] + 1;
                }
                tsDownloadingList[d][1] = tsDownloadingList[d][1] + 1;
            }
        }
        if (tsMessagesScanStep != -1 && tsMessagesScanStep++ > 8) {
            tsMessagesScanStep = 0;
            if (tsIsMessagesStoped) {
                if (InDesignCheckInList.length == 0 && tsLiveSnippetCheckInList.length == 0 && !isThereMessages && tsIsSendingDone) {
                    tsMessagesScanStep = -1;
                }
            }
            if (true) { //!app.isProcessingJob()
                //InDesign Delete Request
                var deleteMessageFiles = Folder (tsDataPath + "/Messages/To Delete").getFiles (isUnhiddenFile);
                for (var df = 0; df < deleteMessageFiles.length; df++) {
                    var fileDotID = File.decode (deleteMessageFiles[df].name);
                    var fileID = "/" + fileDotID.replace (/\./g, "\/");
                    var fileID_Path_newID = [fileID];
                    tsGetPath (fileID_Path_newID);
                    if (fileID_Path_newID[1]) {
                        var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                        tsMoveToTrash (workshopFile, 1, null, true, fileID, false);
                    }
                    deleteMessageFiles[df].remove ();
                }
            
                //InDesign Loading Request
                var loadMessageFiles = Folder (tsDataPath + "/Messages/To Load").getFiles (isUnhiddenFile);
                for (var mf = 0; mf < loadMessageFiles.length; mf++) {
                    var isRequestDone = false;
                    var fileDotID = File.decode (loadMessageFiles[mf].name);
                    var fileID = "/" + fileDotID.replace (/\./g, "\/");
                    var fileID_Path_newID = [fileID];
                    tsGetPath (fileID_Path_newID);
                    if (fileID_Path_newID[1]) {
                        var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                        
                        var currentVersionDigitsFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                        var currentVersionDigits = readFile (currentVersionDigitsFile);
                        if (currentVersionDigits) {
                            currentVersionDigits = currentVersionDigits.split (":")[0];
                            var currentVersionFile = new File (workshopFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + currentVersionDigits + " " + File.decode (workshopFile.name));
                            var isAlreadyExist = false;
                            if (currentVersionFile.exists) {
                                if (!tsIsShade (currentVersionFile)) {
                                    isAlreadyExist = true;
                                }
                            }
                            if (!isAlreadyExist) {
                                tsLoadVersionFile (currentVersionFile, fileID, true);
                                isRequestDone = true;
                            }
                        }
                        else {
                            var creatorFile = new File (tsDataPath + "/IDs" + fileID + "/Creator");
                            var creatorName = readFile (creatorFile);
                            if (creatorName) {
                                tsLoadFile (fileID, null, creatorName, true);
                                isRequestDone = true;
                            }
                        } 
                    }
                    if (isRequestDone) {
                        InDesignLoadList.push (fileID);
                    }
                    loadMessageFiles[mf].remove ();
                }
            
                //Live Snippet tsCheckIn Request
                var liveSnippetMessagesFile = Folder (tsDataPath + "/Messages/To CheckIn Live Snippet").getFiles (isUnhiddenFile);
                for (var smf = 0; smf < liveSnippetMessagesFile.length; smf++) {
                    var LSMcontent = readEncodedFile (liveSnippetMessagesFile[smf]);
                     if (!LSMcontent)
                        continue;
                    
                    var liveSnippetCheckInItem = new Array;
                    liveSnippetCheckInItem.push (-10);
                    var liveSnippetFile = new File (LSMcontent);
                    var fileID = tsGetID (liveSnippetFile);
                    if (!fileID)
                        tsUpdateFileState (liveSnippetFile, -2, -1);
                    liveSnippetCheckInItem.push (liveSnippetFile);
                    tsLiveSnippetCheckInList.push (liveSnippetCheckInItem);
                    liveSnippetMessagesFile[smf].remove ();
                }
            
                for (var scl = 0; scl < tsLiveSnippetCheckInList.length; scl++) {
                    tsLiveSnippetCheckInList[scl][0] ++;
                    if (tsLiveSnippetCheckInList[scl][0] == 0) {
                        var digitsFileIDTriple = getWorkshopVersionInfo (tsLiveSnippetCheckInList[scl][1], null);
                        if (digitsFileIDTriple)
                            tsCheckIn (tsLiveSnippetCheckInList[scl][1], digitsFileIDTriple, false, true, true, true, false, true, null);
                        tsLiveSnippetCheckInList.splice (scl, 1);
                    }
                }

                //tsAutoCheckInFilesList
                //tsAutoCheckInFilesList[acfl][0] File ID
                //tsAutoCheckInFilesList[acfl][1] Relation Method (Reference code or 'PLACING_DOCS')
                //tsAutoCheckInFilesList[acfl][2] Duplicate Source if the relation file is missed (File ID)
                //tsAutoCheckInFilesList[acfl][3] 'C' create new, 'P' path change, 'D' delete, 'M' modification, combinations 'CPDM', 'CD', 'PM'... 
                //tsAutoCheckInFilesList[acfl][4] File Object
                //tsAutoCheckInFilesList[acfl][5] last modified date, if null then it's added to be path once
                //tsAutoCheckInFilesList[acfl][6] is path changed or file deleted... true or false
                if (tsAutoCheckInFilesStep >= tsAutoCheckInFilesList.length) {
                    tsAutoCheckInFilesStep = 0;
                }
                else {
                    var fromDownIndex = tsAutoCheckInFilesStep + tsAutoCheckInFilesStepWide;
                    if (fromDownIndex >= tsAutoCheckInFilesList.length) {
                        fromDownIndex = tsAutoCheckInFilesList.length - 1;
                    }
                    for (var acfl = fromDownIndex; acfl >= tsAutoCheckInFilesStep; acfl--) {
                        var fileID = tsAutoCheckInFilesList[acfl][0];
                        var isToSkip = false;
                        for (var om = 0; om < tsOldModifiedFileIDList.length; om++) {
                            if (tsOldModifiedFileIDList[om][2] == fileID) {
                                isToSkip = true;
                                break;
                            }
                        }
                        if (isToSkip)
                            continue;
                        var isToProccess = false;
                        var isAutoCheckInDeleted = false;
                        var isAutoCheckInNew = false;
                        var isAutoCheckInPathChanged = false;
                        var oldFileToBeRemoved = null;
                        var isRemoveMark = (tsAutoCheckInFilesList[acfl][3].search (/R/i) != -1);
                        if (tsAutoCheckInFilesList[acfl][6] == null) {
                            isAutoCheckInNew = true;
                            tsAutoCheckInFilesList[acfl][6] = false;
                            if (tsAutoCheckInFilesList[acfl][3].search (/C/i) != -1) {
                                isToProccess = true;
                            }
                        }
                        var targetFile = tsAutoCheckInFilesList[acfl][4];
                        var currentVersion = null;
                        if (!targetFile.exists || tsAutoCheckInFilesList[acfl][6]) {
                            var fileID_Path_newID = [fileID];
                            tsGetPath (fileID_Path_newID);
                            if (fileID_Path_newID[1]) {
                                var newLocationFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                if (!newLocationFile.exists) {
                                    continue;
                                }
                                if (newLocationFile.fsName.replace(/\\/g, '/') != targetFile.fsName.replace(/\\/g, '/')) { //the file path changed
                                    isAutoCheckInPathChanged = true;
                                    oldFileToBeRemoved = targetFile;
                                    targetFile = newLocationFile;
                                    tsAutoCheckInFilesList[acfl][4] = newLocationFile;

                                    if (tsAutoCheckInFilesList[acfl][3].search (/P/i) != -1) {
                                        isToProccess = true;
                                    }
                                }
                                else if (!targetFile.exists) {
                                    continue;
                                }
                            }
                            else { //the file is deleted
                                isAutoCheckInDeleted = true;
                                oldFileToBeRemoved = targetFile;
                                if (tsAutoCheckInFilesList[acfl][3].search (/D/i) != -1) {
                                    isToProccess = true;
                                }
                            }
                            tsAutoCheckInFilesList[acfl][6] = false;
                        }
                        if (oldFileToBeRemoved) {
                            //remove old mark
                            var toRemoveMarkFilePath = oldFileToBeRemoved.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                            toRemoveMarkFilePath = toRemoveMarkFilePath.slice (1);
                            toRemoveMarkFilePath = toRemoveMarkFilePath.replace (/\//g, " ➔ ");                        
                            var toRemoveMarkFile = new File (tsRootFolderPath + "/Workflow/Auto Check In Files/" + toRemoveMarkFilePath);
                            toRemoveMarkFile.remove ();
                        }
                        if (targetFile.exists && tsAutoCheckInFilesList[acfl][3].search (/M/i) != -1) {
                            var toComparedTime = 0;
                            if (tsAutoCheckInFilesList[acfl][5] == 0) {
                                var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                                currentVersion = readFile (currentRecordFile);
                                if (currentVersion) {
                                    currentVersion = currentVersion.split (":")[0];
                                    var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersion + "/Modifying Time");
                                    var versionTime = readFile (versionTimeFile);
                                    if (versionTime) {
                                        toComparedTime = parseInt (versionTime, 10);
                                    }
                                }
                            }
                            else {
                                toComparedTime = tsAutoCheckInFilesList[acfl][5];
                            }
                            var actualModified = tsGetActualModified (targetFile.modified.getTime (), fileID);
                            if (actualModified > toComparedTime) {
                                isToProccess = true;
                            }
                            tsAutoCheckInFilesList[acfl][5] = actualModified;
                        }
                        if (!isToProccess) {
                            isRemoveMark = false;
                        }
                        if (isAutoCheckInPathChanged || isAutoCheckInNew || isRemoveMark) {
                            //add new mark
                            var toAddMarkFilePath = targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                            toAddMarkFilePath = toAddMarkFilePath.slice (1);
                            toAddMarkFilePath = toAddMarkFilePath.replace (/\//g, " ➔ ");                        
                            var toAddMarkFile = new File (tsRootFolderPath + "/Workflow/Auto Check In Files/" + toAddMarkFilePath);
                            if (isRemoveMark) {
                                toAddMarkFile.remove ();
                                if (tsAutoCheckInFilesList[acfl][3].search (/RR/i) != -1) {
                                    var autoCheckInMarkFile = new File (tsDataPath + "/IDs" + fileID + "/Auto Check In Mark");
                                    autoCheckInMarkFile.remove ();
                                }
                            }
                            else {
                                writeEncodedFile (toAddMarkFile, tsAutoCheckInFilesList[acfl][0] + "\n" + tsAutoCheckInFilesList[acfl][1] + "\n" + tsAutoCheckInFilesList[acfl][2] + "\n" + tsAutoCheckInFilesList[acfl][3]);
                            }
                        }
                        if (isToProccess) {
                            var isNotToCheckIn = false;
                            var isToDeleteDestination = false;
                            if (targetFile.exists) {
                                if (tsAutoCheckInFilesList[acfl][1].search (/<DNC>/i) != -1) {
                                    isNotToCheckIn = true;
                                }
                                else {
                                    //check in
                                    var digitsFileIDTriple = new Array;
                                    if (currentVersion == null) {
                                        var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                                        currentVersion = readFile (currentRecordFile);
                                        if (currentVersion) {
                                            currentVersion = currentVersion.split (":")[0];
                                        }
                                    }
                                    currentVersion = currentVersion? currentVersion : "01";
                                    digitsFileIDTriple.push (currentVersion);
                                    digitsFileIDTriple.push (File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + currentVersion + " " + File.decode (targetFile.name)));
                                    digitsFileIDTriple.push (fileID);
                                    tsCheckIn (targetFile, digitsFileIDTriple, false, true, true, true, false, false, null);
                                }
                            }

                            var docsIDsPairs = new Array;
                            if (tsAutoCheckInFilesList[acfl][1] == "PLACING_DOCS") {
                                var docsIDsList = retrievePlacingDocsIDs (fileID);
                                if (isToDeleteDestination && isAutoCheckInDeleted) {
                                    for (var dil = 0; dil < docsIDsList.length; dil++) {
                                        var docID_Path_newID = [docsIDsList[dil]];
                                        tsGetPath (docID_Path_newID);
                                        if (docID_Path_newID[1]) {
                                            var targetDocFile = new File (tsWorkshopPath + docID_Path_newID[1]);
                                            if (targetDocFile.exists) {
                                                tsMoveToTrash (targetDocFile, 1, null, true, null, false);
                                            }
                                        }
                                    }
                                }
                                else {
                                    for (var dil = 0; dil < docsIDsList.length; dil++) {
                                        docsIDsPairs.push ([null, docsIDsList[dil]]);
                                    }
                                }
                            }
                            else {
                                var relationPath = tsAutoCheckInFilesList[acfl][1];
                                var sourceRelationFiles = null;
                                var sourceStartID = null;
                                var sourceStartFile = null;
                                var sourceDeterminer = tsAutoCheckInFilesList[acfl][2];
                                var selectFileID = "";
                                var isToOverwriteDestination = false;
                                if (sourceDeterminer.indexOf == ":") {
                                    selectFileID = sourceDeterminer.slice (sourceDeterminer.indexOf (":") + 1);
                                    selectFileID = "/" + selectFileID.replace (/\./g, "\/");
                                    sourceDeterminer = sourceDeterminer.slice (0, sourceDeterminer.indexOf (":"));
                                }
                                if (sourceDeterminer.search (/<O>/i) != -1) {
                                    var originalID = readFile (File (tsDataPath + "/IDs" + fileID + "/Original ID"));
                                    if (originalID) {
                                        sourceStartID = originalID;
                                    }
                                    sourceDeterminer = sourceDeterminer.replace (/<O>/i, "");
                                }
                                else if (sourceDeterminer.search (/<P>/i) != -1) {
                                    var previousID = null;
                                    if (tsAutoCheckInFilesList[acfl][6] || tsAutoCheckInFilesList[acfl][7]) {
                                        sourceStartFile = new File (tsWorkshopPath + tsAutoCheckInFilesList[acfl][7]);
                                    }
                                    else {
                                        previousID = readFile (File (tsDataPath + "/IDs" + fileID + "/Previous ID"));
                                        if (previousID) {
                                            sourceStartID = previousID;
                                        }
                                    }
                                    sourceDeterminer = sourceDeterminer.replace (/<P>/i, "");
                                }
                                else if (sourceDeterminer.search (/<C>/i) != -1) {
                                    if (File.decode (targetFile.name).slice (-4) == ".txt") {
                                        var autoCheckInContent = readFile (targetFile);
                                        if (autoCheckInContent) {
                                            sourceStartID = "/" + autoCheckInContent.replace (/\./g, "\/");
                                        }
                                    }
                                    sourceDeterminer = sourceDeterminer.replace (/<C>/i, "");
                                }
                                else if (sourceDeterminer.search (/<S>/i) != -1) {
                                    sourceStartID = selectFileID;
                                    sourceDeterminer = sourceDeterminer.replace (/<S>/i, "");
                                }
                                if (!sourceStartFile) {
                                    if (!sourceStartID) {
                                        sourceStartFile = targetFile;
                                    }
                                    else {
                                        var fileID_Path_newID = [sourceStartID];
                                        tsGetPath (fileID_Path_newID);
                                        if (fileID_Path_newID[1]) {
                                            sourceStartFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                        }
                                    }

                                }
                                if (sourceStartFile) {
                                    var relativeSourcePath = solveSourcePath (sourceStartFile, sourceDeterminer);
                                    var relativeSourceFolder = Folder (relativeSourcePath.slice (0, relativeSourcePath.lastIndexOf ("/")));
                                    if (relativeSourceFolder instanceof Folder) {
                                        if (relativeSourceFolder.exists) {
                                            var relativeSourceFile = relativeSourceFolder.getFiles (relativeSourcePath.slice (relativeSourcePath.lastIndexOf ("/") + 1));
                                            if (relativeSourceFile.length > 0) {
                                                sourceRelationFiles = relativeSourceFile;
                                            }
                                        }
                                    }
                                }
                                if (relationPath) {
                                    if (relationPath.search (/<DNC>/i) != -1) {
                                        relationPath = relationPath.replace (/<DNC>/i, "");
                                    }
                                    if (relationPath.search (/<DD>/i) != -1) {
                                        relationPath = relationPath.replace (/<DD>/i, "");
                                        isToDeleteDestination = true;
                                    }
                                    if (relationPath.search (/<CO>/i) != -1) {
                                        relationPath = relationPath.replace (/<CO>/i, "");
                                        isToOverwriteDestination = true;
                                    }
                                    relationPath = tsSolveDateTime (relationPath);
                                    relationPath = tsSolveRandom (relationPath, null);
                                    if (relationPath.indexOf ("/") == -1) {
                                        relationPath = "./" + relationPath;
                                    }
                                    if (relationPath.indexOf ("//") == 0) {
                                        relationPath = relationPath.replace("//", tsWorkshopPath + "/");
                                    }
                                    var prefixDotsIndex = relationPath.search (/\.+\$?\//);
                                    while (prefixDotsIndex != -1) {
                                        var deepCount = 2;
                                        var dotsFirstMatch = relationPath.match (/\.+\$?\//)[0];
                                        var relativeFile = targetFile;
                                        if (dotsFirstMatch[dotsFirstMatch.length - 2] == '$' && sourceRelationFiles) {
                                            relativeFile = sourceRelationFiles[0];
                                            deepCount = 3;
                                        }
                                        var targetParent = relativeFile.parent;
                                        for (var pml = 0; pml < dotsFirstMatch.length - deepCount; pml++) {
                                            if (!targetParent.parent) {
                                                break;
                                            }
                                            targetParent = targetParent.parent;
                                        }
                                        relationPath = relationPath.replace (dotsFirstMatch, targetParent.fsName.replace(/\\/g, '/') + "/");
                                        prefixDotsIndex = relationPath.search (/\.+\$?\//);
                                    }
                                    var nameDotsIndex = relationPath.search (/<\.+\$?>/);
                                    while (nameDotsIndex != -1) {
                                        var deepCount = 3;
                                        var dotsFirstMatch = relationPath.match (/<\.+\$?>/)[0];
                                        var relativeFile = targetFile;
                                        if (dotsFirstMatch[dotsFirstMatch.length - 2] == '$' && sourceRelationFiles) {
                                            relativeFile = sourceRelationFiles[0];
                                            deepCount = 4;
                                        }
                                        var targetParent = relativeFile.parent;
                                        for (var pml = 0; pml < dotsFirstMatch.length - deepCount; pml++) {
                                            if (!targetParent.parent) {
                                                break;
                                            }
                                            targetParent = targetParent.parent;
                                        }
                                        var parentFolderName = "";
                                        if (targetParent && targetParent.name) {
                                            parentFolderName = File.decode (targetParent.name);
                                        }
                                        relationPath = relationPath.replace (dotsFirstMatch, parentFolderName);
                                        nameDotsIndex = relationPath.search (/<\.+\$?>/);
                                    }
                                    if (relationPath.search (/<AP>/i) != -1) {
                                        var fileAP = targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                                        if (fileAP == "") {
                                            relationPath = relationPath.replace(/\/?<AP>/gi, fileAP);
                                        }
                                        else {
                                            relationPath = relationPath.replace(/<AP>/gi, fileAP);
                                        }
                                    }
                                    if (relationPath.search (/<AP\$>/i) != -1 && sourceRelationFiles) {
                                        var fileAP = sourceRelationFiles[0].parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                                        if (fileAP == "") {
                                            relationPath = relationPath.replace(/\/?<AP\$>/gi, fileAP);
                                        }
                                        else {
                                            relationPath = relationPath.replace(/<AP\$>/gi, fileAP);
                                        }
                                    }
                                    var apDotIndex = relationPath.search (/<AP.+>/i);
                                    while (apDotIndex != -1) {
                                        var endIndex = -1;
                                        var apDotFirstMatch = relationPath.match (/<AP.+>/i)[0];
                                        var relativeFile = targetFile;
                                        if (apDotFirstMatch[apDotFirstMatch.length - 2] == '$' && sourceRelationFiles) {
                                            relativeFile = sourceRelationFiles[0];
                                            endIndex = -2;
                                        }
                                        var fileAPDot = relativeFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                                        var apDotSep = apDotFirstMatch.slice (3, endIndex);
                                        fileAPDot = fileAPDot.replace (/\//g, apDotSep);
                                        relationPath = relationPath.replace (/<AP.+>/i, fileAPDot);
                                        apDotIndex = relationPath.search (/<AP.+>/i);
                                    }
                                    if (relationPath.search (/<FD>/i) != -1) {
                                        var targetName = File.decode (targetFile.name);
                                        targetName = tsGetDisplayName (targetName);
                                        if (targetName == null) targetName = '';
                                        relationPath = relationPath.replace(/<FD>/gi, targetName);
                                    }
                                    if (relationPath.search (/<FN>/i) != -1) {
                                        var targetName = File.decode (targetFile.name);
                                        if (targetName.indexOf (".") > 0)
                                            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
                                        relationPath = relationPath.replace(/<FN>/gi, targetName);
                                    }
                                    if (relationPath.search (/<FN\$>/i) != -1 && sourceRelationFiles) {
                                        var targetName = File.decode (sourceRelationFiles[0].name);
                                        if (targetName.indexOf (".") > 0)
                                            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
                                        relationPath = relationPath.replace(/<FN\$>/gi, targetName);
                                    }
                                    if (relationPath.search (/<FNS>/i) != -1) {
                                        var targetName = File.decode (targetFile.name);
                                        if (targetName.indexOf (".") > 0)
                                            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
                                        if (targetName[0] == '[') {
                                            var suggestName = targetName;
                                            if (suggestName.indexOf ("]") != -1)
                                                suggestName = suggestName.slice (suggestName.indexOf ("]") + 1);
                                            while (suggestName[0] == ' ')
                                                suggestName = suggestName.slice (1);
                                            if (suggestName != "") {
                                                targetName = suggestName;
                                            }
                                        }
                                        else if (targetName[0] == '-') {
                                            var suggestName = targetName;
                                            suggestName = suggestName.slice (1);
                                            while (suggestName[0] == ' ')
                                                suggestName = suggestName.slice (1);
                                            if (suggestName != "") {
                                                targetName = suggestName;
                                            }
                                        }
                                        relationPath = relationPath.replace(/<FNS>/gi, targetName);
                                    }
                                    if (relationPath.search (/<FNS\$>/i) != -1 && sourceRelationFiles) {
                                        var targetName = File.decode (sourceRelationFiles[0].name);
                                        if (targetName.indexOf (".") > 0)
                                            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
                                        if (targetName[0] == '[') {
                                            var suggestName = targetName;
                                            if (suggestName.indexOf ("]") != -1)
                                                suggestName = suggestName.slice (suggestName.indexOf ("]") + 1);
                                            while (suggestName[0] == ' ')
                                                suggestName = suggestName.slice (1);
                                            if (suggestName != "") {
                                                targetName = suggestName;
                                            }
                                        }
                                        else if (targetName[0] == '-') {
                                            var suggestName = targetName;
                                            suggestName = suggestName.slice (1);
                                            while (suggestName[0] == ' ')
                                                suggestName = suggestName.slice (1);
                                            if (suggestName != "") {
                                                targetName = suggestName;
                                            }
                                        }
                                        relationPath = relationPath.replace(/<FNS\$>/gi, targetName);
                                    }
                                    var fnDotIndex = relationPath.search (/<FN.+>/i);
                                    while (fnDotIndex != -1) {
                                        var endIndex = -1;
                                        var fnDotFirstMatch = relationPath.match (/<FN.+>/i)[0];
                                        var relativeFile = targetFile;
                                        if (fnDotFirstMatch[fnDotFirstMatch.length - 2] == '$' && sourceRelationFiles) {
                                            relativeFile = sourceRelationFiles[0];
                                            endIndex = -2;
                                        }
                                        var targetName = File.decode (relativeFile.name);
                                        if (targetName.indexOf (".") > 0)
                                            targetName = targetName.slice (0, targetName.lastIndexOf ("."));
                                        if (targetName[0] == '[') {
                                            if (targetName.indexOf ("]") != -1)
                                            targetName = targetName.slice (targetName.indexOf ("]") + 1);
                                            while (targetName[0] == ' ')
                                                targetName = targetName.slice (1);
                                        }
                                        if (targetName != "") {
                                            var fnDotSep = fnDotFirstMatch.slice (3, endIndex);
                                            targetName = targetName.split (fnDotSep).join ("/");
                                            relationPath = relationPath.replace (/<FN.+>/i, targetName);
                                        }
                                        else {
                                            relationPath = relationPath.replace (/\/?<FN.+>/i, targetName);
                                        }
                                        fnDotIndex = relationPath.search (/<FN.+>/i);
                                    }
                                    if (relationPath.search (/<FC>/i) != -1) {
                                        var autoCheckInContent = readFile (targetFile);
                                        if (autoCheckInContent) {
                                            relationPath = relationPath.replace(/<FC>/gi, autoCheckInContent);
                                        }
                                    }
                                    if (relationPath.search (/<FC\$>/i) != -1 && sourceRelationFiles) {
                                        var autoCheckInContent = readFile (sourceRelationFiles[0]);
                                        if (autoCheckInContent) {
                                            relationPath = relationPath.replace(/<FC\$>/gi, autoCheckInContent);
                                        }
                                    }
                                    if (relationPath.search (/<FF>/i) != -1) {
                                        var firstFolderName = null;
                                        var toLookInFolder = Folder (relationPath.slice (0, relationPath.search (/\/<FF>/i)));
                                        if (toLookInFolder.exists) {
                                            var firstFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                            if (firstFolder.length > 0) {
                                                firstFolderName = File.decode (firstFolder[0].name);
                                            }
                                        }
                                        if (firstFolderName) {
                                            relationPath = relationPath.replace(/<FF>/gi, firstFolderName);
                                        }
                                        else {
                                            relationPath = relationPath.replace(/<FF>/gi, "0001");
                                        }
                                    }
                                    if (relationPath.search (/<NF>/i) != -1) {
                                        var nextFolderName = "0001";
                                        var toLookInFolder = Folder (relationPath.slice (0, relationPath.search (/\/<NF>/i)));
                                        if (toLookInFolder.exists) {
                                            var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                            if (lastFolder.length > 0) {
                                                var lastFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
                                                nextFolderName = tsNextIncrement (lastFolderName, "_01");
                                            }
                                        }
                                        relationPath = relationPath.replace(/<NF>/gi, nextFolderName);
                                    }
                                    if (relationPath.search (/<LF>/i) != -1) {
                                        var lastFolderName = null;
                                        var toLookInFolder = Folder (relationPath.slice (0, relationPath.search (/\/<LF>/i)));
                                        if (toLookInFolder.exists) {
                                            var lastFolder = toLookInFolder.getFiles (isAcceptedFolder);
                                            if (lastFolder.length > 0) {
                                                lastFolderName = File.decode (lastFolder[lastFolder.length - 1].name);
                                            }
                                        }
                                        if (lastFolderName) {
                                            relationPath = relationPath.replace(/<LF>/gi, lastFolderName);
                                        }
                                        else {
                                            relationPath = relationPath.replace(/<LF>/gi, "0001");
                                        }
                                    }
                                    var relationParent = null;
                                    if (relationPath.indexOf ("/") != -1) {
                                        relationParent = relationPath.slice (0, relationPath.lastIndexOf ("/"));
                                        if (relationParent.indexOf (tsWorkshopPath) == 0) {
                                            var relationFileName = relationPath.slice (relationPath.lastIndexOf ("/") + 1);
                                            if (relationFileName.length > 0) {
                                                var relationParentFol = new Folder (relationParent);
                                                var actualRelationFiles = new Array;
                                                var actualRelationIDs = new Array;
                                                if (relationParentFol.exists) {
                                                    var suggestedRelationFiles = relationParentFol.getFiles (relationFileName);
                                                    if (suggestedRelationFiles.length > 0) {
                                                        if (isToDeleteDestination && isAutoCheckInDeleted) {
                                                            for (var srf = 0; srf < suggestedRelationFiles.length; srf++) {
                                                                tsMoveToTrash (suggestedRelationFiles[srf], 1, null, true, null, false);
                                                            }
                                                        }
                                                        else if (!isToOverwriteDestination) {
                                                            actualRelationFiles = suggestedRelationFiles;
                                                            for (var arf = 0; arf < actualRelationFiles.length; arf++) {
                                                                var desName = actualRelationFiles[arf].fsName.replace(/\\/g, '/').slice (actualRelationFiles[arf].fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1);
                                                                if (desName[0] == '[') {
                                                                    var newFullPath = checkDynamicName (actualRelationFiles[arf], true);
                                                                    if (newFullPath) {
                                                                        actualRelationFiles[arf] = new File (newFullPath);
                                                                        actualRelationIDs.push (tsUpdateFileState (actualRelationFiles[arf], -2, -1));
                                                                    }
                                                                    else {
                                                                        actualRelationIDs.push (tsGetID (actualRelationFiles[arf]));
                                                                    }
                                                                }
                                                                else {
                                                                    actualRelationIDs.push (tsGetID (actualRelationFiles[arf]));
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                if (relationFileName[0] != '-' && actualRelationFiles.length == 0 && sourceRelationFiles) {
                                                    if (!isToDeleteDestination || !isAutoCheckInDeleted) {
                                                        for (var srf = 0; srf < sourceRelationFiles.length; srf++) {
                                                            var newPathIDList = tsChangeFile (sourceRelationFiles[srf], File (relationParent + "/" + File.decode (sourceRelationFiles[srf].name)), true, 2, false);
                                                            if (newPathIDList) {
                                                                actualRelationFiles.push (new File (newPathIDList[0]));
                                                                actualRelationIDs.push (newPathIDList[1]);
                                                            }
                                                        }
                                                    }
                                                }
                                                if (relationFileName[0] == '-') {
                                                    if (isToDeleteDestination && isAutoCheckInDeleted) {
                                                        if (relationParentFol.exists) {
                                                            var filesList = new Array;
                                                            retrieveFilesList (relationParentFol, filesList, false, []);
                                                            for (var fl = 0; fl < filesList.length; fl++) {
                                                                tsMoveToTrash (filesList[fl], 1, null, true, null, false);
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        if (sourceRelationFiles) {
                                                            newFromHandler ([sourceRelationFiles[0]], relationParentFol);
                                                        }
                                                    }
                                                }
                                                else if (!isNotToCheckIn) {
                                                    for (var arf = 0; arf < actualRelationFiles.length; arf++) {
                                                        if (actualRelationIDs[arf]) {
                                                            if (isInDesignFile (actualRelationFiles[arf])) {
                                                                docsIDsPairs.push ([actualRelationFiles[arf], actualRelationIDs[arf]]);
                                                            }
                                                            else {
                                                                var digitsFileIDTriple = getWorkshopVersionInfo (actualRelationFiles[arf], actualRelationIDs[arf]);
                                                                if (digitsFileIDTriple) {
                                                                    tsCheckIn (actualRelationFiles[arf], digitsFileIDTriple, false, true, true, true, false, true, null);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            //auto checkin for documents that have modified links
                            for (var dic = 0; dic < docsIDsPairs.length; dic++) {
                                var targetDocFile = docsIDsPairs[dic][0];
                                if (targetDocFile == null) {
                                    var docID_Path_newID = [docsIDsPairs[dic][1]];
                                    tsGetPath (docID_Path_newID);
                                    if (docID_Path_newID[1]) {
                                        targetDocFile = new File (tsWorkshopPath + docID_Path_newID[1]);
                                    }
                                }
                                if (targetDocFile != null) {
                                    if (targetDocFile.exists) {
                                        var digitsDocIDTriple = getWorkshopVersionInfo (targetDocFile, docsIDsPairs[dic][1]);
                                        if (digitsDocIDTriple) {
                                            var docVersionCreatorFile = new File (tsDataPath + "/IDs" + docsIDsPairs[dic][1] + "/ver" + digitsDocIDTriple[0] + "/Creator");
                                            if (!docVersionCreatorFile.exists) {
                                                var PDFPreviewIndex = -1;
                                                for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                                                    if (targetDocFile.fsName.replace(/\\/g, '/') == tsAlertPDFPreviewList[ppl][0]) {
                                                        PDFPreviewIndex = ppl;
                                                        break;
                                                    }
                                                }
                                                if (PDFPreviewIndex == -1) {
                                                    tsAlertPDFPreviewList.push ([
                                                        targetDocFile.fsName.replace(/\\/g, '/'), //The document full path
                                                        docsIDsPairs[dic][1], //fileID
                                                        digitsDocIDTriple[0], //versionNumber
                                                        false, //isWithFinal
                                                        0, //count down
                                                        0 //skips count
                                                    ]);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (tsAutoCheckInFilesList[acfl][3] > 4) {
                                tsAutoCheckInFilesList[acfl][3]--;
                            }
                        }

                        if (isAutoCheckInDeleted || isRemoveMark) {
                            tsAutoCheckInFilesList.splice (acfl, 1);
                        }
                    }
                    tsAutoCheckInFilesStep += tsAutoCheckInFilesStepWide + 1;
                }
                //Update Files IDs
                var updateIDsFiles = Folder (tsDataPath + "/Messages/To Update").getFiles (isUnhiddenFile);
                for (var uid = 0; uid < updateIDsFiles.length; uid++) {
                    var absolutePath = File.decode (updateIDsFiles[uid].name).replace(/\s➔\s/g, "/");
                    targetFileToUpdate = new File (tsWorkshopPath + "/" + absolutePath);
                    if (targetFileToUpdate.exists) {
                        tsUpdateFileState (targetFileToUpdate, -2, -1);
                    }
                    else {
                        tsMoveToTrash (targetFileToUpdate, 1, null, true, null, false);
                    }
                    updateIDsFiles[uid].remove ();
                }

                //InDesign tsCheckIn Request
                var checkInMessageFiles = Folder (tsDataPath + "/Messages/To CheckIn").getFiles (isUnhiddenFile);
                for (var ci = 0; ci < checkInMessageFiles.length; ci++) {
                    var fileDotID = File.decode (checkInMessageFiles[ci].name);
                    var fileID = "/" + fileDotID.replace (/\./g, "\/");
                    var checkinMode = readFile (checkInMessageFiles[ci]);
                    checkinMode = checkinMode.split (":");
                    InDesignCheckInItem = new Array;
                    InDesignCheckInItem.push (-1);
                    InDesignCheckInItem.push (fileID);
                    InDesignCheckInItem.push (checkinMode[0]);
                    InDesignCheckInItem.push (checkinMode[1]);
                    InDesignCheckInList.push (InDesignCheckInItem);
                    checkInMessageFiles[ci].remove ();
                }        
                for (var ch = InDesignCheckInList.length - 1; ch >= 0; ch--) {
                    InDesignCheckInList[ch][0] ++;
                    if (InDesignCheckInList[ch][0] == 0) {
                        var PDFExportingFile = new File (tsDataPath + "/No PDF Exporting");
                        tsIsStartPDFExporting = !PDFExportingFile.exists;
                        var fileID_Path_newID = [InDesignCheckInList[ch][1]];
                        tsGetPath (fileID_Path_newID);
                        if (fileID_Path_newID[1]) {
                            var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                            var digitsFileIDTriple = null;
                            if (InDesignCheckInList[ch][2] == "NewVersion") {
                                var versionsFolder = new Folder (workshopFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath));
                                if (!versionsFolder.exists)
                                    versionsFolder.create ();
                                var maxNumber = 0;
                                var IDFolder = new Folder (tsDataPath + "/IDs" + InDesignCheckInList[ch][1]);
                                var allVersions = IDFolder.getFiles ("ver??");
                                if (allVersions.length > 0) {
                                    maxNumber = parseInt (File.decode (allVersions[allVersions.length-1].name).slice (3), 10);
                                }
                                maxNumber += 1;
                                if (maxNumber < 10)
                                    maxNumber = "0" + maxNumber.toString ();
                                else
                                    maxNumber = maxNumber.toString ();
                                var filePart = new File(versionsFolder.fsName.replace(/\\/g, '/') + "/ver" + maxNumber + " " + File.decode (workshopFile.name));
                                digitsFileIDTriple = new Array;
                                digitsFileIDTriple.push (maxNumber);
                                digitsFileIDTriple.push (filePart);
                                digitsFileIDTriple.push (InDesignCheckInList[ch][1]);
                            }
                            else if (InDesignCheckInList[ch][2] == "OverwriteCurrent") {
                                digitsFileIDTriple = getWorkshopVersionInfo (workshopFile, null);
                            }
                            else {
                                var filePart = new File(workshopFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + InDesignCheckInList[ch][2] + " " + File.decode (workshopFile.name));
                                digitsFileIDTriple = new Array;
                                digitsFileIDTriple.push (InDesignCheckInList[ch][2]);
                                digitsFileIDTriple.push (filePart);
                                digitsFileIDTriple.push (InDesignCheckInList[ch][1]);
                            }

                            if (tsIsStartPDFExporting && InDesignCheckInList[ch][3] == "yesPDF") {
                                if (digitsFileIDTriple) {
                                    var PDFPreviewIndex = -1;
                                    for (var ppl = tsAlertPDFPreviewList.length - 1; ppl >= 0; ppl--) {
                                        if (workshopFile.fsName.replace(/\\/g, '/') == tsAlertPDFPreviewList[ppl][0]) {
                                            PDFPreviewIndex = ppl;
                                            break;
                                        }
                                    }
                                    if (PDFPreviewIndex == -1) {
                                        tsAlertPDFPreviewList.push ([
                                            workshopFile.fsName.replace(/\\/g, '/'), //The document full path
                                            fileID_Path_newID[0], //fileID
                                            digitsFileIDTriple[0], //versionNumber
                                            false, //isWithFinal
                                            0, //count down
                                            0 //skips count
                                        ]);
                                    }
                                }
                            }
                            else {
                                if (digitsFileIDTriple) {
                                    tsCheckIn (workshopFile, digitsFileIDTriple, false, true, true, true, false, true, null);
                                }
                            }
                        }
                        InDesignCheckInList.splice (ch, 1);
                    }
                }
                tsSendingBoxesStep++;
                if (tsSendingBoxesStep > tsSendingBoxesSpan) {
                    for (var icb = 0; icb < recipientsList.length; icb++) {
                        var sendingMessages = new Array;
                        for (var rli = recipientsList[icb][8][1].length - 1; rli >= 0; rli--) {
                            var firstLine = recipientsList[icb][8][1][rli][0] + ":" + recipientsList[icb][8][1][rli][1];
                            sendingMessages.push (firstLine + "\n---\n" + recipientsList[icb][8][1][rli][2]);
                            recipientsList[icb][8][1].splice (rli, 1);
                        }
                        sendingMessages = sendingMessages.join ("\n***\n");
                        if (sendingMessages != "") { 
                            var newCell = produceMessageCell (Folder (recipientsList[icb][1].fsName.replace(/\\/g, '/') + "/SyncInfo"));
                            if (newCell) {
                                var messageFile = new File (newCell.fsName.replace(/\\/g, '/') + "/Info");
                                writeEncodedFile (messageFile, sendingMessages); 
                            }
                            else {
                                /*Error*/$.writeln ("Error " + $.line);
                            }
                        }
                    }
                    tsIsSendingDone = true;
                    tsSendingBoxesStep = 0;
                }
                tsCheckSenderStep ++;
                if (tsCheckSenderStep > tsCheckSendersSpan) {
                
                    //Senders Online State
                    var onlineCollaboratorsFolder = new Folder (tsRootFolderPath + "/Workflow/Collaborators/Online");
                    if (onlineCollaboratorsFolder.exists) {
                        var onlineCollaboratorsFiles = onlineCollaboratorsFolder.getFiles ();
                        for (var ocf = 0; ocf < onlineCollaboratorsFiles.length; ocf++) {
                            onlineCollaboratorsFiles[ocf].remove();
                        }
                    }
                    else {
                        onlineCollaboratorsFolder.create();
                    }
                    var nowTime = new Date ().getTime ();
                    for (var e = 0; e < sendersList.length; e++) {
                        
                        //put my pulse
                        if (sendersList[e][0][3] != -1) {
                            var userPulseFile = new File (recipientsList[sendersList[e][0][3]][1].fsName.replace(/\\/g, '/') + "/Pulse");
                            writeFile (userPulseFile, nowTime);
                        }
                        else {
                            continue;
                        }
                        
                        var isOnline = false;
                        var senderPulse;
                        var senderPulseFile = File (sendersList[e][0][1].fsName.replace(/\\/g, '/') + "/Pulse");
                        if (senderPulseFile.exists) {
                            senderPulse = senderPulseFile.modified.getTime ();
                        }
        
                        if (senderPulse) {
                            if ((nowTime - senderPulse) < tsOnlineInterval)
                                isOnline = true;
                        }
                        
                        if (isOnline) {
                            var onlineCollaboratorIndex = -1;
                            for (var oc = 0; oc < onlineCollaborators.length; oc ++) {
                                if (onlineCollaborators[oc] == sendersList[e][0][3]) {
                                    onlineCollaboratorIndex = oc;
                                    break;
                                }
                            }
                            if (onlineCollaboratorIndex == -1) {
                                onlineCollaborators.push (sendersList[e][0][3]);
                            }
                            if (recipientsList[sendersList[e][0][3]][7]) { //to avoid the problem if the collaborator's folder name change after modifying his profile name
                            var onlineCollaboratorImage = new File (onlineCollaboratorsFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (recipientsList[sendersList[e][0][3]][7].name));
                            recipientsList[sendersList[e][0][3]][7].copy (onlineCollaboratorImage);
                            }
                        }
                        else {
                            for (var oic = 0; oic < onlineCollaborators.length; oic ++) {
                                if (onlineCollaborators[oic] == sendersList[e][0][3]) {
                                    onlineCollaborators.splice (oic, 1);
                                    break;
                                }
                            }
                        }
                    }
                    tsCheckSenderStep = 0;
                }
                for (var i = 0; i < sendersList.length; i++) {
                    if (sendersList[i][0][3] == -1)
                        continue;    
                    //distributing messages to boxes list
                    var currentTime = new Date ().getTime ();
                    if (!tsIsMessagesStoped) {
                        var newSyncInfos = getMessages (sendersList[i][1], currentTime);
        
                        for (var p = 0; p < newSyncInfos.length; p++) {
                            if (newSyncInfos[p].exists) {
                                if (File.decode (newSyncInfos[p].name)[0] != 'd') {
                                    var infoFile = new File (newSyncInfos[p].fsName.replace(/\\/g, '/') + "/Info"); 
                                    var wholeContent = readEncodedFile (infoFile);
                                    if (wholeContent) {
                                        var wholeContentSplitted = wholeContent.split ("\n***\n");
                                        for (var wcs = 0; wcs < wholeContentSplitted.length; wcs++) {
                                            var single = wholeContentSplitted[wcs].split ("\n---\n");
                                            var headAndTitle = single[0].split (":");
                                            var recievingBoxesItem = new Array;
                                            recievingBoxesItem.push (headAndTitle[1]); //message Tree Shade ID
                                            recievingBoxesItem.push (single[1]); //message body
                                            switch(headAndTitle[0]) {
                                                case "PathChanged":
                                                    sendersList[i][2][0].push (recievingBoxesItem);
                                                    break;
                                                case "Download":
                                                    sendersList[i][2][1].push (recievingBoxesItem);
                                                    break;
                                                case "HaveYou":
                                                    sendersList[i][2][2].push (recievingBoxesItem);
                                                    break;
                                                case "YesIHave":
                                                    sendersList[i][2][3].push (recievingBoxesItem);
                                                    break;
                                                case "IRequest":
                                                    sendersList[i][2][4].push (recievingBoxesItem);
                                                    break;
                                                case "NewState":
                                                    sendersList[i][2][5].push (recievingBoxesItem);
                                                    break;
                                                default:
                                                    
                                            }
                                        }
                                        deleteForcelyFolders (newSyncInfos[p], true);
                                    }
                                }
                            }
                        }
                    }
                    //PathChanged
                    var allPathChangedList = new Array;
                        //filtering messages
                    for (var rbp0 = sendersList[i][2][0].length - 1; rbp0 >= 0; rbp0--) {
                        var fileDotID = sendersList[i][2][0][rbp0][0].slice (0, sendersList[i][2][0][rbp0][0].lastIndexOf ("."));
                        var fileID = "/" + fileDotID.replace (/\./g, "\/");
                        
                        //if it under path changing
                        isUnderPathChanging = false;
                        for (var pa = tsIDTimePathStepIsUserOldPathList.length - 1; pa >= 0; pa--) {
                            if (tsIDTimePathStepIsUserOldPathList[pa][0] == fileID) {
                                isUnderPathChanging = true;
                                break;
                            }
                        }
                        if (isUnderPathChanging) {
                            continue;
                        }
                          
                        var modificationTime = sendersList[i][2][0][rbp0][0].slice (sendersList[i][2][0][rbp0][0].lastIndexOf (".")+1);
                        var pathChangedSplitted = sendersList[i][2][0][rbp0][1].split ("**");
                        var newPath = pathChangedSplitted[0];
                        var previousID = "NO_ID";
                        var originalID = "NO_ID";
                        if (pathChangedSplitted.length > 2) {
                            previousID = pathChangedSplitted[2];
                            originalID = pathChangedSplitted[3];
                        }
                        //if it under checking out to working location
                        var isUnderCheckingOut = false;
                        for (var vw = tsVersionsToWorkshopList.length -1 ; vw >= 0; vw--) {
                            if (tsVersionsToWorkshopList[vw][4] == fileID) { //tsVersionsToWorkshopList[x][4] fileID
                                isUnderCheckingOut = true;
                                break;
                            }
                        }
                        if (isUnderCheckingOut) {
                            continue;
                        }
        
                        //if it under downloading
                        var downloadingIndex = -1;
                        for (var v = tsDownloadingList.length - 1; v >= 0; v--) {
                            if (tsDownloadingList[v][2] == fileID) {
                                downloadingIndex = v;
                                break;
                            }
                        }
                        if (downloadingIndex != -1) {
                            if (newPath[0] == ':') {
                                if (parseInt (modificationTime, 10) > tsDownloadingList[downloadingIndex][3][1][0]) {
                                    tsDownloadingList[downloadingIndex][3][1][1] = false;
                                    continue;
                                }
                                else {
                                    sendersList[i][2][0].splice (rbp0, 1);
                                    continue;
                                }
                            }
                            else {
                                continue;
                            }
                        }
        
                        if (newPath.slice(newPath.length - 5).toLowerCase() == ".indd") {
                            var isToReopenAlready = false;
                            for (var rar = tsReopenAfterRenameList.length - 1; rar >= 0; rar--) {
                                if (newPath == tsReopenAfterRenameList[rar]) {
                                    isToReopenAlready = true;
                                    break;
                                }
                            }
                            if (isToReopenAlready)
                                continue;
                            var openedMarkFile = new File (tsDataPath + "/Opened Documents/" + fileDotID);
                            if (openedMarkFile.exists) {
                                var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                                var talkInDesign = new BridgeTalk;
                                talkInDesign.target = targetInDesign;
                                talkInDesign.body = 
                                    "closeToRename ();\n" +
                                    "function closeToRename () {\n" +
                                        "for (var a = 0; a < app.documents.length; a++) {\n" +
                                            "var targetDoc = app.documents[a];" + "\n" +
                                            "var docID = targetDoc.metadataPreferences.getProperty('http://ns.dulajun.com/treeshade/', 'TS_ID');\n" +
                                            "if (docID == '" + fileID + "') {\n" +
                                                "targetDoc.close (SaveOptions.ASK);" + "\n" +
                                            "}" + "\n" +
                                        "}" + "\n" +
                                    "}\n";
                                talkInDesign.send ();
                                tsReopenAfterRenameList.push (newPath);
                                continue;
                            }
                        }
                        var withThumbPart = pathChangedSplitted[1];
                        if (withThumbPart == "WITH_THUMB") {
                            var pathChangedThumbFile = new File (sendersList[i][0][1].fsName.replace(/\\/g, '/') + "/Path Thumb/" + fileDotID + "." + modificationTime + ".jpg");
                            var pathChangedThumbItem = new Array;
                            pathChangedThumbItem.push(0); //tsPathChangedThumbList[x][0] count
                            pathChangedThumbItem.push(pathChangedThumbFile); //tsPathChangedThumbList[x][1] file to be copied
                            pathChangedThumbItem.push(0); //tsPathChangedThumbList[x][2] file length
                            pathChangedThumbItem.push (new File (tsWorkshopPath + newPath.slice (0, newPath.lastIndexOf ("/")) + tsGetTreeShadeThumb (newPath.slice (newPath.lastIndexOf ("/") + 1)) + newPath.slice (newPath.lastIndexOf ("/") + 1) + ".jpg")); //tsPathChangedThumbList[x][3] destination
                            pathChangedThumbItem.push (newPath); //tsPathChangedThumbList[x][4] absolute new path
                            tsPathChangedThumbList.push (pathChangedThumbItem);
                        }
                        
                        var newListItem = new Array;
                        newListItem.push (fileID);
                        newListItem.push (parseInt (modificationTime, 10));
                        newListItem.push (newPath);
                        newListItem.push (previousID);
                        newListItem.push (originalID);
                        allPathChangedList.push (newListItem);
                        sendersList[i][2][0].splice (rbp0, 1);
                    }
                    //executing messages
                    for (var k = 0; k < allPathChangedList.length; k++) {
                        if (allPathChangedList[k][1] == -1)
                            continue;
                        var isOld = false;
                        for (var u = k + 1; u < allPathChangedList.length; u++) {
                            if (allPathChangedList[k][0] == allPathChangedList[u][0]) {
                                if (allPathChangedList[k][1] < allPathChangedList[u][1]) {
                                    isOld = true;
                                    allPathChangedList[k][1] = -1;
                                    break;
                                }
                                else {
                                    allPathChangedList[u][1] = -1;
                                }
                            }
                        }
                        if (isOld)
                            continue;
                        if (allPathChangedList[k][3] != "NO_ID") {
                            var previousID = new File (tsDataPath + "/IDs" + allPathChangedList[k][0] + "/Previous ID");
                            previousID.parent.create ();
                            writeFile (previousID, allPathChangedList[k][3]);
                        }
                        else {
                            var previousID = new File (tsDataPath + "/IDs" + allPathChangedList[k][0] + "/Previous ID");
                            previousID.remove ();
                        }
                        if (allPathChangedList[k][4] != "NO_ID") {
                            var originalID = new File (tsDataPath + "/IDs" + allPathChangedList[k][0] + "/Original ID");
                            originalID.parent.create ();
                            writeFile (originalID, allPathChangedList[k][4]);
                        }
                        else {
                            var originalID = new File (tsDataPath + "/IDs" + allPathChangedList[k][0] + "/Original ID");
                            originalID.remove ();
                        }
                        tsUpdatePath (sendersList[i][0][0], allPathChangedList[k][0], allPathChangedList[k][1], allPathChangedList[k][2]);
                    }
                    //Downloading
                    for (var rbp1 = sendersList[i][2][1].length - 1; rbp1 >= 0; rbp1--) {
                        //getting the information
                        var senderID = sendersList[i][0][0];
                        var exactName = sendersList[i][2][1][rbp1][0];
                        var isWithThumbnail = false;
                        if (sendersList[i][2][1][rbp1][0].slice(sendersList[i][2][1][rbp1][0].length - 4) == ".jpg") {
                            exactName = sendersList[i][2][1][rbp1][0].slice (0, sendersList[i][2][1][rbp1][0].lastIndexOf ("."));
                            isWithThumbnail = true;
                        }
                        var versionDotID = exactName.slice (0, exactName.lastIndexOf ("."));
                        var fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                        var versionID = "/" + versionDotID.replace (/\./g, "\/");
                        var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                        var downloadingThumbItem = new Array;
        
                        //if it under checking out to working location
                        var isUnderCheckingOut = false;
                        for (var vw = tsVersionsToWorkshopList.length -1 ; vw >= 0; vw--) {
                            if (tsVersionsToWorkshopList[vw][4] == fileID) { //tsVersionsToWorkshopList[x][4] fileID
                                isUnderCheckingOut = true;
                                break;
                            }
                        }
                        if (isUnderCheckingOut) {
                            continue;
                        }
                            
                        //if it under path changing
                        isUnderPathChanging = false;
                        for (var pd = 0; pd < tsIDTimePathStepIsUserOldPathList.length; pd++) {
                            if (tsIDTimePathStepIsUserOldPathList[pd][0] == fileID) {
                                isUnderPathChanging = true;
                                break;
                            }
                        }
                        if (isUnderPathChanging) {
                            continue;
                        }
                            
                        var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
                        var modificationTime = exactName.slice (exactName.lastIndexOf (".") + 1); 
        
                        modificationTime = parseInt (modificationTime, 10);
                        
                        //getting own time
                        var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
                        var versionTime = readFile (versionTimeFile);
                        if (!versionTime) {
                            var versionCreatorFile = new File (tsDataPath + "/IDs" + versionID + "/Creator");
                            if (!versionCreatorFile.parent.exists) {
                                versionCreatorFile.parent.create ();
                            }
                            writeFile (versionCreatorFile, senderID);
                            versionTime = "0";
                        }
                        versionTime = parseInt (versionTime, 10);
                        if (modificationTime < versionTime) {
                            sendersList[i][2][1].splice (rbp1, 1);
                            continue;
                        }
                        var versionDigits = versionPrefix.slice (versionPrefix.length-2);
                        var messageContent = sendersList[i][2][1][rbp1][1];
                    
                        var versionsConflict = false;
                        for (var dl = tsDownloadingList.length - 1; dl >= 0; dl--) {
                            if (tsDownloadingList[dl][2] == fileID) {
                                if (tsDownloadingList[dl][3][0] == versionDigits) {
                                    if (tsDownloadingList[dl][3][1][0] >= modificationTime) {
                                        sendersList[i][2][1].splice (rbp1, 1);
                                        continue;
                                    }
                                }
                                else {
                                    versionsConflict = true;
                                    break;
                                }
                            }
                        }

                        if (versionsConflict) {
                            continue;
                        }
        
                        var messageContentSplitted = messageContent.split ("\n");
                        var firstSplitted = messageContentSplitted[0].split (":");
                        var isFinal = (firstSplitted[0] == "Final"? true : false);
                        var notRequired = ((firstSplitted[1] == "Dark" || firstSplitted[1] == "Under Editing")? true : false);
                        var isUnderEditing = (firstSplitted[1] == "Under Editing");
                        var isWithPages = ((firstSplitted[2] == "With Pages" || firstSplitted[2] == "With All")? true : false);
                        var isWithPDF = ((firstSplitted[2] == "With PDF" || firstSplitted[2] == "With All")? true : false);
                        if (firstSplitted.length > 3) {
                            if (firstSplitted[3] != "NO_ID") {
                                var previousID = new File (tsDataPath + "/IDs" + fileID + "/Previous ID");
                                previousID.parent.create ();
                                writeFile (previousID, firstSplitted[3]);
                            }
                            else {
                                var previousID = new File (tsDataPath + "/IDs" + fileID + "/Previous ID");
                                previousID.remove ();
                            }
                            if (firstSplitted[4] != "NO_ID") {
                                var originalID = new File (tsDataPath + "/IDs" + fileID + "/Original ID");
                                originalID.parent.create ();
                                writeFile (originalID, firstSplitted[4]);
                            }
                            else {
                                var originalID = new File (tsDataPath + "/IDs" + fileID + "/Original ID");
                                originalID.remove ();
                            }
                        }
                        var oldVersionDigits = messageContentSplitted[1];
                        var pathTime = messageContentSplitted[2];
                        var supposedPath = messageContentSplitted[3];
                        var isInDesign = false;
                        if (messageContentSplitted.length > 4) {
                            isInDesign = true;
                        }
                    
                        var downloadingPathPart;
                        var scopeIndex = -1;
                        if (!notRequired) {
                            if (tsDownloadingList.length > 100) {
                                continue;
                            }                    
                            if (firstSplitted[1].slice (1) == "SELF") {
                                downloadingPathPart = sendersList[i][0][1].fsName.replace(/\\/g, '/');
                            }
                            else {
                                scopeIndex = getScopeIndex (firstSplitted[1].slice (1));
                                if (scopeIndex == -1) {
                                    sendersList[i][2][1].splice (rbp1, 1);
                                    continue;
                                }
                                downloadingPathPart = tsScopesList[scopeIndex][1][5].parent.fsName.replace(/\\/g, '/');
                            }
                        }
                    
                        var fileID_Path_newID = [fileID];
                        var localPathTime = tsGetPath (fileID_Path_newID);
                        if (!fileID_Path_newID[1]) {
                            if (fileID_Path_newID[2]) {
                                sendersList[i][2][1].splice (rbp1, 1);
                            }
                            else {
                                tsUpdatePath (sendersList[i][0][0], fileID, pathTime, supposedPath);
                            }
                            continue;
                        }
                        else if (localPathTime < pathTime) {
                            if (scopeIndex != -1) {
                                if (!isFileExistInScope (fileID_Path_newID[1], tsScopesList[scopeIndex][0])) {
                                    tsUpdatePath (sendersList[i][0][0], fileID, pathTime, supposedPath);
                                    continue;
                                }
                            }
                            else {
                                tsUpdatePath (sendersList[i][0][0], fileID, pathTime, supposedPath);
                                continue;
                            }
                        }
                        var downloadingPurePath = fileID_Path_newID[1];
                        var targetVersionFile = new File (tsVersionsPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + "/ver" + versionDigits + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1));
                        var workingThumbFullPath = null;
                        //mark under editing...
                        if (isUnderEditing) {
                            var underEditingFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/UnderEditing");
                            if (!underEditingFile.exists) {
                                var underEditingByOtherFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/UnderEditingByOther");
                                if (!underEditingByOtherFile.parent.exists)
                                    underEditingByOtherFile.parent.create ();
                                writeFile (underEditingByOtherFile, senderID);
                            }
                        }
                        
                        //Here
                        var requiredFolder = new Folder (tsDataPath + "/IDs" + fileID + "/Required");
                        if (!notRequired) {
                            if (!requiredFolder.exists)
                                requiredFolder.create ();
                            if (firstSplitted[1][0] == "L") {
                                var alreadyHave = requiredFolder.getFiles (isUnhiddenFile);
        
                                var loadTwin = getTotalGoal (fileID_Path_newID[1], null, fileID, false);
                                
                                for (var auno = 0; auno < loadTwin.length; auno++) {
                                    for (var asp = 0; asp < loadTwin[auno].length; asp++) {
                                        for (var arc = 0; arc < loadTwin[auno][asp][1].length; arc++) {
                                            var isAlreadyHave = false;
                                            for (var em = 0; em < alreadyHave.length; em++) {
                                                if (File.decode (alreadyHave[em].name) == recipientsList[loadTwin[auno][asp][1][arc]][0]) {
                                                    isAlreadyHave = true;
                                                    break;
                                                }
                                            }
                                            if (!isAlreadyHave) {
                                                //sendingBoxesList[1][x][0] message head
                                                //sendingBoxesList[1][x][1] message Tree Shade ID
                                                //sendingBoxesList[1][x][2] message body 
                                                tsIsSendingDone = false;
                                                var sendingBoxesItem = new Array;
                                                sendingBoxesItem.push ("YesIHave");
                                                sendingBoxesItem.push (versionDotID + "." + modificationTime);
                                                sendingBoxesItem.push ("ILoad");
                                                recipientsList[loadTwin[auno][asp][1][arc]][8][1].push (sendingBoxesItem);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    
                        if (!notRequired) {
                            writeFile (File (requiredFolder.fsName.replace(/\\/g, '/') + "/" + senderID), currentTime);
                            if (firstSplitted[1][0] == "W") {
                                var loadTwin = getTotalGoal (fileID_Path_newID[1], null, fileID, false);
                                for (var resp = 0; resp < loadTwin[0].length; resp++) {
                                    for (var rerc = 0; rerc < loadTwin[0][resp][1].length; rerc++) {
                                        var recipientRequiredFile = new File (tsDataPath + "/IDs" + fileID + "/Required/" + recipientsList[loadTwin[0][resp][1][rerc]][0]);
                                        if (!recipientRequiredFile.exists) {
                                            if (!recipientRequiredFile.parent.exists) {
                                                recipientRequiredFile.parent.create ();
                                            }
                                            writeFile (recipientRequiredFile, currentTime);
                                        }
                                    }
                                }
                            }
                        }
        
                        var modifierFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/Modifier");
                        if (!modifierFile.parent.exists)
                            modifierFile.parent.create ();
                        writeFile (modifierFile, senderID);
                        var currentVersionRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                        var currentVersionDigits = readFile (currentVersionRecordFile);
                        if (!currentVersionDigits)
                            currentVersionDigits = "New";
                        else {
                            currentVersionDigits = currentVersionDigits.split (":")[0];
                        }
                        if (!versionTimeFile.parent.exists)
                            versionTimeFile.parent.create ();
                        writeFile (versionTimeFile, modificationTime); //writing to the /M/ file the new modification time
                        if (notRequired) {
                            //put new shade version file or overwrite actual version file with it.
                            if (!targetVersionFile.parent.exists)
                                targetVersionFile.parent.create ();
                            writeFile (targetVersionFile, "TS_ID:" + fileID); //dangerous command
                            if (isInDesign) {
                                //deleting version pages and pdfs
                                var targetPagesFolder = new Folder (targetVersionFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages).slice (0, -5));
                                if (tsVersionsOutputZero != "ONLY_ZERO") {
                                    var oldPages = targetPagesFolder.getFiles (isUnhiddenFile);
                                    for (var a = 0; a < oldPages.length; a++) {
                                        oldPages[a].remove ();
                                    }
                                }
                                if (tsVersionsOutputZero == "ONLY_ZERO" || tsVersionsOutputZero == "WITH_ZERO") {
                                    var targetPagesZeroFolder = Folder (targetPagesFolder.fsName.replace(/\\/g, '/').slice (0, targetPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver")) + "/ver00" + targetPagesFolder.fsName.replace(/\\/g, '/').slice (targetPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver") + 6));
                                    var oldPages = targetPagesZeroFolder.getFiles (isUnhiddenFile);
                                    for (var a = 0; a < oldPages.length; a++) {
                                        oldPages[a].remove ();
                                    }
                                }
                                var targetPrevPDFFile = new File (tsVersionsPDFPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + "/ver" + versionDigits + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1, fileID_Path_newID[1].lastIndexOf (".")) + ".pdf");
                                targetPrevPDFFile.remove ();
                            }
                        }
                        if (isInDesign) {
                            if (versionTime != 0) {
                                //remove old version Places Files
                                var oldVersionLinksReportFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + versionTime + "/LinksReport");
                                var oldVersionLinksReportFileContent = readFile (oldVersionLinksReportFile);
                                if (oldVersionLinksReportFileContent) {
                                    var oldLines = oldVersionLinksReportFileContent.split ("\n");
                                    for (var o = 1; o < oldLines.length; o++) {
                                        var oldVersionPlacesFile = new File (tsDataPath + "/IDs" + oldLines[o] + "/Places/" + versionDotID + "." + versionTime);
                                        oldVersionPlacesFile.remove ();
                                    }
                                }
                            }
                            var versionLinksReportContent = messageContentSplitted[4];
                            for (var r = 5; r < messageContentSplitted.length; r++) {
                                var reportLine = messageContentSplitted[r].split (":");
                                var pageNumbers;
                                if (reportLine.length > 1) {
                                    pageNumbers = reportLine[1];
                                    for (var p = 2; p < reportLine.length; p++) {
                                        pageNumbers += "\n" + reportLine[p];
                                    }
                                }
                                else {
                                    /*Error*/$.writeln ("Tree Shade Error " + $.line);
                                }
                                versionLinksReportContent += "\n" + reportLine[0];
                                var versionPlacesFile = new File (tsDataPath + "/IDs" + reportLine[0] + "/Places/" + versionDotID + "." + modificationTime);
                                if (!versionPlacesFile.parent.exists)
                                    versionPlacesFile.parent.create ();
                                writeFile (versionPlacesFile, pageNumbers);
                                
                                if (!isUnderEditing) {
                                    //tsLinksLoadList[0] waiting list before check list
                                    //tsLinksLoadList[1] to be checked and to be requested list
                                    //tsLinksLoadList[2] requested list
                                    //tsLinksLoadList[crl][lll][0] counter
                                    //tsLinksLoadList[crl][lll][1] link tsIDVer
                                    //tsLinksLoadList[crl][lll][2] is to load actual file
                                    //tsLinksLoadList[crl][lll][3] creatorName
                                    
                                    var isExistInLinksLoadList = false;
                                    for (var crl = 0; crl < 3; crl++) {
                                        for (var lll = tsLinksLoadList[crl].length - 1; lll >= 0; lll--) {
                                            if (tsLinksLoadList[crl][lll][1] == reportLine[0]) {
                                                isExistInLinksLoadList = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (!isExistInLinksLoadList) {
                                        var isToBeRequested = false;
                                        var linkFileID = reportLine[0].slice (0, reportLine[0].lastIndexOf ("/"));
                                        fileID_Path_newID = [linkFileID];
                                        var pathTime = tsGetPath (fileID_Path_newID);
                                        if (fileID_Path_newID[1]) {
                                            var workshopFile = File (tsWorkshopPath + fileID_Path_newID[1]);
                                            if (!workshopFile.exists) {
                                                if (!workshopFile.parent.exists)
                                                    workshopFile.parent.create();
                                                writeFile (workshopFile, "TS_ID:" + linkFileID);
                                                if (!notRequired) {
                                                    isToBeRequested = true;
                                                }
                                            }
                                        }
                                        else {
                                            tsLoadFile (linkFileID, reportLine[0].slice (reportLine[0].lastIndexOf ("/") + 1), sendersList[i][0][0], !notRequired);
                                        }
                                        var linksLoadItem = new Array;
                                        linksLoadItem.push (0); //tsLinksLoadList[lll][crl][0] counter
                                        linksLoadItem.push (reportLine[0]); //tsLinksLoadList[lll][crl][1] link tsID
                                        linksLoadItem.push (!notRequired); //tsLinksLoadList[lll][crl][2] is to load actual file
                                        linksLoadItem.push (sendersList[i][0][0]); //tsLinksLoadList[crl][lll][3] creatorName
                                        if (isToBeRequested) {
                                            tsLinksLoadList[0].push (linksLoadItem);
                                        }  
                                        else {
                                            tsLinksLoadList[2].push (linksLoadItem);
                                        }
                                    }
                                }
                            }
                            var newVersionLinksReportFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/LinksReport");
                            if (!newVersionLinksReportFile.parent.exists)
                                newVersionLinksReportFile.parent.create ();
                            writeFile (newVersionLinksReportFile, versionLinksReportContent);
                        }
                        if (notRequired || isWithThumbnail) {
                            var isToCheckOut = false;
                            if (currentVersionDigits == versionDigits) {
                                isToCheckOut = true;
                            }
                            else {
                                //getting current version time
                                var currentVersionTime = 0;
                                if (currentVersionDigits != "New") {
                                    var currentVersionTimeFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersionDigits + "/Modifying Time");
                                    currentVersionTime = readFile (currentVersionTimeFile);
                                    if (currentVersionTime) {
                                        currentVersionTime = parseInt (currentVersionTime, 10);
                                        if (modificationTime > currentVersionTime) {
                                            var underEditingFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + currentVersionDigits + "/V/" + currentVersionTime + "/UnderEditing");
                                            if (!underEditingFile.exists)
                                                isToCheckOut = true;
                                        }
                                    }
                                }
                                else {
                                    isToCheckOut = true;
                                }
                            }
                            if (isToCheckOut && isWithThumbnail) {
                                workingThumbFullPath = tsWorkshopPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + tsGetTreeShadeThumb (fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1)) + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1) + ".jpg"; //the working thumbnail full path (assigning)
                            }
                            if (notRequired) {
                                if (isToCheckOut) {
                                    tsCheckOut (targetVersionFile, isFinal);
                                }
                            }
                        }
        
                        if (isWithThumbnail) {
                            //tsDownloadingThumbList
                            //tsDownloadingThumbList[dtl][0] check times
                            //tsDownloadingThumbList[dtl][1] the thumnbail file object
                            //tsDownloadingThumbList[dtl][2] the thumnbail file object length
                            //tsDownloadingThumbList[dtl][3] the version thumbnail full path
                            //tsDownloadingThumbList[dtl][4] the working thumbnail full path (will be assign if checked out)
                            
                            downloadingThumbItem.push (0); //tsDownloadingThumbList[dtl][0]
                            var thumbnailFile = new File (sendersList[i][0][1].fsName.replace(/\\/g, '/') + "/Thumbnails/" + sendersList[i][2][1][rbp1][0]);
                            downloadingThumbItem.push (thumbnailFile); //tsDownloadingThumbList[dtl][1]
                            downloadingThumbItem.push (thumbnailFile.exists? thumbnailFile.length : 0); //tsDownloadingThumbList[dtl][2]
                            var versionThumbFullPath = tsDataPath + "/IDs" + versionID + "/V/" + exactName.slice (exactName.lastIndexOf (".") + 1) + "/Thumbnail.jpg";
                            downloadingThumbItem.push (versionThumbFullPath); //tsDownloadingThumbList[dtl][3]
                            downloadingThumbItem.push (workingThumbFullPath); //tsDownloadingThumbList[dtl][4]
                            tsDownloadingThumbList.push (downloadingThumbItem);
                        }
        
                        if (notRequired) {
                            sendersList[i][2][1].splice (rbp1, 1);
                            continue;
                        }
        
                        var downloadData = new Array;
                        downloadData.push (0); //[0] interval: determine the span which the file take to traited again
                        downloadData.push (0); //[1] counter: to the interval
                        downloadData.push (fileID); //[2] fileID with slashs
                        
                        //building [3] array
                        downloadData.push (new Array);
                        downloadData[3].push (versionDigits); //[3][0] version digits
                        downloadData[3].push (new Array); //[3][1] array [modificationTime, isUpToDate]
                        downloadData[3][1].push (modificationTime); //[3][1] modificationTime as integer not string
                        downloadData[3][1].push (true); //isUpToDate
                        downloadData[3].push (isFinal); //[3][2] isFinal
                        downloadData[3].push (oldVersionDigits); //[3][3] oldVersionDigits
                        downloadData[3].push (senderID); //[3][4] senderID
        
                        //building [4] array
                        downloadData.push (new Array);
                        downloadData[4].push (false);
        
                        var physicalFile = new File (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/File");
                        downloadData[4].push (physicalFile);
                        downloadData[4].push (downloadingPurePath);
                        downloadData[4].push (isWithThumbnail);
                        if (isInDesign) {
                            //InDesign files information
                            if (isWithPages) {
                                downloadData.push (new Array);
                                downloadData[5].push (false); //[5][0] is count file downloaded
                                var countFile = new File (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/Count");
                                downloadData[5].push (countFile);  
                                
                                downloadData.push (new Array);
                                downloadData[6].push (false); //[6][0] is pages folder downloaded
                                var pagesFolder = new Folder (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/Pages");
                                downloadData[6].push (pagesFolder);
                                
                                downloadData.push (new Array);
                                downloadData[7].push (false); //[7][0] are all pages downloaded
                            }
                            else {
                                downloadData.push (new Array);
                                downloadData[5].push (true);
                                downloadData.push (0);
                                downloadData.push (0);
                            }
                            
                            if (isWithPDF) {
                                downloadData.push (new Array);
                                downloadData[8].push (false); //[8][0] is prevPDF file downloaded
                                var physicalPrevPDF = new File (downloadingPathPart +"/.tssync" + fileID + "/" + versionPrefix + "/" + modificationTime + "/PrevPDF");
                                downloadData[8].push (physicalPrevPDF);
                            }
                            else {
                                downloadData.push (new Array);
                                downloadData[8].push (true); //[8][0] is prevPDF file downloaded
                            }
                            
                        }
                        var downloadingWorkflowName = downloadData[4][2].replace (/\//g, " ➔ ");
                        downloadingWorkflowName = downloadingWorkflowName.slice (2);
                        var downloadingWorkflowFile = new File (tsRootFolderPath + "/Workflow/Downloading/" + downloadingWorkflowName);
                        if (!downloadingWorkflowFile.parent.exists)
                            downloadingWorkflowFile.parent.create ();
                        writeFile (downloadingWorkflowFile, "TS_ID:" + downloadData[2]);
                        tsDownloadingList.push (downloadData);
                        var isToAlert = true;
                        try {
                            app.document.navbars.filesystem.top.Downloading.text;
                        }
                        catch (e) { isToAlert = false; }
                        if (isToAlert) {
                            app.document.navbars.filesystem.top.Downloading.text = "Downloading: " + tsDownloadingList.length;
                        }
                        var downloadingMessageFile = new File (tsDataPath + "/Messages/Downloading/" + versionDotID + "." + modificationTime);
                        if (!downloadingMessageFile.parent.exists)
                            downloadingMessageFile.parent.create ();
                        messageContentSplitted[0] += ":" + senderID;
                        writeFile (downloadingMessageFile, messageContentSplitted[0] + "\n" + messageContentSplitted[1] + "\n" + senderID);
                        for (var w = 0; w < tsDownloadingList.length - 1; w++) {
                            if (tsDownloadingList[w][2] == downloadData[2]) {
                                if (tsDownloadingList[w][3][0] == downloadData[3][0]) {
                                    tsDownloadingList[w][3][1][1] = false;
                                }
                            }
                        }
                        sendersList[i][2][1].splice (rbp1, 1);
                    }
                    //HaveYou
                    for (var rbp2 = sendersList[i][2][2].length - 1; rbp2 >= 0; rbp2--) {
                        //getting the information
                        var senderID = sendersList[i][0][0];
                        if (sendersList[i][2][2][rbp2][0] == "Info") {
                            var infoContent = sendersList[i][2][2][rbp2][1];
                            if (infoContent) {
                                infoContent = infoContent.split ("\n");
                                if (infoContent[0] == "Work Time") {
                                    var finalResult = getWorkingTable (infoContent);
                                    if (finalResult) {
                                        if (sendersList[i][0][3] != -1) {
                                            //sendingBoxesList[1][x][0] message head
                                            //sendingBoxesList[1][x][1] message Tree Shade ID
                                            //sendingBoxesList[1][x][2] message body 
                                            tsIsSendingDone = false;
                                            var sendingBoxesItem = new Array;
                                            sendingBoxesItem.push ("YesIHave");
                                            sendingBoxesItem.push ("Info");
                                            sendingBoxesItem.push (finalResult);
                                            recipientsList[sendersList[i][0][3]][8][1].push (sendingBoxesItem);
                                        }
                                    }
                                }
                                else if (infoContent[0] == "Message") {
                                    //tsOrdersList[a][0] sender index
                                    //tsOrdersList[a][1] steps
                                    //tsOrdersList[a][2] step
                                    //tsOrdersList[a][3] versionFullDotID
                                    //tsOrdersList[a][4] is requested
                                    //tsOrdersList[a][5] is working of version
                                    //tsOrdersList[a][6] count of receivers
                                    //tsOrdersList[a][7] is to set remote under editing
                                    //tsOrdersList[a][8] the message body    
                                    var paraLineSplitted = infoContent[1].split (":");
                                    var messagesListItem = new Array;
                                    messagesListItem.push (i); // 0
                                    messagesListItem.push (1); // 1
                                    messagesListItem.push (1); // 2
                                    messagesListItem.push (paraLineSplitted[0]); // 3
                                    messagesListItem.push (false); // 4
                                    messagesListItem.push (paraLineSplitted[1]); // 5
                                    messagesListItem.push (paraLineSplitted[2]); // 6
                                    messagesListItem.push (paraLineSplitted[3] == "Y"); // 7
                                    var theMessageBody = "";
                                    if (infoContent.length > 2) {
                                        theMessageBody = infoContent[2];
                                        if (infoContent.length > 3) {
                                            for (var mb = 3; mb < infoContent.length; mb++) {
                                                theMessageBody += "\n" + infoContent[mb];
                                            }
                                        }
                                    }
                                    messagesListItem.push (theMessageBody); // 8
                                    tsOrdersList.push (messagesListItem);
                                }
                            }
                            sendersList[i][2][2].splice (rbp2, 1);
                            continue;
                        }
                        else if (sendersList[i][2][2][rbp2][0] == "Check") {
                            var infoContent = sendersList[i][2][2][rbp2][1];
                            if (infoContent) {
                                    if (sendersList[i][0][3] != -1) {
                                    var checkedFileID = infoContent.slice (0, infoContent.lastIndexOf ("."));
                                    var checkedVersionDigits = infoContent.slice (infoContent.lastIndexOf (".") + 1);
                                    var versionTimeFile =  new File (tsDataPath + "/IDs" + checkedFileID + "/ver" + checkedVersionDigits + "/Modifying Time");
                                    var versionTime = readFile (versionTimeFile);
                                    var isUnderEditingByMe = false;
                                    if (!versionTime) {
                                        versionTime = 0;
                                    }
                                    else {
                                        var currentRecordFile = new File (tsDataPath + "/IDs" + checkedFileID + "/CV");
                                        var currentVersion = readFile (currentRecordFile);
                                        if (currentVersion) {
                                            currentVersion = currentVersion.split (":")[0];
                                            if (currentVersion == checkedVersionDigits) {
                                                var fileID_Path_newID = [checkedFileID];
                                                tsGetPath (fileID_Path_newID);
                                                if (fileID_Path_newID[1]) {
                                                    var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                                    var actualModified = tsGetActualModified (workshopFile.modified.getTime (), checkedFileID);
                                                    if (actualModified > parseInt (versionTime, 10)) {
                                                        isUnderEditingByMe = true;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    //sendingBoxesList[1][x][0] message head
                                    //sendingBoxesList[1][x][1] message Tree Shade ID
                                    //sendingBoxesList[1][x][2] message body 
                                    tsIsSendingDone = false;
                                    var sendingBoxesItem = new Array;
                                    sendingBoxesItem.push ("YesIHave");
                                    sendingBoxesItem.push ("Check");
                                    sendingBoxesItem.push (infoContent + "." + versionTime + (isUnderEditingByMe? ".MODIFIED" : ""));
                                    recipientsList[sendersList[i][0][3]][8][1].push (sendingBoxesItem);
                                }
                            }
                            sendersList[i][2][2].splice (rbp2, 1);
                            continue;
                        }
        
                        var versionDotID = sendersList[i][2][2][rbp2][0].slice (0, sendersList[i][2][2][rbp2][0].lastIndexOf ("."));
                        var fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                        var versionID = "/" + versionDotID.replace (/\./g, "\/");
                        var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                        var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
                        var modificationTime = sendersList[i][2][2][rbp2][0].slice (sendersList[i][2][2][rbp2][0].lastIndexOf (".") + 1);                    
        
                        modificationTime = parseInt (modificationTime, 10);
                        
                        //getting own time
                        var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
                        var versionTime = readFile (versionTimeFile);
                        if (!versionTime) {
                            versionTime = "0";
                        }
                        versionTime = parseInt (versionTime, 10);
                        if (modificationTime == versionTime) {
                            var fileID_Path_newID = [fileID];
                            tsGetPath (fileID_Path_newID);
                            if (fileID_Path_newID[1]) {
                            
                                var versionFile = new File (tsVersionsPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/") + 1) + versionPrefix + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1));
                                if (versionFile.exists) {
                                    if (!tsIsShade (versionFile)) {
                                        var askForFolder = new Folder (tsDataPath + "/Messages/AskFor" + fileID + "/" + versionPrefix + "." + modificationTime);
                                        if (!askForFolder.exists) {
                                            //Set The Requirment
                                            var haveYouContent = sendersList[i][2][2][rbp2][1];
                                            var requiredFile = new File (tsDataPath + "/IDs" + fileID + "/Required/" + senderID);
                                            if (haveYouContent == "WILL_RELEASE") {
                                                requiredFile.remove ();
                                            }
                                            else {
                                                if (!requiredFile.exists) {
                                                    if (!requiredFile.parent.exists)
                                                        requiredFile.parent.create ();
                                                    writeFile (requiredFile, currentTime);
                                                }
                                            }
                                            if (sendersList[i][0][3] != -1) {
                                                tsIsSendingDone = false;
                                                var sendingBoxesItem = new Array;
                                                sendingBoxesItem.push ("YesIHave");
                                                sendingBoxesItem.push (versionDotID + "." + modificationTime);
                                                sendingBoxesItem.push (currentTime);
                                                recipientsList[sendersList[i][0][3]][8][1].push (sendingBoxesItem);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        sendersList[i][2][2].splice (rbp2, 1);
                    }
                    //YesIHave
                    for (var rbp3 = sendersList[i][2][3].length - 1; rbp3 >= 0; rbp3--) {
                        var senderID = sendersList[i][0][0];
                        var senderName = sendersList[i][0][0];
                        if (sendersList[i][0][3] != -1) {
                            senderName = recipientsList[sendersList[i][0][3]][5];
                        }
                    
                        if (sendersList[i][2][3][rbp3][0] == "Info") {
                            var infoContent = sendersList[i][2][3][rbp3][1];
                            if (infoContent) {
                                produceWorkingDocument (senderName, infoContent);
                            }
                            sendersList[i][2][3].splice (rbp3, 1);
                            continue;
                        }
                        else if (sendersList[i][2][3][rbp3][0] == "Check") {
                            var infoContent = sendersList[i][2][3][rbp3][1];
                            if (infoContent) {
                                var checkMessage = "";
                                var infoContentSplitted = infoContent.split (".");
                                var localVersionTimeFile =  new File (tsDataPath + "/IDs" + infoContentSplitted[0] + "/ver" + infoContentSplitted[1] + "/Modifying Time");
                                var localVersionTime = readFile (localVersionTimeFile);
                                if (!localVersionTime) {
                                    localVersionTime = 0;
                                }
                                localVersionTime = parseInt (localVersionTime, 10);
                                infoContentSplitted[2] = parseInt (infoContentSplitted[2], 10);
                                if (localVersionTime == infoContentSplitted[2]) {
                                    if (infoContentSplitted.length > 3) {
                                        checkMessage = "It is under editing by me";
                                    }
                                    else {
                                        checkMessage = "It is synchronized";
                                    }
                                }
                                else if (localVersionTime > infoContentSplitted[2]) {
                                    if (infoContentSplitted[2] == 0) {
                                        checkMessage = "I don't have this version";
                                    }
                                    else {
                                        checkMessage = "I have old modification time";
                                    }
                                }
                                else {
                                    checkMessage = "I have new modification time and you need to load the file";
                                }
        
                                var versionFullDotID = infoContentSplitted[0].replace (/\//g,"\.");
                                versionFullDotID = versionFullDotID.slice (1);
                                versionFullDotID = versionFullDotID + ".ver" + infoContentSplitted[1] + "." + localVersionTime;
        
                                //tsOrdersList[a][0] sender index
                                //tsOrdersList[a][1] steps
                                //tsOrdersList[a][2] step
                                //tsOrdersList[a][3] versionFullDotID
                                //tsOrdersList[a][4] is requested
                                //tsOrdersList[a][5] is working of version
                                //tsOrdersList[a][6] count of receivers
                                //tsOrdersList[a][7] is to set remote under editing
                                //tsOrdersList[a][8] the message body    
                                var messagesListItem = new Array;
                                messagesListItem.push (i); // 0
                                messagesListItem.push (1); // 1
                                messagesListItem.push (1); // 2
                                messagesListItem.push (versionFullDotID); // 3
                                messagesListItem.push (false); // 4
                                messagesListItem.push ("1"); // 5
                                messagesListItem.push (1); // 6
                                messagesListItem.push (false); // 7
                                messagesListItem.push (checkMessage); // 8
                                tsOrdersList.push (messagesListItem);
                            }
                            sendersList[i][2][3].splice (rbp3, 1);
                            continue;
                        }
                        
                        //getting the information
                        var versionDotID = sendersList[i][2][3][rbp3][0].slice (0, sendersList[i][2][3][rbp3][0].lastIndexOf ("."));
                        var fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                        var versionID = "/" + versionDotID.replace (/\./g, "\/");
                        var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                        var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
                        var modificationTime = sendersList[i][2][3][rbp3][0].slice (sendersList[i][2][3][rbp3][0].lastIndexOf (".") + 1);
        
                        var versionDigits = versionPrefix.slice (versionPrefix.length-2);
                        var messageContent = sendersList[i][2][3][rbp3][1];
                        var askForFolder = new Folder (tsDataPath + "/Messages/AskFor" + fileID + "/" + versionPrefix + "." + modificationTime);
                        if (askForFolder.exists) {
                            var whatToDo = readFile (File (askForFolder.fsName.replace(/\\/g, '/') + "/ToDo"));
                            deleteForcelyFolders (askForFolder, true);
                            //getting own time
                            var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
                            var versionTime = readFile (versionTimeFile);
                            if (modificationTime == versionTime) {
                                if (whatToDo == "WILL_RELEASE") {
                                    var fileID_Path_newID = [fileID];
                                    tsGetPath (fileID_Path_newID);
                                    if (fileID_Path_newID[1]) {
                                        var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                        var CVRecordFile = new File (tsDataPath + "/IDs" + fileID  + "/CV");
                                        var CVDigits = "00";
                                        var CVFinal = "P";
                                        if (CVRecordFile.exists) {
                                            var CVRecordSplitted = readFile (CVRecordFile);
                                            if (CVRecordSplitted) {
                                                CVRecordSplitted = CVRecordSplitted.split (":");
                                                CVDigits = CVRecordSplitted[0];
                                                CVFinal = CVRecordSplitted[1];
                                            }
                                        }
                                        var isInDesign = isInDesignFile (workshopFile);
                                        if (("ver" + CVDigits) == versionPrefix) {
                                            var oldDate = tsGetActualModified (workshopFile.modified.getTime (), fileID);
                                            writeFile (workshopFile, "TS_ID:" + fileID); //dangerous command
                                            tsMarkFakeModified (oldDate, workshopFile, fileID);
                                            if (isInDesign) {
                                                var workingPagesFolder = new Folder (workshopFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsPagesPath + "/Workshop"));
                                                deleteForcelyFolders (workingPagesFolder, true);
                                                var finalPDFFile = new File (workshopFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsFinalPDFPath) + "/" + File.decode (workshopFile.name).slice (0, File.decode (workshopFile.name).lastIndexOf (".")) + ".pdf");
                                                addToNonTreeEmptyFoldersList (finalPDFFile.parent.fsName.replace(/\\/g, '/'));
                                                finalPDFFile.remove ();
                                            }
                                        }
                                        //remove the version file
                                        var absoluteWithSlash = fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/") + 1);
                                        var nameWithExt = fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1);
                                        var nameWithout = nameWithExt.slice (0, nameWithExt.lastIndexOf ("."));
                                        var versionFile = new File (tsVersionsPath + absoluteWithSlash + versionPrefix + " " + nameWithExt);
                                    
                                        writeFile (versionFile, "TS_ID:" + fileID); //dangerous command
                                        if (isInDesign) {
                                            //remove pages
                                            var versionPagesFolder = new Folder (versionFile.fsName.replace(/\\/g, '/').replace (tsVersionsPath, tsVersionsPages).slice (0, -5));
                                            if (tsVersionsOutputZero != "ONLY_ZERO") {
                                                deleteForcelyFolders (versionPagesFolder, true);
                                            }
                                            if (tsVersionsOutputZero == "ONLY_ZERO" || tsVersionsOutputZero == "WITH_ZERO") {
                                                var versionPagesZeroFolder = Folder (versionPagesFolder.fsName.replace(/\\/g, '/').slice (0, versionPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver")) + "/ver00" + versionPagesFolder.fsName.replace(/\\/g, '/').slice (versionPagesFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/ver") + 6));
                                                deleteForcelyFolders (versionPagesZeroFolder, true);
                                            }
                                            //remove preview pdf
                                            var prevPDFFile = new File (tsVersionsPDFPath + absoluteWithSlash + nameWithout + ".pdf");
                                            addToNonTreeEmptyFoldersList (prevPDFFile.parent.fsName.replace(/\\/g, '/'));
                                            prevPDFFile.remove ();
                                        }
                                    }               
                                }
                                else if (whatToDo == "WILL_REQUEST") {
                                    if (sendersList[i][0][3] != -1) {
                                        tsIsSendingDone = false;
                                        var sendingBoxesItem = new Array;
                                        sendingBoxesItem.push ("IRequest");
                                        sendingBoxesItem.push (versionDotID + "." + modificationTime);
                                        sendingBoxesItem.push ("A");
                                        recipientsList[sendersList[i][0][3]][8][1].push (sendingBoxesItem);
                                    }
                                }
                            }
                        }
                        else {
                            if (messageContent == "ILoad") {
                                var requiredFile = new File (tsDataPath + "/IDs" + fileID + "/Required/" + senderID);
                                if (!requiredFile.parent.exists)
                                    requiredFile.parent.create ();
                                writeFile (requiredFile, currentTime);
                            }
                        }
                        sendersList[i][2][3].splice (rbp3, 1);
                    }
                    //IRequest
                    for (var rbp4 = sendersList[i][2][4].length - 1; rbp4 >= 0; rbp4--) {
                        if (sendersList[i][2][4][rbp4][1][0] == 'C') {
                            var labelFileID = "/" + sendersList[i][2][4][rbp4][0].replace (/\./g, "\/");
                            var fileID_Path_newID = [labelFileID];
                            tsGetPath (fileID_Path_newID);
                            if (fileID_Path_newID[1]) {
                                var receivedIDsList = sendersList[i][2][4][rbp4][1].split (",");
                                var loadPara = receivedIDsList[0].split (":");
                                var isWithSub = (loadPara[1] == "YES_SUB")? true : false;
                                var isShade = (loadPara[2] == "YES_SHADE")? true : false;
                                var labelFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                var IDsList = new Array;
                                if (isWithSub) {
                                    var allFilesList = new Array;
                                    retrieveFilesList (labelFile.parent, allFilesList, false, []);
                                    for (var afl = 0; afl < allFilesList.length; afl++) {
                                        var aflID = tsGetID (allFilesList[afl]);
                                        if (aflID) {
                                            IDsList.push (aflID);
                                        }
                                    }
                                }
                                else {
                                    tsRetrieveLabelIDsList (labelFile, IDsList);
                                }
                                var idli = new Array;
                                for (var idl = 0; idl < IDsList.length; idl++) {
                                    idli.push (idl);
                                }
                                
                                receivedIDsList.splice (0, 1); //Remove 'C:YES_SUB:YES_SHADE'
                                for (var rid = receivedIDsList.length - 1; rid >= 0; rid--) {
                                    for (var li = idli.length - 1; li >= 0; li--) {
                                        if (receivedIDsList[rid] == IDsList[idli[li]]) {
                                            receivedIDsList.splice (rid, 1);
                                            idli.splice (li, 1);
                                            break;
                                        }
                                    }
                                }
                                IDsList = IDsList.concat (receivedIDsList);
                                if (isShade) {
                                    for (idl = 0; idl < IDsList.length; idl++) {
                                        tsUploadFilePath (null, null, IDsList[idl], sendersList[i][0][3], true);
                                    }
                                }
                                else {
                                    for (idl = 0; idl < IDsList.length; idl++) {
                                        var fileDotID = IDsList[idl].replace (/\//g,"\.");
                                        fileDotID = fileDotID.slice (1);
                                        tsUpload (fileDotID + ".ver00.0", i, null);
                                    }
                                }
                            }
                            else {
                                tsUploadFilePath (null, null, labelFileID, sendersList[i][0][3], true);
                            }
                        }
                        else if (sendersList[i][2][4][rbp4][1][0] == 'A') {
                            tsUpload (sendersList[i][2][4][rbp4][0], i, null);
                        }
                        else {
                            var versionDotID = sendersList[i][2][4][rbp4][0].slice (0, sendersList[i][2][4][rbp4][0].lastIndexOf ("."));
                            var versionID = "/" + versionDotID.replace (/\./g, "\/");
                            var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                            tsUploadFilePath (null, null, fileID, sendersList[i][0][3], true);
                        }
                        sendersList[i][2][4].splice (rbp4, 1);
                    }
                    //NewState
                    for (var rbp5 = sendersList[i][2][5].length - 1; rbp5 >= 0; rbp5--) {
                        //getting the information
                        var versionDotID = sendersList[i][2][5][rbp5][0].slice (0, sendersList[i][2][5][rbp5][0].lastIndexOf ("."));
                        var fileDotID = versionDotID.slice (0, versionDotID.lastIndexOf ("."));
                        var versionID = "/" + versionDotID.replace (/\./g, "\/");
                        var fileID = versionID.slice (0, versionID.lastIndexOf ("/"));
                        var versionPrefix = versionID.slice (versionID.lastIndexOf ("/") + 1);
                        var modificationTime = sendersList[i][2][5][rbp5][0].slice (sendersList[i][2][5][rbp5][0].lastIndexOf (".") + 1);                  
        
                        modificationTime = parseInt (modificationTime, 10);
                        
                        //getting own time
                        var versionTimeFile = new File (tsDataPath + "/IDs" + versionID + "/Modifying Time");
                        var versionTime = readFile (versionTimeFile);
                        if (!versionTime) {
                            versionTime = "0";
                        }
                        versionTime = parseInt (versionTime, 10);
                        var senderID = sendersList[i][0][0];
                        if (modificationTime == versionTime) {
                            var messageContent = sendersList[i][2][5][rbp5][1];
                            if (messageContent) {
                                messageContent = messageContent.split (":");
                                var newState = messageContent[0];
                                var newTime = parseInt (messageContent[1], 10);
                                var oldStateTimeFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/StateTime");
                                var oldStateTime = readFile (oldStateTimeFile);
                                var isNew = true;
                                if (oldStateTime) {
                                    oldStateTime = parseInt (oldStateTime, 10);
                                    if (newTime <= oldStateTime) {
                                        isNew = false;
                                    }
                                }
                                if (isNew) {
                                    var underEditingByOtherFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/UnderEditingByOther");
                                    if (newState == "UNDER_EDITING") {
                                        var underEditingFile = new File (tsDataPath + "/IDs" + versionID + "/V/" + modificationTime + "/UnderEditing");
                                        if (!underEditingFile.exists) {
                                            if (!underEditingByOtherFile.parent.exists)
                                                underEditingByOtherFile.parent.create ();
                                            writeFile (underEditingByOtherFile, senderID);
                                            writeFile (oldStateTimeFile, newTime);
                                            var fileID_Path_newID = [fileID];
                                            var pathTime = tsGetPath (fileID_Path_newID);
                                            if (fileID_Path_newID[1]) {
                                                var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                                if (workshopFile.exists) {
                                                    var fileThumbnail = new Thumbnail (workshopFile);
                                                    if (fileThumbnail.label == "Modified By Another Collaborator" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "") {
                                                        var oldDate = fileThumbnail.spec.modified.getTime ();
                                                        fileThumbnail.label = "Need To Be Checked In";
                                                        if (!tsIsShade (fileThumbnail.spec) && isCSFile (fileThumbnail.spec))
                                                            tsMarkFakeModified (oldDate, fileThumbnail.spec, fileID);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (newState == "CANCEL_UNDER_EDITING") {
                                        if (underEditingByOtherFile.exists) {
                                            var content = readFile (underEditingByOtherFile);
                                            if (content == senderID) {
                                                underEditingByOtherFile.remove ();
                                                writeFile (oldStateTimeFile, newTime);
                                                var fileID_Path_newID = [fileID];
                                                var pathTime = tsGetPath (fileID_Path_newID);
                                                if (fileID_Path_newID[1]) {
                                                    var workshopFile = new File (tsWorkshopPath + fileID_Path_newID[1]);
                                                    if (workshopFile.exists) {
                                                        var fileThumbnail = new Thumbnail (workshopFile);
                                                        if (fileThumbnail.label == "Modified By Another Collaborator" || fileThumbnail.label == "Placed" || fileThumbnail.label == "Current" || fileThumbnail.label == "Final" || fileThumbnail.label == "Need To Be Checked In") {
                                                            var oldDate = fileThumbnail.spec.modified.getTime ();
                                                            fileThumbnail.label = "";
                                                            if (!tsIsShade (fileThumbnail.spec) && isCSFile (fileThumbnail.spec))
                                                                tsMarkFakeModified (oldDate, fileThumbnail.spec, fileID);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else if (newState == "FINAL") {
                                        var content = readFile (underEditingByOtherFile);
                                        if (content == senderID) {
                                            underEditingByOtherFile.remove ();
                                        }
                                        var fileID_Path_newID = [fileID];
                                        var pathTime = tsGetPath (fileID_Path_newID);
                                        if (fileID_Path_newID[1]) {
                                            var versionFile = new File (tsVersionsPath + fileID_Path_newID[1].slice (0, fileID_Path_newID[1].lastIndexOf ("/")) + "/" + versionPrefix + " " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1));
                                            tsCheckOut (versionFile, true);
                                            writeFile (oldStateTimeFile, newTime);
                                        }
                                    }
                                }
                            }
                        }
                        sendersList[i][2][5].splice (rbp5, 1);
                    }
                }
            }
        }
        if (tsRandomTimeTaskStep++ > 152) {
            tsRandomTimeTaskStep = 0;
            //task guest update version thumbnail
            //tsCheckedInThumbnailsList[x][0] counter
            //tsCheckedInThumbnailsList[x][1] version File then Thumbnail
            //tsCheckedInThumbnailsList[x][2] thumbnailFile
            //tsCheckedInThumbnailsList[x][3] workingThumbnailFile
            
            
            for (var ct = tsCheckedInThumbnailsList.length - 1; ct >= 0; ct--) {
                if (tsCheckedInThumbnailsList[ct][1] instanceof File) {
                    if (tsCheckedInThumbnailsList[ct][1].exists) {
                        tsCheckedInThumbnailsList[ct][1] = new Thumbnail (tsCheckedInThumbnailsList[ct][1]);
                    }
                }
                else {
                    if (tsCheckedInThumbnailsList[ct][0] % 2 == 0) {
                        tsCheckedInThumbnailsList[ct][1].refresh ();
                    }
                    else {
                        if (!tsCheckedInThumbnailsList[ct][2].exists) {
                            if (!tsCheckedInThumbnailsList[ct][2].parent.exists)
                                tsCheckedInThumbnailsList[ct][2].parent.create();
                            tsCheckedInThumbnailsList[ct][1].core.thumbnail.thumbnail.exportTo(tsCheckedInThumbnailsList[ct][2], 0);  
                        }
                        else {
                            if (tsCheckedInThumbnailsList[ct][3]) {
                                if (!tsCheckedInThumbnailsList[ct][3].parent.exists)
                                    tsCheckedInThumbnailsList[ct][3].parent.create ();
                                tsCheckedInThumbnailsList[ct][2].copy (tsCheckedInThumbnailsList[ct][3]);
                            }
                            tsCheckedInThumbnailsList.splice (ct, 1);
                            continue;
                        }
                        if (tsCheckedInThumbnailsList[ct][0] > 10) {
                            tsCheckedInThumbnailsList.splice (ct, 1);
                            continue;
                        }
                    }
                }
                tsCheckedInThumbnailsList[ct][0]++;
            }
            //tsUploadThumbnailsList[x][0] counter
            //tsUploadThumbnailsList[x][1] file thumbnail
            //tsUploadThumbnailsList[x][2] working thumbnail file
            //tsUploadThumbnailsList[x][3] pathchanged thumbnail file
            for (var ut = tsUploadThumbnailsList.length - 1; ut >= 0; ut--) {
                if (tsUploadThumbnailsList[ut][0] % 2 == 0) {
                    tsUploadThumbnailsList[ut][1].refresh ();
                }
                else {
                    if (!tsUploadThumbnailsList[ut][2].exists) {
                        if (!tsUploadThumbnailsList[ut][1].exists) {
                            tsUploadThumbnailsList.splice (ut, 1);
                            continue;
                        }
                        if (!tsUploadThumbnailsList[ut][2].parent.exists)
                            tsUploadThumbnailsList[ut][2].parent.create();
                        tsUploadThumbnailsList[ut][1].core.thumbnail.thumbnail.exportTo(tsUploadThumbnailsList[ut][2], 0);  
                    }
                    else {
                        if (tsUploadThumbnailsList[ut][3]) {
                            if (!tsUploadThumbnailsList[ut][3].parent.exists)
                                tsUploadThumbnailsList[ut][3].parent.create ();
                            tsUploadThumbnailsList[ut][2].copy (tsUploadThumbnailsList[ut][3]);
                        }
                        tsUploadThumbnailsList.splice (ut, 1);
                        continue;
                    }
                    if (tsUploadThumbnailsList[ut][0] > 20) {
                        tsUploadThumbnailsList.splice (ut, 1);
                        continue;
                    }
                }
                tsUploadThumbnailsList[ut][0]++;
            }
            //tsPathChangedThumbList
            //tsPathChangedThumbList[x][0] count
            //tsPathChangedThumbList[x][1] file to be copied
            //tsPathChangedThumbList[x][2] file length
            //tsPathChangedThumbList[x][3] destination
            //tsPathChangedThumbList[x][4] absolute new path
            for (var pct = tsPathChangedThumbList.length - 1; pct >= 0; pct--) {
                if (tsPathChangedThumbList[pct][0] > 100) {
                    if (tsPathChangedThumbList[pct][1].exists)
                        tsPathChangedThumbList[pct][1].remove ();
                    tsPathChangedThumbList.splice (pct, 1);
                    continue;
                }
                if (tsPathChangedThumbList[pct][2] == 0) {
                    if (tsPathChangedThumbList[pct][3].exists) {
                        tsPathChangedThumbList[pct][3].remove ();
                        continue;
                    }
                }
                if (tsPathChangedThumbList[pct][2] != 0) {
                    if (tsPathChangedThumbList[pct][2] == tsPathChangedThumbList[pct][1].length) {
                        var workshopFile = new File (tsWorkshopPath + tsPathChangedThumbList[pct][4]);
                        if (workshopFile.exists) {
                            tsPathChangedThumbList[pct][3].parent.create ();
                            tsPathChangedThumbList[pct][1].copy (tsPathChangedThumbList[pct][3]); 
                            tsPathChangedThumbList[pct][0] = 101;   
                        }
                        else if (tsPathChangedThumbList[pct][0] < 90) {
                            tsPathChangedThumbList[pct][0] = 90;
                        }
                        continue;
                    }
                }
                if (tsPathChangedThumbList[pct][1].exists) {
                    tsPathChangedThumbList[pct][2] = tsPathChangedThumbList[pct][1].length;
                }
                tsPathChangedThumbList[pct][0]++;
            }

            //tsDownloadingThumbList
            //tsDownloadingThumbList[dtl][0] check times
            //tsDownloadingThumbList[dtl][1] the thumnbail file object
            //tsDownloadingThumbList[dtl][2] the thumnbail file object length
            //tsDownloadingThumbList[dtl][3] the version thumbnail full path
            //tsDownloadingThumbList[dtl][4] the working thumbnail full path (will be assign if checked out)
            for (var dtl = tsDownloadingThumbList.length - 1; dtl >= 0; dtl--) {
                if (tsDownloadingThumbList[dtl][0] == -1) {
                    tsDownloadingThumbList[dtl][1].remove ();
                    tsDownloadingThumbList.splice (dtl, 1);
                }
                else {
                    tsDownloadingThumbList[dtl][0]++;
                    if (tsDownloadingThumbList[dtl][1].exists) {
                        if (tsDownloadingThumbList[dtl][1].length) {
                            if (tsDownloadingThumbList[dtl][1].length == tsDownloadingThumbList[dtl][2]) {
                                var verThumbnailFile = new File (tsDownloadingThumbList[dtl][3]);
                                if (!verThumbnailFile.parent.exists)
                                    verThumbnailFile.parent.create ();
                                tsDownloadingThumbList[dtl][1].copy (verThumbnailFile);
                                if (tsDownloadingThumbList[dtl][4]) {
                                    var workingThumbnailFile = new File (tsDownloadingThumbList[dtl][4]);
                                    if (!workingThumbnailFile.parent.exists)
                                        workingThumbnailFile.parent.create ();
                                    tsDownloadingThumbList[dtl][1].copy (workingThumbnailFile);
                                }
                                tsDownloadingThumbList[dtl][0] = -1;
                                continue;
                            }
                            else {
                                tsDownloadingThumbList[dtl][2] = tsDownloadingThumbList[dtl][1].length;
                            }
                        }
                    }
                    if (tsDownloadingThumbList[dtl][0] > 100) {
                        tsDownloadingThumbList.splice (dtl, 1);
                    }
                }
            }

            //task guest openToEditList 
            var currentTime = new Date().getTime();
            openToEditStep++;
            if (openToEditStep > 0) {
                var modifiedMessageFolder = new Folder (tsDataPath + "/Messages/Modified");
                if (!modifiedMessageFolder.exists) 
                    modifiedMessageFolder.create ();
                for (var c = openToEditList.length - 1; c >= 0; c--) {
                    openToEditList[c][0]++;
                    if (openToEditList[c][0] > 0) {
                        if (openToEditList[c][1].exists) {
                            var newWorkshopTime = openToEditList[c][1].modified.getTime();
                            if (newWorkshopTime > openToEditList[c][2]) {
                                var fileID = tsGetID (openToEditList[c][1]);
                                if (fileID) {
                                    var currentRecordFile = new File (tsDataPath + "/IDs" + fileID + "/CV");
                                    var currentDigits = null;
                                    var isFinal = false;
                                    var currentContent = readFile (currentRecordFile);
                                    if (currentContent) {
                                        currentContent = currentContent.split (":");
                                        currentDigits = currentContent[0];
                                        isFinal = currentContent[1] == "F"? true : false;
                                    }
                                    else {
                                        openToEditList.splice (c, 1);
                                        continue;
                                    }
                                    
                                    var actualModified = tsGetActualModified (newWorkshopTime, fileID);
                                    var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + currentDigits + "/Modifying Time");
                                    var versionTime = readFile (versionTimeFile);
                                    if (actualModified > parseInt (versionTime, 10)) {
                                        var fileDotID = fileID.replace (/\//g,"\.");
                                        fileDotID = fileDotID.slice (1);
                                        writeFile (File (modifiedMessageFolder .fsName.replace(/\\/g, '/') + "/" + fileDotID), currentTime);
                                        tsStartEditing (openToEditList[c][1], fileID, false, null);
                                    }
                                    else {

                                    }
                                }
                                openToEditList.splice (c, 1);
                                continue;
                            }
                        }
                        if (openToEditList[c][0] > 30) {
                            openToEditList.splice (c, 1);
                            continue;
                        }
                    }
                }
                openToEditStep = 0;
            }
            //task guest for new Scope and new Sender
            if (tsIsSendingDone) {
                scopeChangedStep++;
                if (scopeChangedStep > 4) {
                    if (!scopesChangingAlerted) {
                        var allScopeFolders = new Array;
                        var tsDialogsCheckTestList = new Array;
                        for (var tsc = 0; tsc < tsCloudPaths.length; tsc++) {
                            var scopeTemp = Folder (tsCloudPaths[tsc][0] + "/Scopes").getFiles (isUnhiddenFolder);
                            allScopeFolders = allScopeFolders.concat (scopeTemp);
                            //tsDialogsCheckList[x][0] dialogs modification time in x cloud location
                            //tsDialogsCheckList[x][1] first dialog folder modification time
                            //tsDialogsCheckList[x][2] second dialog folder modification time
                            //...
                            var dialogsFolder = Folder (tsCloudPaths[tsc][0] + "/dialogs");
                            if (dialogsFolder.exists) {
                                var tsDialogsCheckItem = [dialogsFolder.modified.getTime ()];
                                var allCloudDialogs = dialogsFolder.getFiles (isUnhiddenFolder);
                                for (var cds = 0; cds < allCloudDialogs.length; cds++) {
                                    tsDialogsCheckItem.push (allCloudDialogs[cds].modified.getTime ());
                                }
                                tsDialogsCheckTestList.push (tsDialogsCheckItem);
                            }
                        }
                        if (tsDialogsCheckList.length != tsDialogsCheckTestList.length) {
                            tsBuildMessagesLists ();
                        }
                        else {
                            for (var dcl = 0; dcl < tsDialogsCheckList.length; dcl++) {
                                if (tsDialogsCheckList[dcl].length != tsDialogsCheckTestList[dcl].length) {
                                    tsBuildMessagesLists ();
                                    break;
                                }
                                else {
                                    var isToRebuild = false;
                                    for (var dcls = 0; dcls < tsDialogsCheckList[dcl].length; dcls++) {
                                        if (tsDialogsCheckList[dcl][dcls] != tsDialogsCheckTestList[dcl][dcls]) {
                                            isToRebuild = true;
                                            break;
                                        }
                                    }
                                    if (isToRebuild) {
                                        tsBuildMessagesLists ();
                                        break;
                                    }
                                }
                            }
                        }
                        if (allScopeFolders.length != tsScopesList.length) {
                            tsBuildMessagesLists ();
                        }
                        else {
                            for (var sl = 0; sl < tsScopesList.length; sl++) {
                                var collaboratorsImageFiles = Folder (tsScopesList[sl][1][5].parent.fsName.replace(/\\/g, '/') + "/Collaborators").getFiles ("*.jpg");
                                if (collaboratorsImageFiles.length - 1 != tsScopesList[sl][2].length) {
                                    tsBuildMessagesLists ();
                                    break;
                                }
                                var scopePathsFolder = new Folder (tsScopesList[sl][1][5].parent.fsName.replace(/\\/g, '/') + "/Synchronizing Paths");
                                var currentPathsDate = (scopePathsFolder.exists) ? scopePathsFolder.modified.getTime() : 0;
                                if (currentPathsDate != tsScopesList[sl][4]) {
                                    tsBuildMessagesLists ();
                                    break;
                                }
                                if (tsScopesList[sl][1][5].modified.getTime() != tsScopesList[sl][1][4]) {
                                    tsBuildMessagesLists ();
                                    break;
                                }
                            }
                        }
                    }
                    scopeChangedStep = 0;
                }
            }
            if (tsWorkingTimeOn) {
                tsWorkingOn ++;
            }
            var newWorkingTimeStep = Math.floor (new Date ().getMinutes ()/5);
            if (tsWorkingTimeStep != newWorkingTimeStep) {
                // new step
                if (tsWorkingTimeOn) { //tsWorkingOn > 3
                    //record new
                    var now = new Date ();
                    var month = now.getMonth () + 1;
                    var day = now.getDate ();
                    var hours = now.getHours();
                    month = month > 9? month.toString () : "0" + month.toString ();
                    day = day > 9? day.toString () : "0" + day.toString ();
                    hours = hours > 9? hours.toString () : "0" + hours.toString ();
                    var step = (newWorkingTimeStep) * 5;
                    step = step > 9? step.toString () : ("0" + step.toString ());
                    var newRecord = tsDataPath + "/Working Time/" + now.getFullYear() + "/" + month + "/" + day + "/" + hours + "/" + step;
                    if (tsOldRecord != "") {
                        var oldRecordFile = new File (tsOldRecord);
                        if (!oldRecordFile.parent.exists)
                            oldRecordFile.parent.create ();
                        writeFile (oldRecordFile, "No Document");
                    }
                    var tsOldRecord = newRecord;
                    var targetInDesign = BridgeTalk.getSpecifier ("indesign");
                    var talkInDesign = new BridgeTalk;
                    talkInDesign.target = targetInDesign;
                    talkInDesign.onResult = function (returnBtObj)
                    { setInDesignScript (returnBtObj.body); }
                    talkInDesign.body = 
                        "testExisting ();\n" +
                        "function testExisting () {\n" +
                            "var docList = new Array;\n" +
                            "docList.push ('" + newRecord + "');\n" + 
                            //"for (var a = 0; a < app.documents.length; a++) {\n" +
                            //"}" + "\n" +

                            "var targetDoc = app.activeDocument;" + "\n" +
                            "var isThere = true;" + "\n" +
                            "try {" + "\n" +
                                "targetDoc.fullName;" + "\n" +
                            "}" + "\n" +
                            "catch (e) {" + "\n" +
                                "isThere = false;" + "\n" +
                            "}" + "\n" +
                            "if (isThere) {" + "\n" +
                                "if (targetDoc.layoutWindows.length > 0) {" + "\n" +
                                    "var docID = targetDoc.metadataPreferences.getProperty('http://ns.dulajun.com/treeshade/', 'TS_ID');\n" +
                                    "if (docID) {\n" +
                                        //"var isModified = false;" + "\n" +
                                        //"if (targetDoc.modified) {" + "\n" +
                                        //     "isModified = true;" + "\n" +
                                        //"}" + "\n" +
                                        //"var mStr = isModified? 'MODIFIED' : 'STILL';" + "\n" +
                                        "var currentTock = app.extractLabel ('activityTock');" + "\n" +
                                        "app.insertLabel ('activityTock', '0');" + "\n" +
                                        "var currentPage = targetDoc.layoutWindows[0].activePage.name;" + "\n" +
                                        "docList.push (docID + ':' + currentPage + ':' + currentTock);\n" +
                                        //"if (isModified) {" + "\n" +
                                            //"targetDoc.save ();" + "\n" +
                                        //"}" + "\n" +
                                    "}\n" +
                                
                                "}" + "\n" +
                            "}" + "\n" +                    
                            
                            "return docList;\n" +
                        "}\n";
                    talkInDesign.send ();
                    function setInDesignScript (theBody) {
                        if (theBody) {
                            theBody = theBody.split (",");
                            if (theBody.length > 0) {
                                var newFile = new File (theBody[0]);
                                if (!newFile.parent.exists)
                                    newFile.parent.create ();
                                theBody.splice (0, 1);
                                var content;
                                if (theBody.length == 0)
                                    content = "No Document";
                                else
                                    content = theBody.join ("\n");
                                if (content.lastIndexOf(":0") == content.length - 2) {
                                    tsAbandonedDocCounter++;
                                }
                                else {
                                    tsAbandonedDocCounter = 0;
                                }
                                if (tsAbandonedDocCounter > 3) {
                                    content = "No Document";
                                }
                                if (content != "No Document") {
                                    writeFile (newFile, content);
                                    tsOldRecord = "";
                                }
                            }
                        }
                    }
                }
                tsWorkingOn = 0;
            }
            tsWorkingTimeStep = newWorkingTimeStep;
        }
    }
}

function ambushingTask () {
    /**///$.writeln ($.line);

}

function finalizeBeforeQuitOrChangeRoot (isForQuit) {
    /**///$.writeln ($.line);
    var isResetAll = false;
    var isForcedToReset = false;
    if (!tsIsMessagesStoped) {
        tsIsMessagesStoped = true;
    }
    isThereMessages = false;
    for (var st = 0; st < sendersList.length; st++) {
        if (sendersList[st][2][0].length > 0) {
            isThereMessages = true;
            break;
        }
        if (sendersList[st][2][0].length > 0) {
            isThereMessages = true;
            break;
        }
        if (sendersList[st][2][1].length > 0) {
            isThereMessages = true;
            break;
        }
        if (sendersList[st][2][2].length > 0) {
            isThereMessages = true;
            break;
        }
        if (sendersList[st][2][3].length > 0) {
            isThereMessages = true;
            break;
        }
        if (sendersList[st][2][4].length > 0) {
            isThereMessages = true;
            break;
        }
        if (sendersList[st][2][5].length > 0) {
            isThereMessages = true;
            break;
        }
    }
    if (tsIDTimePathStepIsUserOldPathList.length == 0 
            && InDesignCheckInList.length == 0 
            && tsAlertPDFPreviewList.length == 0
            && tsLiveSnippetCheckInList.length == 0 
            && !isThereMessages 
            && tsIsSendingDone 
            && tsPathChangedThumbList.length == 0 
            && tsDownloadingThumbList.length == 0 
            && tsVersionsToWorkshopList.length == 0 
            && tsCheckedInThumbnailsList.length == 0 
            && tsUploadThumbnailsList.length == 0 
            && tsCopyToList.length == 0) 
    {
        isResetAll = true;
    }
    else {
        if (quitRequestTime == null) {
            quitRequestTime = new Date().getTime();
        }
        else {
            var currentTime = new Date().getTime();
            if (currentTime - quitRequestTime > 60000) {
                isForcedToReset = true;
            }
        }
    }
    if (isResetAll || isForcedToReset) {
        if (isForQuit) {
            okNowYouCanQuit = true;
            var labourFile = new File (tsDataPath + "/Scanning/Labour");
            labourFile.remove ();
            var vacancyFile = new File (tsDataPath + "/Scanning/Vacancy");
            writeFile (vacancyFile, tsClientID);
    
            var userSettingContent = tsUserTask + "\n" + tsUserID + "\n" + tsRecentNewFromPath + "\n" + tsTemplatesPath + "\n" + tsChangeTemplate + "\n" + tsIsStaticIDs;
            if (!tsUserSettingFile) {
                tsUserSettingFile = new File (tsRootFolderPath + "/Settings/" + tsClientID + " Preferences");
            }
            if (!tsUserSettingFile.parent.exists)
                tsUserSettingFile.parent.create ();
            writeEncodedFile (tsUserSettingFile, userSettingContent);
            
            //saving tsScanningQueue
            var scanningQueueFile = new File (tsDataPath + "/TS_SQ");
            if (!scanningQueueFile.parent.exists)
                scanningQueueFile.parent.create ();
            writeEncodedFile (scanningQueueFile, tsScanningQueue.join ("\n"));
            
            //saving tsConsiderSwapList
            //tsConsiderSwapList
            //tsConsiderSwapList[x][0] adding time
            //tsConsiderSwapList[x][1] file path
            //tsConsiderSwapList[x][2] file name
            var considerSwapListLines = new Array;
            for (var cs = tsConsiderSwapList.length - 1; cs >= 0; cs--) {
                considerSwapListLines.push (tsConsiderSwapList[cs][0] + ":" + tsConsiderSwapList[cs][1] + ":" + tsConsiderSwapList[cs][2]);
            }
            if (considerSwapListLines.length > 0) {
                var considerSwapListFile = new File (tsDataPath + "/TS_CS");
                writeEncodedFile (considerSwapListFile, considerSwapListLines.join ("\n"));
            }

            var tsChangeShortcutsFile = new File (tsDataPath + "/Change Shortcuts.txt");
            tsChangeShortcutsFile.encoding = "UTF8";
            writeFile (tsChangeShortcutsFile, tsChangeShortcuts.join ("\n"));
            app.quit ();
        }
        else {
            tsUserTask = "Scanning";
            tsUserID = null;
            tsUserName = "";
            tsUserEmail = "";
            tsUserImage = null;
            tsRecentNewFromPath = "BBB";
            tsTemplatesPath = "CCC";
            tsChangeTemplate = "";
            tsIsStaticIDs = false;
            tsWorkshopPath = "";
            tsPagesPath = "";
            tsDataPath = "";
            tsVersionsPath = "";
            tsFinalPDFPath = "";
            tsVersionsPDFPath = "";
            tsVersionsPages = "";
            tsCloudPaths = new Array;
            tsTrashPath = "";
            tsMainInterval = 238;
            tsAmbushingStep = 0;
            tsScanningStep = 0;
            tsFakeModifiedStep = 7;
            tsPhysicalPDFStep = 17;
            tsAlertPathChangedStep = 4;
            tsOnlineInterval = 600000;
            tsDownloadingStep = 0;
            tsMessagesScanStep = 0;
            tsRandomTimeTaskStep = 0;
            tsMessagesCleanStep = 5260;
            tsMessagesStep = 54;
            tsCopyToStep = 11;
            tsGrowingInterval = 1;
            tsFoldersChanged = new Array;
            tsSuspectedFolders = new Array;
            tsLoadedFolders = new Array;
            tsToBeSelectedList = new Array;
            tsChangeList = [0];
            tsLastSelected = null;
            tsBeforeLastSelectedFullPath = null;
            tsBeforeLastSelectedSize = null;
            tsPickedFilesListWithSubs = new Array;
            tsToBeSelectedThumbnail = null;
            tsIDTimePathStepIsUserOldPathList = new Array;
            tsOldModifiedFileIDList = new Array;
            tsPhysicalPDFList = new Array;
            tsDownloadingList = new Array;
            tsLoadStage = 0;
            tsSendingBoxesStep = 0;
            tsSendingBoxesSpan = 2;
            tsProducingWorkSheetSteps = 4670;
            tsIsToRestart = 0;
            tsIsWideScanning = false;
            tsIsWideScanningUltimate = false;
            tsAbandonedDocCounter = 0;
            tsNewFromRemoteTargetFolder = null;
            
            growingFolders = new Array;
            isOddStage = false;
            suspectedOdd = new Array;
            suspectedEven = new Array;
            isBlackSide = false;
            tsIsPhysicalFinished = false;
            isNoDeleteTSQueries = true;
            openToEditStep = 0;
            scopeChangedStep = 0;
            scopesChangingAlerted = false;
            tsLoadedPreviousDate = new Date().getTime();
            closingRequested = false;
            tsChangeRootRequested = false;
            okNowYouCanQuit = false;
            tsInitializeAlerts = false;
            tsInitializeStep = 4;
            quitRequestTime = null;
            tsWorkingTimeOn = true;
            tsWorkingOn = 0;
            tsWorkingTimeStep = Math.floor (new Date ().getMinutes ()/5);
            tsCheckSenderStep = 0;
            tsCheckSendersSpan = 30;
            tsIsMessagesStoped = false;
            tsIsStartPDFExporting = false;
            tsNewCollaborators = new Array;
            tsIsScanningStopped = 2;
            tsOldRecord = "";
            startScanAtZero = 4;
            //
            sendersList = new Array;
            recipientsList = new Array;
            InDesignLoadList = new Array;
            InDesignCheckInList = new Array;
            tsAlertPDFPreviewList = new Array;
            tsAlertPDFPreviewStep = 0;
            tsReopenAfterRenameList = new Array;
            tsChangeAfterCloseList = new Array;
            tsLiveSnippetCheckInList = new Array;
            tsAutoCheckInFilesList = new Array;            
            tsAutoCheckInList = new Array;
            tsAutoCheckInFilesList = new Array;
            tsAutoCheckInFilesStep = 0;
            openToEditList = new Array;
            insideIDsList = new Array;
            tsScanningQueue = new Array;
            tsOrdersList = new Array;
            tsGroupedOrdersList = new Array;
            onlineCollaborators = new Array;
            emptyFoldersList = new Array;
            emptyFoldersList.push (new Array); //emptyFoldersList[0] tsWorkshopPath List
            emptyFoldersList.push (new Array); //emptyFoldersList[1] non tsWorkshopPath List
            emptyFoldersStep = 0;
            tsCheckedInThumbnailsList = new Array;
            tsPathChangedThumbList = new Array;
            tsDownloadingThumbList = new Array;
            tsUploadThumbnailsList = new Array;
            tsCopyToList = new Array;
            tsVersionsToWorkshopList = new Array;
            tsVersionsToWorkshopStep = 0;
            tsLinksLoadList = new Array;
            tsLinksLoadList.push (new Array); //tsLinksLoadList[0] waiting list before check list
            tsLinksLoadList.push (new Array); //tsLinksLoadList[1] to be checked and to be requested list
            tsLinksLoadList.push (new Array); //tsLinksLoadList[2] requested list  
            tsConsiderSwapList = new Array;
            tsConsiderSwapStep = 0;
            tsLinksLoadStep = 0;
            tsDialogsCheckList = new Array;
            cleanningIndex = 0;
            isAlertedToRestart = false;
            thumbnailList = new Array;
            thumbnailVersionList = new Array;
            newVersionDigitsFileIDTriple = null;
            thumbnailWaitingSteps = 100;
            isThereMessages = false;
            tsIsSendingDone = true;
            tsIsVersionsOutputToWorkshop = false;
            tsIsSwitchWithInDesign = false;
            tsIsIgnoreVersionOwner = false;
            tsIsRespondToManuallyDeleted = false;
            tsVersionsOutputZero = "NO_ZERO";
            tsTreeShadeThumb = "/.TREESHADE/.THUMB/";
            isNewMessage = false;
            isSelectionChangedByUser = true;
            tsSelectionChangedByUserDate = new Date().getTime();
            lastSwitchingTime = new Date().getTime();
            tsTextEditorOpened = false;
            tsEditText = null;
            tsUserKeyDate = new Date ().getTime ();
            tsUserKeyValue = "";
            tsChangeShortcuts = new Array;
            tsTaskStage = 0;
        }
    }
}

function tsForgeSenderArray (recipientIndex, senderFolder) {
    //sendersList
    //sendersList[x][0][0]: the sender id
    //sendersList[x][0][1]: the sender folder object
    //sendersList[x][0][2]: the sender scopes array
    //sendersList[x][0][3]: recipient index
    //sendersList[x][1]: message folder data
    //sendersList[x][2]: recievingBoxes
    
    var senderArray = new Array;
    var senderInfo = new Array;
    
    senderInfo.push (File.decode (senderFolder.name).slice (4)); //senderArray[0][0]: the sender id
    senderInfo.push (senderFolder); //senderArray[0][1]: the sender folder object
    senderInfo.push (new Array); //senderArray[0][2]: the sender scopes array
    senderInfo.push (recipientIndex); //senderArray[0][3]: recipient index
    senderArray.push (senderInfo); 

    senderArray.push (new Array); //senderArray[1]: message folder data
    senderArray[1].push (new Folder (senderFolder.fsName.replace(/\\/g, '/') + "/SyncInfo")); //the messages folder object cell
    senderArray[1].push( new Array); //Level A
    senderArray[1].push( new Array); //Level B
    senderArray[1].push( new Array); //Level C
    senderArray[1][1].push (-1); //senderArray[1][1][0]: Level A index value
    senderArray[1][2].push (-1); //senderArray[1][2][0]: Level B index value
    senderArray[1][3].push (-1); //senderArray[1][3][0]: Level C index value
    senderArray[1][1].push (new Array); //senderArray[1][1][1]: Level A Folders Array Cell
    senderArray[1][2].push (new Array); //senderArray[1][2][1]: Level B Folders Array Cell
    senderArray[1][3].push (new Array); //senderArray[1][3][1]: Level C Folders Array Cell

    //recievingBoxes
    //senderArray[2][0][x][0] message tree shade id
    //senderArray[2][0][x][1] message body
    senderArray.push (new Array); //senderArray[2]: 
    senderArray[2].push (new Array); //senderArray[2][0] PathChanged
    senderArray[2].push (new Array); //senderArray[2][1] Download
    senderArray[2].push (new Array); //senderArray[2][2] HaveYou
    senderArray[2].push (new Array); //senderArray[2][3] YesIHave
    senderArray[2].push (new Array); //senderArray[2][4] IRequest
    senderArray[2].push (new Array); //senderArray[2][5] NewState
    
    return senderArray;
}

function tsForgeRecipientArray (recipientID, recipientFolder, sharingState, senderIndex) {
    //recipientsList
    //recipientsList[x][0] recipient ID
    //recipientsList[x][1] folder object
    //recipientsList[x][2] scopes list
    //recipientsList[x][3] sharing State as string "Shared", "Requested", "Not Yet"
    //recipientsList[x][4] Sender Index

    var recipientArray = new Array;
    recipientArray.push (recipientID); //recipientsList[x][0] recipient ID
    recipientArray.push (recipientFolder); //recipientsList[x][1] folder object
    recipientArray.push (new Array); //recipientsList[x][2] scopes list
    recipientArray.push (sharingState); //recipientsList[x][3] sharing State as string "Shared", "Requested", "Not Yet"
    recipientArray.push (senderIndex); //recipientsList[x][4] Sender Index    
    
    return recipientArray;
}

function tsBuildMessagesLists () {
    
    /**///$.writeln ($.line);
    var nowTime = new Date ().getTime ();
    
    var activeScopesFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Active");
    var activeScopesFolderFiles = activeScopesFolder.getFiles ();
    for (var sff = 0; sff < activeScopesFolderFiles.length; sff++) {
        activeScopesFolderFiles[sff].remove();
    }
    var repeatedScopesFolder = new Folder (tsRootFolderPath + "/Workflow/Scopes/Repeated");
    deleteForcelyFolders (repeatedScopesFolder, false);
    var allCollaboratorsFolder = new Folder (tsRootFolderPath + "/Workflow/Collaborators/All");
    var activeCollaboratorsFolder = new Folder (tsRootFolderPath + "/Workflow/Collaborators/Active");
    deleteForcelyFolders (activeCollaboratorsFolder, false);
    var newCollaboratorsFolder = new Folder (tsRootFolderPath + "/Workflow/Collaborators/New");
    if (!newCollaboratorsFolder.exists) {
        newCollaboratorsFolder.create ();
    }
    else {
        var newCollaboratorsFiles = newCollaboratorsFolder.getFiles ();
        for (var ncf = 0; ncf < newCollaboratorsFiles.length; ncf++) {
            newCollaboratorsFiles[ncf].remove ();
        }
    }
    var onlineCollaboratorsFolder = new Folder (tsRootFolderPath + "/Workflow/Collaborators/Online");
    deleteForcelyFolders (onlineCollaboratorsFolder, false);
    activeScopesFolder.create ();
    repeatedScopesFolder.create ();
    allCollaboratorsFolder.create ();
    activeCollaboratorsFolder.create ();
    var dialogFolders = new Array;
    for (var cps = 0; cps < tsCloudPaths.length; cps++) {
        var dialogsFolder = Folder (tsCloudPaths[cps][0] + "/Dialogs");
        if (!dialogsFolder.exists)
            dialogsFolder.create ();
        var dialogTemp = dialogsFolder.getFiles (isUnhiddenFolder);
        dialogFolders = dialogFolders.concat (dialogTemp);
    }
    var senderRecipientPairs = new Array;
    for (var df = 0; df < dialogFolders.length; df++) {
        var userIDFolder = new Folder (dialogFolders[df].fsName.replace(/\\/g, '/') + "/.ID " + tsUserID);
        if (!userIDFolder.exists)
            userIDFolder.create ();
        var senderRecipientPair = dialogFolders[df].getFiles (".ID *");
        var senderRecipientItems = new Array;
        if (senderRecipientPair.length == 2) {
            if (File.decode (senderRecipientPair[0].name).slice (4) == tsUserID) {
                senderRecipientItems.push (senderRecipientPair[1]);
                senderRecipientItems.push (senderRecipientPair[0]);
            }
            else if (File.decode (senderRecipientPair[1].name).slice (4) == tsUserID) {
                senderRecipientItems.push (senderRecipientPair[0]);
                senderRecipientItems.push (senderRecipientPair[1]);
            }
            else {
                continue;
            }
            var isToContinue = false;
            for (var srp = senderRecipientPairs.length - 1; srp >= 0; srp--) {
                if (File.decode (senderRecipientPairs[srp][0].name) == File.decode (senderRecipientItems[0].name)) {
                    //repeated
                    if (senderRecipientPairs[srp][0].parent.created.getTime () < senderRecipientItems[0].parent.created.getTime ()) {
                        deleteForcelyFolders (dialogFolders[df], true);
                        isToContinue = true;
                        break;
                    }
                    else {
                        deleteForcelyFolders (senderRecipientPairs[srp][0].parent, true);
                        senderRecipientPairs.splice (srp, 1);
                        break;
                    }
                }
            }
            if (isToContinue)
                continue;
        }
        else {
            continue;
        }
        senderRecipientPairs.push (senderRecipientItems);
    }
    tsDialogsCheckList = new Array;
    for (var cps = 0; cps < tsCloudPaths.length; cps++) {
        var dialogsFolder = Folder (tsCloudPaths[cps][0] + "/Dialogs");
        var tsDialogsCheckItem = [dialogsFolder.modified.getTime ()];        
        var allCloudDialogs = dialogsFolder.getFiles (isUnhiddenFolder);
        for (var cds = 0; cds < allCloudDialogs.length; cds++) {
            tsDialogsCheckItem.push (allCloudDialogs[cds].modified.getTime ());
        }
        tsDialogsCheckList.push (tsDialogsCheckItem);
    }

    sendersList = new Array;
    for (var f = 0; f < senderRecipientPairs.length; f++) {     
        sendersList.push (tsForgeSenderArray (f, senderRecipientPairs[f][0])); //the sender array 
    }
    
    recipientsList = new Array;
    for (var ou = 0; ou < senderRecipientPairs.length; ou++) {
        recipientsList.push (tsForgeRecipientArray (File.decode (senderRecipientPairs[ou][0].name).slice (4), senderRecipientPairs[ou][1], "Dialog", ou));
    }
    
    var activeScopes = new Array;
    for (var tsc = 0; tsc < tsCloudPaths.length; tsc++) {
        var scopeTemp = Folder (tsCloudPaths[tsc][0] + "/Scopes").getFiles (isUnhiddenFolder);
        activeScopes = activeScopes.concat (scopeTemp);
    }
    tsScopesList = new Array;
    //tsScopesList[a][0]   scope id
    //tsScopesList[a][1]   scope info from info file
        //tsScopesList[a][1][0]   scope name
        //tsScopesList[a][1][1]   scope description
        //tsScopesList[a][1][2]   scope email
        //tsScopesList[a][1][3]   scope auto loading "Auto Load", "No Load"
        //tsScopesList[a][1][4]   scope info file modified
        //tsScopesList[a][1][5]   scope info file object
    //tsScopesList[a][2]   array of recipients indexes
    //tsScopesList[a][3]   cleanning list
    //tsScopesList[a][4]   Synchronizing Paths folder modified
    //tsScopesList[a][5]   paths triples

    //tsRootsList[0][0] the folder name
    //tsRootsList[0][1] the scopes' indexes list

    tsRootsList = new Array;
    tsRootsList.push (new Array);
    tsRootsList[0].push ("");
    tsRootsList[0].push (new Array);
    tsRootsList.push (new Array);
    
    var scopeCollaboratorsList = new Array;
    for (var sc = 0; sc < activeScopes.length; sc++) {
        scopeCollaboratorsList.push (Folder (activeScopes[sc].fsName.replace(/\\/g, '/') + "/Collaborators").getFiles ("*.jpg"));
    }
    for (sc = 0; sc < activeScopes.length - 1; sc++) {
        for (var ssc = sc + 1; ssc < activeScopes.length; ssc++) {
            if (scopeCollaboratorsList[sc].length > scopeCollaboratorsList[ssc].length) { //swap both activeScopes and scopeCollaboratorsList
                var scopeSpoon = activeScopes[sc];
                activeScopes[sc] = activeScopes[ssc];
                activeScopes[ssc] = scopeSpoon;
                var collSpoon = scopeCollaboratorsList[sc];
                scopeCollaboratorsList[sc] = scopeCollaboratorsList[ssc];
                scopeCollaboratorsList[ssc] = collSpoon;
            }
        }
    }
    for (sc = 0; sc < activeScopes.length; sc++) {
        var scopeListItem = new Array;
        var scopeInfoFile = activeScopes[sc].getFiles ("Scope *.jpg");
        if (scopeInfoFile.length != 1) {
            /*if (scopeInfoFile.length == 0) {
                var tempScopeID = TSProduceID ();
                scopeInfoFile = new File (activeScopes[sc].fsName.replace(/\\/g, '/') + "/Scope " + tempScopeID + ".jpg");                
                File (File($.fileName).parent.fsName.replace(/\\/g, '/') + "/Tree Shade Resources/Scope Image Template.jpg").copy (scopeInfoFile);                
                if (!tsUpdateScopeInfo (scopeInfoFile, [File.decode (activeScopes[sc].name).replace ("Scope ", ""), "No Description", "No Email", "Auto Load"])) {
                    return false;
                }
                tsSetScopeID (scopeInfoFile, tempScopeID);
            }
            else { 
                continue;
            }*/
            continue;
        }
        else {
            scopeInfoFile = scopeInfoFile[0];
        }
        scopeListItem.push (File.decode (scopeInfoFile.name).slice (6, File.decode (scopeInfoFile.name).lastIndexOf ("."))); //tsScopesList[a][0]   scope id
        var isToContinue = false;
        var repeatedScopeMarkFile = new File (activeScopes[sc].fsName.replace(/\\/g, '/') + "/Marks/Repeated.txt");
        if (repeatedScopeMarkFile.exists) {
            isToContinue = true;
            var repeatedScopesShortcut = new File (repeatedScopesFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (activeScopes[sc].name));
            repeatedScopesShortcut.createAlias (repeatedScopeMarkFile);
        }
        else {
            for (var sol = tsScopesList.length - 1; sol >= 0; sol--) {
                if (tsScopesList[sol][0] == scopeListItem[0]) {//The scope id is repeated repeatedScopesFolder
                    if (tsScopesList[sol][1][5].parent.created.getTime() < activeScopes[sc].created.getTime()) {
                        if (!repeatedScopeMarkFile.parent.exists)
                            repeatedScopeMarkFile.parent.create ();
                        writeFile (repeatedScopeMarkFile, "This Tree Shade Scope is Repeated!");
                        var repeatedScopesShortcut = new File (repeatedScopesFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (activeScopes[sc].name));
                        repeatedScopesShortcut.createAlias (repeatedScopeMarkFile);
                        isToContinue = true;
                        break;
                    }
                    else {
                        if (!repeatedScopeMarkFile.parent.exists)
                            repeatedScopeMarkFile.parent.create ();
                        writeFile (repeatedScopeMarkFile, "This Tree Shade Scope is Repeated!");
                        return tsBuildMessagesLists ();
                    }
                }
            }
        }
        if (isToContinue)
            continue;
        var scopeInfo = tsGetScopeInfo (scopeInfoFile);
        if (!scopeInfo) {
            continue;
        }
        if ("Scope " + scopeInfo[0] != File.decode (activeScopes[sc].name)) {
            activeScopes[sc].rename ("Scope " + scopeInfo[0]);
            scopeInfoFile = new File (activeScopes[sc].fsName.replace(/\\/g, '/') + "/Scope " + scopeListItem[0] + ".jpg");
        }
        var metadataID = tsGetScopeID (scopeInfoFile);
        if (metadataID != scopeListItem[0]) {
            tsSetScopeID (scopeInfoFile, scopeListItem[0]);
        }
        scopeInfo.push (scopeInfoFile.modified.getTime()); //tsScopesList[a][1][4]   scope info file modified
        scopeInfo.push (scopeInfoFile);//tsScopesList[a][1][5]   scope info file object
        scopeListItem.push (scopeInfo); //tsScopesList[a][1]   scope info from info file
        scopeListItem.push (new Array); //tsScopesList[a][2]   array of recipients indexes
        var scopeAliasFile = new File (activeScopesFolder.fsName.replace(/\\/g, '/') + "/" + scopeListItem[1][0] + ".jpg");
        scopeListItem[1][5].copy (scopeAliasFile);
        var myImageFile = null;

        //Scan allCollaboratorsFolder
        var allCollaboratorsArray = new Array;
        var allCollaboratorsActiveArray = new Array;
        var allCollaboratorsFiles = allCollaboratorsFolder.getFiles ("*.jpg");
        for (var acf = 0; acf < allCollaboratorsFiles.length; acf++) {
            var imageInfo = tsGetUserInfo (allCollaboratorsFiles[acf]);
            if (!imageInfo)
                continue;
            allCollaboratorsArray.push ([imageInfo[0], allCollaboratorsFiles[acf]]);
            var ratingThumbnail = new Thumbnail (allCollaboratorsFiles[acf]);
            ratingThumbnail.rating = 0;
        }
        var collaboratorsList = scopeCollaboratorsList[sc];
        var IDsScanList = new Array;
        for (var i = 0; i < collaboratorsList.length; i++) {
            var imageInfo = tsGetUserInfo (collaboratorsList[i]);
            if (!imageInfo)
                continue;
            var collaboratorID = imageInfo[0];
            var isRepeated = false;
            for (var ids = 0; ids < IDsScanList.length; ids++) {
                if (IDsScanList[ids] == collaboratorID) {
                    collaboratorsList[i].remove ();
                    isRepeated = true;
                    break;
                }
            }
            if (isRepeated)
                continue;
            IDsScanList.push (collaboratorID);
            if (collaboratorID == tsUserID) {
                myImageFile = collaboratorsList[i];
                continue;
            }
            var scopeRecipientIndex = tsGetRecipientIndex (collaboratorID);
            if (scopeRecipientIndex == -1) {
                var recipientFolder = new Folder (activeScopes[sc].fsName.replace(/\\/g, '/') + "/.Pairs" + "/.ID " + collaboratorID + "/.ID " + tsUserID);
                if (!recipientFolder.exists)
                    recipientFolder.create ();
                var recipientArray = tsForgeRecipientArray (collaboratorID, recipientFolder, "Pair", sendersList.length);
                scopeRecipientIndex = recipientsList.length;
                recipientsList.push (recipientArray);

                var senderFolder = new Folder (activeScopes[sc].fsName.replace(/\\/g, '/') + "/.Pairs" + "/.ID " + tsUserID + "/.ID " + collaboratorID);
                if (!senderFolder.exists) 
                    senderFolder.create ();
                sendersList.push (tsForgeSenderArray (scopeRecipientIndex, senderFolder));
            }

            if (recipientsList[scopeRecipientIndex].length < 6) {
                //recipientsList[x][5] full name
                //recipientsList[x][6] email
                //recipientsList[x][7] image file object
                //recipientsList[x][8] sendingBoxesList
                recipientsList[scopeRecipientIndex].push (imageInfo[1]); //recipientsList[x][5] full name
                recipientsList[scopeRecipientIndex].push (imageInfo[2]); //recipientsList[x][6] email
                recipientsList[scopeRecipientIndex].push (collaboratorsList[i]); //recipientsList[x][7] image file object
                //Check allCollaboratorsArray
                for (var aca = 0; aca < allCollaboratorsArray.length; aca++) {
                    if (recipientsList[scopeRecipientIndex][0] == allCollaboratorsArray[aca][0]) {
                        allCollaboratorsArray[aca][1].remove ();
                        allCollaboratorsArray.splice (aca, 1);
                        break;
                    }
                }
                var collaboratorAllFile = new File (allCollaboratorsFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (recipientsList[scopeRecipientIndex][7].name));
                var collaboratorAliasFile = new File (activeCollaboratorsFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (recipientsList[scopeRecipientIndex][7].name));
                recipientsList[scopeRecipientIndex][7].copy (collaboratorAllFile);
                recipientsList[scopeRecipientIndex][7].copy (collaboratorAliasFile);
                var ratingThumbnail = new Thumbnail (collaboratorAllFile);
                allCollaboratorsActiveArray.push ([recipientsList[scopeRecipientIndex][0], ratingThumbnail]);
                ratingThumbnail.rating = 2;
            }

            recipientsList[scopeRecipientIndex][2].push(tsScopesList.length);
            scopeListItem[2].push (scopeRecipientIndex); //tsScopesList[a][2][x]  new recipient's index added to current scope
        }
    
        if (myImageFile == null) {
            if (tsUserImage.exists) {
                myImageFile = new File (activeScopes[sc].fsName.replace(/\\/g, '/') + "/Collaborators/" + tsUserName + ".jpg");
                myImageFile.parent.create ();
                tsUserImage.copy (myImageFile);
            }
            else {
                alert ("Tree Shade User Image is missed!\nWhich supposed to be here:\n" + tsUserImage.fsName.replace(/\\/g, '/'));
                return false;
            }
        }

        //tsScopesList[a][3]   cleanning list
        var scopeCleanItem = new Array;
        var messagesPhysicalFolder = new Folder (activeScopes[sc].fsName.replace(/\\/g, '/') + "/.tssync");
        scopeCleanItem.push (messagesPhysicalFolder);
        scopeCleanItem.push(new Array); //Level A
        scopeCleanItem.push(new Array); //Level B
        scopeCleanItem.push(new Array); //Level C
        scopeCleanItem[1].push (-1); //Level A index value
        scopeCleanItem[2].push (-1); //Level B index value
        scopeCleanItem[3].push (-1); //Level C index value
        scopeCleanItem[1].push (new Array); //Level A Folders Array Cell
        scopeCleanItem[2].push (new Array); //Level B Folders Array Cell
        scopeCleanItem[3].push (new Array); //Level C Folders Array Cell            
        scopeListItem.push (scopeCleanItem);
        
        //Synchronizing Paths 
        var scopePathsFolder = new Folder (activeScopes[sc].fsName.replace(/\\/g, '/') + "/Synchronizing Paths");
        var scopePaths = new Array;
        var synchronizingPathsFiles = scopePathsFolder.getFiles (isUnhiddenFile);
        for (var spf = 0; spf < synchronizingPathsFiles.length; spf++) {
            synchronizingPathsContent = readEncodedFile (synchronizingPathsFiles[spf]);
            if (!synchronizingPathsContent)
                continue;
            synchronizingPathsContent = synchronizingPathsContent.split ("\n");
            //synchronizingPathsContent
            //synchronizingPathsContent[0] Folder Label ID
            //synchronizingPathsContent[1] Label Date
            //synchronizingPathsContent[2] Assigner ID (Collaborator ID)
            //synchronizingPathsContent[3] Label Text
            if (synchronizingPathsContent.length < 4)
                continue;
            var absolutePath = File.decode (synchronizingPathsFiles[spf].name).replace(/\s➔\s/g, "/");
            var currentLabel = new Folder (tsWorkshopPath + "/" + absolutePath).getFiles (tsIsLabelFile);
            var isSame = false;
            if (currentLabel.length > 0) {
                var currentLabelID = tsGetID (currentLabel[0]);
                if (currentLabelID) {
                    if (currentLabelID != synchronizingPathsContent[0]) { //The label is forbidden and reserved already
                        continue;
                    }
                    else {
                        isSame = true;
                    }
                }
            }
            
            var pathID = synchronizingPathsContent[0];
            var absolutePath = File.decode (synchronizingPathsFiles[spf].name).replace(/\s➔\s/g, "/");
            addKnob (tsRootsList[1], tsScopesList.length, absolutePath);
            
            if (!isSame) {
                var fileID_Path_newID = [synchronizingPathsContent[0]];
                tsGetPath (fileID_Path_newID);
                if (!fileID_Path_newID[1] && !fileID_Path_newID[2]) {
                    tsUpdatePath (synchronizingPathsContent[2], synchronizingPathsContent[0], synchronizingPathsContent[1], "/" + absolutePath + "/" + synchronizingPathsContent[3]); //(senderID, fileID, modificationTime, newPath)
                }
            }

            var pathItems = new Array;
            //[0] folder full path
            //[1]  trsd ID
            //[2] trsd name 
            pathItems.push (absolutePath);
            pathItems.push (pathID);
            pathItems.push (synchronizingPathsContent[3]);
            scopePaths.push (pathItems);
        }
        //tsScopesList[a][4]   Synchronizing Paths folder modified
        scopeListItem.push (scopePathsFolder.exists? scopePathsFolder.modified.getTime () : 0);
        //tsScopesList[a][5]   paths triples
        scopeListItem.push (scopePaths);
        
        tsScopesList.push (scopeListItem);
    }

    //mark any recipients who doesn't belong to any scope and adjust folders for pairs
    var homelessRecipientsReport = "Out of all scopes recipients:\n";
    for (var recir = recipientsList.length - 1; recir >= 0; recir--) {
        if (recipientsList[recir][2].length == 0) {
            for (var acaa = 0; acaa < allCollaboratorsActiveArray.length; acaa++) {
                if (recipientsList[recir][0] == allCollaboratorsActiveArray[acaa][0]) {
                    allCollaboratorsActiveArray[acaa][1].rating = 1;
                    allCollaboratorsActiveArray.splice (acaa, 1);
                    break;
                }
            }
            homelessRecipientsReport += "\n";
            homelessRecipientsReport += recipientsList[recir][0] + "\t" + recipientsList[recir][6] + "\t" + recipientsList[recir][5];
        }
    }

    var homelessRecipientsReportFile = new File (tsRootFolderPath + "/Workflow/Reports/Collaborators Out of Scopes.txt");
    if (!homelessRecipientsReportFile.parent.exists)
        homelessRecipientsReportFile.parent.create ();
    if (homelessRecipientsReport == "Out of all scopes recipients:\n") {
        writeFile (homelessRecipientsReportFile, "No Collaborator is Out");
    }
    else {
        writeFile (homelessRecipientsReportFile, homelessRecipientsReport);
    }

    for (var rls = 0; rls < recipientsList.length; rls++) {
        if (recipientsList[rls][3] == "Pair") {
            var newCollaboratorFile = new File (newCollaboratorsFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (recipientsList[rls][7].name));
            recipientsList[rls][7].copy (newCollaboratorFile);
        }
        else {
            if (recipientsList[rls].length < 6) {
                recipientsList[rls].push ("No Name");
                recipientsList[rls].push ("No Email");
                recipientsList[rls].push (null);
            }
            else {
                if (File.decode (recipientsList[rls][1].parent.name) != "Collaborator " + recipientsList[rls][5]) {
                    var pathRest = recipientsList[rls][1].parent.parent.fsName.replace(/\\/g, '/');
                    if (recipientsList[rls][1].parent.rename ("Collaborator " + recipientsList[rls][5])) {
                        recipientsList[rls][1] = new Folder (pathRest + "/Collaborator " + recipientsList[rls][5] + "/.ID " + tsUserID);
                        if (recipientsList[rls][4] != -1) {
                            sendersList[recipientsList[rls][4]][0][1] = new Folder (pathRest + "/" + recipientsList[rls][5] + "/.ID " + sendersList[recipientsList[rls][4]][0][0]);
                            sendersList[recipientsList[rls][4]][1][0] = new Folder (pathRest + "/" + recipientsList[rls][5] + "/.ID " + sendersList[recipientsList[rls][4]][0][0] + "/SyncInfo");
                        }
                    }
                }
            }
        }
        
        //recipientsList[x][8]
        //sendingBoxesList
        recipientsList[rls].push (new Array);
        recipientsList[rls][8].push (0); //sendingBoxesList[0] the date
        recipientsList[rls][8].push (new Array);
        //sendingBoxesList[1][x][0] message head
        //sendingBoxesList[1][x][1] message tree shade ID
        //sendingBoxesList[1][x][2] message body
    } 

    var preferencesFiles = Folder (tsRootFolderPath + "/Settings").getFiles ("*Preferences");
    for (var pf = 0; pf < preferencesFiles.length; pf++) {
        var userLines = readEncodedFile (preferencesFiles[pf]).split ("\n");
        if (userLines.length == 6) {
            if (userLines[1] != tsUserID) {
                var data = new Array;
                //data[0] user id
                //data[x] ...
                data.push (userLines[1]);
                insideIDsList.push (data);
            }
        }
    }

    extractRecipients (tsRootsList, new Array);
    return true;
}

function extractRecipients (folderKnob, parentScopes) {
    /**///$.writeln ($.line);
    //add own scopes to the list
    for (var c = 0; c < folderKnob[0][1].length; c++) {
        parentScopes.push (folderKnob[0][1][c]);
    }

    //processing
    var autoLoadScopes = new Array;
    //autoLoadScopes[a][0] scope index
    //autoLoadScopes[a][1] pure recipients indexes
    var noLoadScopes = new Array;
    //noLoadScopes[a][0] scope index
    //noLoadScopes[a][1] pure recipients indexes
    for (var t = 0; t < parentScopes.length; t++) {
        var newItem = new Array;
        newItem.push (parentScopes[t]);
        newItem.push (tsScopesList[parentScopes[t]][2].slice(0));
        if (tsScopesList[parentScopes[t]][1][3] == "Auto Load") {
            autoLoadScopes.push (newItem);
        }
        else {
            noLoadScopes.push (newItem);
        }
    }

    //sorting lists
    for (var au = 0; au < autoLoadScopes.length - 1; au++) {
        for (var aa = au + 1; aa < autoLoadScopes.length; aa++) {
            if (autoLoadScopes[au][1].length < autoLoadScopes[aa][1].length) { //swap
                var swapItem = autoLoadScopes[au];
                autoLoadScopes[au] = autoLoadScopes[aa];
                autoLoadScopes[aa] = swapItem;
            }
        }
    }

    for (var no = 0; no < noLoadScopes.length - 1; no++) {
        for (var nn = no + 1; nn < noLoadScopes.length; nn++) {
            if (noLoadScopes[no][1].length < noLoadScopes[nn][1].length) { //swap
                var swapItem = noLoadScopes[no];
                noLoadScopes[no] = noLoadScopes[nn];
                noLoadScopes[nn] = swapItem;
            }
        }
    }

    //extraction repeated recipients
    for (var z1 = 0; z1 < autoLoadScopes.length; z1++) {
        for (var z2 = autoLoadScopes[z1][1].length - 1; z2 >= 0; z2--) {
            var isExist = false;
            for (var z3 = 0; z3 < z1; z3++) {
                var isFound = false;
                for (var z4 = 0; z4 < autoLoadScopes[z3][1].length; z4++) {
                    if (autoLoadScopes[z3][1][z4] == autoLoadScopes[z1][1][z2]) {
                        isFound = true;
                        break;
                    }
                }
                if (isFound) {
                    isExist = true;
                    break;
                }
            }
            if (isExist) {
                autoLoadScopes[z1][1].splice (z2, 1);
            }
        }
    }

    for (var y1 = 0; y1 < noLoadScopes.length; y1++) {
        for (var y2 = noLoadScopes[y1][1].length - 1; y2 >= 0; y2--) {
            var isExist = false;
            for (var y3 = 0; y3 < y1; y3++) {
                var isFound = false;
                for (var y4 = 0; y4 < noLoadScopes[y3][1].length; y4++) {
                    if (noLoadScopes[y3][1][y4] == noLoadScopes[y1][1][y2]) {
                        isFound = true;
                        break;
                    }
                }
                if (isFound) {
                    isExist = true;
                    break;
                }
            }
        
            //search autoLoadScopes also
            for (var y5 = 0; y5 < autoLoadScopes.length; y5++) {
                var isFoundThere = false;
                for (var y6 = 0; y6 < autoLoadScopes[y5][1].length; y6++) {
                    if (autoLoadScopes[y5][1][y6] == noLoadScopes[y1][1][y2]) {
                        isFoundThere = true;
                        break;
                    }
                }
                if (isFoundThere) {
                    isExist = true;
                    break;
                }
            }
        
            if (isExist) {
                noLoadScopes[y1][1].splice (y2, 1);
            }
        }
    }

    //newKnob[0][2] auto load recipients 
    //newKnob[0][3] no load recipients

    folderKnob[0].push (autoLoadScopes);
    folderKnob[0].push (noLoadScopes);
    
    //go ahead
    for (var f = 0; f < folderKnob[1].length; f++) {
        var passedArray = parentScopes.slice (0);
        extractRecipients (folderKnob[1][f], passedArray);
    }
}

function getGoal (abstractPathOrTwin, extraList) {
    /**///$.writeln ($.line);
    var returnedTwin;
    if (abstractPathOrTwin instanceof Array) {
        returnedTwin = abstractPathOrTwin;
        for (twasp = 0; twasp < returnedTwin[0].length; twasp++) {
            if (extraList) {
                for (var aspd = 0; aspd < extraList[0].length; aspd++) {
                    if (extraList[0][aspd][0] == returnedTwin[0][twasp][0]) {
                        if (extraList[0][aspd][0] == "SELF")
                            continue;
                        extraList[0].splice (aspd, 1);
                        break;
                    }
                }
            }
        }
        for (twnsp = 0; twnsp < returnedTwin[1].length; twnsp++) {
            if (extraList) {
                for (var nspd = 0; nspd < extraList[1].length; nspd++) {
                    if (extraList[1][nspd][0] == returnedTwin[1][twnsp][0]) {
                        extraList[1].splice (nspd, 1);
                        break;
                    }
                }
            }
        }
    }
    else {
        var fileKnob = getStation (tsRootsList, abstractPathOrTwin);
        returnedTwin = new Array;
        returnedTwin.push (new Array);
        returnedTwin.push (new Array);
        for (var asp = 0; asp < fileKnob[0][2].length; asp++) {
            returnedTwin[0].push (new Array);
            returnedTwin[0][returnedTwin[0].length - 1].push (fileKnob[0][2][asp][0]);
            returnedTwin[0][returnedTwin[0].length - 1].push (fileKnob[0][2][asp][1].slice (0));
            if (extraList) {
                for (var aspd = 0; aspd < extraList[0].length; aspd++) {
                    if (extraList[0][aspd][0] == fileKnob[0][2][asp][0]) {
                        if (extraList[0][aspd][0] == "SELF")
                            continue;
                        extraList[0].splice (aspd, 1);
                        break;
                    }
                }
            }
        }
        for (var nsp = 0; nsp < fileKnob[0][3].length; nsp++) {
            returnedTwin[1].push (new Array);
            returnedTwin[1][returnedTwin[1].length - 1].push (fileKnob[0][3][nsp][0]);
            returnedTwin[1][returnedTwin[1].length - 1].push (fileKnob[0][3][nsp][1].slice (0));
            if (extraList) {
                for (var nspd = 0; nspd < extraList[1].length; nspd++) {
                    if (extraList[1][nspd][0] == fileKnob[0][3][nsp][0]) {
                        extraList[1].splice (nspd, 1);
                        break;
                    }
                }
            }
        }
    }


    if (!extraList)
        return returnedTwin;
    //remove repeated recipients in no load scopes
    for (var nesp = 0; nesp < extraList[1].length; nesp++) {
        for (var nerc = extraList[1][nesp].length - 1; nerc >= 0; nerc--) {
            var isRepeated = false;
            for (var twin = 0; twin < 2; twin++) {
                var isBreak2 = false;
                for (var wsp = 0; wsp < returnedTwin[twin].length; wsp++) {
                    var isBreak1 = false;
                    for (var wrc = 0; wrc < returnedTwin[twin][wsp][1].length; wrc++) {
                        if (returnedTwin[twin][wsp][1][wrc] == extraList[1][nesp][1][nerc]) {
                            isRepeated = true;
                            isBreak1 = true;
                            break;
                        }
                    }
                    if (isBreak1) {
                        isBreak2 = true;
                        break;
                    }
                }
                if (isBreak2)
                    break;
            }
            if (isRepeated) {
                extraList[1][nesp][1].splice (nerc, 1);
            }
        }
    }

    //AUTO
    var autoPointer = -1;
    var returnedCompare = new Array;
    var extraCompare = new Array;
    for (var aesp = 0; aesp < extraList[0].length; aesp++) {
        autoPointer++;
        for (var aespc = autoPointer; aespc < returnedTwin[0].length; aespc++) {
            if (extraList[0][aesp][0] == "SELF") {
                returnedCompare.push (aespc);
                autoPointer++;
            }
            else if (returnedTwin[0][aespc][0] == "SELF") {
                break;
            }
            else if (tsScopesList [returnedTwin[0][aespc][0]][2].length > tsScopesList [extraList[0][aesp][0]][2].length) {
                returnedCompare.push (aespc);
                autoPointer++;
            }
            else {
                break;
            }
        }
        //adding extra scope to returned auto list
        returnedTwin[0].splice (autoPointer, 0, extraList[0][aesp]);
        extraCompare.push (autoPointer);
    }

    //removing repeated elements
    for (var resp = 0; resp < returnedCompare.length; resp++) {
        for (var rerc = returnedTwin[0][returnedCompare[resp]][1].length - 1; rerc >= 0; rerc--) {
            var isReRepeated = false;
            if (extraCompare.length > 0) {
                for (var exsp = 0; extraCompare[exsp] < returnedCompare[resp]; exsp++) {
                    var isBreak = false;
                    for (var exrc = 0; exrc < returnedTwin[0][extraCompare[exsp]][1].length; exrc++) {
                        if (returnedTwin[0][returnedCompare[resp]][1][rerc] == returnedTwin[0][extraCompare[exsp]][1][exrc]) {
                            isReRepeated = true;
                            isBreak = true;
                            break;
                        }
                    }
                    if (isBreak)
                        break;
                }
            }
            if (isReRepeated) {
                returnedTwin[0][returnedCompare[resp]][1].splice (rerc, 1);
            }
        }
    }
    for (var exsp2 = 0; exsp2 < extraCompare.length; exsp2++) {
        for (var exrc2 = returnedTwin[0][extraCompare[exsp2]][1].length - 1; exrc2 >= 0; exrc2--) {
            var isReRepeated = false;
            if (returnedCompare.length > 0) {
                for (var resp2 = 0; resp2 < returnedCompare.length && returnedCompare[resp2] < extraCompare[exsp2]; resp2++) {
                    var isBreak = false;
                    for (var rerc2 = 0; rerc2 < returnedTwin[0][returnedCompare[resp2]][1].length; rerc2++) {
                        if (returnedTwin[0][extraCompare[exsp2]][1][exrc2] == returnedTwin[0][returnedCompare[resp2]][1][rerc2]) {
                            isReRepeated = true;
                            isBreak = true;
                            break;
                        }
                    }
                    if (isBreak)
                        break;
                }
            }
            if (isReRepeated) {
                returnedTwin[0][extraCompare[exsp2]][1].splice (exrc2, 1);
            }
            else {
                for (var wee = 0; wee < returnedTwin[1].length; wee++) {
                    var isFound = false;
                    for (var tee = returnedTwin[1][wee][1].length - 1; tee >= 0; tee--) {
                        if (returnedTwin[0][extraCompare[exsp2]][1][exrc2] == returnedTwin[1][wee][1][tee]) {
                            returnedTwin[1][wee][1].splice (tee, 1);
                            isFound = true;
                            break;
                        }
                    }
                    if (isFound)
                        break;
                }
            }
        }
    }

    //NO LOAD
    for (var nespa = 0; nespa < extraList[1].length; nespa++) {
        returnedTwin[1].push (extraList[1][nespa]);
    }
    //merge SELF scopes
    if (returnedTwin[0].length > 1) {
        if (returnedTwin[0][returnedTwin[0].length -2][0] == "SELF") {
            for (var vv = 0; vv < returnedTwin[0][returnedTwin[0].length - 1][1].length; vv++) {
                returnedTwin[0][returnedTwin[0].length - 2][1].push (returnedTwin[0][returnedTwin[0].length - 1][1][vv]);
            }
        }
        returnedTwin[0].splice (returnedTwin[0].length - 1, 1);
    }
    return returnedTwin;
}

function getTotalGoal (fileAbstractPath, returnedTwin, fileID, isToAddRequired) {
    /**///$.writeln ($.line);
    var filefsName = fileAbstractPath;
    fileAbstractPath = fileAbstractPath.slice (1, fileAbstractPath.lastIndexOf ("/"));
    returnedTwin = getGoal (fileAbstractPath, returnedTwin);
    if (isToAddRequired) {
        var requiredArray = new Array;
        var requiredFiles = new Folder (tsDataPath + "/IDs" + fileID + "/Required").getFiles (isUnhiddenFile);
        for (var req = 0; req < requiredFiles.length; req++) {
            var recipientIndex = tsGetRecipientIndex (File.decode (requiredFiles[req].name));
            if (recipientIndex != -1) {
                requiredArray.push (recipientIndex);
            }
        }
        if (requiredArray.length > 0) {
            var selfScope = new Array;
            selfScope.push ("SELF");
            selfScope.push (requiredArray);
            var requiredTwin = new Array;
            requiredTwin.push (new Array);
            requiredTwin[0].push (selfScope);
            requiredTwin.push (new Array);
            returnedTwin = getGoal (returnedTwin, requiredTwin);
        }
    }
    if (!fileID) {
        var tryedID = tsGetID (new File (tsWorkshopPath + filefsName));
        if (!tryedID) {
            return returnedTwin;
        }
        fileID = tryedID;
    }
    var placesFolder = new Folder (tsDataPath + "/IDs" + fileID + "/Workshop/Places");
    if (placesFolder.exists) {
        var placesFiles = placesFolder.getFiles (isUnhiddenFile);
        for (var e = 0; e < placesFiles.length; e++) {
            var fileDotID = File.decode (placesFiles[e].name);
            var linkFileID = "/" + fileDotID.replace (/\./g, "\/");
            var fileID_Path_newID = [linkFileID];
            tsGetPath (fileID_Path_newID);
            if (fileID_Path_newID[1]) {
                returnedTwin = getTotalGoal (fileID_Path_newID[1], returnedTwin, linkFileID, false);
            }
        }
    }
    return returnedTwin;
}

function getStation (curretKnob, fullPath) {
    /**///$.writeln ($.line);
    var currentPortion = fullPath;
    var restPortion = "";
    if (fullPath.indexOf ("/") != -1) {
        currentPortion = fullPath.slice (0, fullPath.indexOf ("/"));
        restPortion = fullPath.slice (fullPath.indexOf ("/")+1);
    }
    var knobIndex = -1;
    for (var n = 0; n < curretKnob[1].length; n++) {
        if (currentPortion == curretKnob[1][n][0][0]) {
            knobIndex = n;
            break;
        }
    }
    if (knobIndex != -1) {
        return getStation (curretKnob[1][knobIndex], restPortion);
    }
    else {
        return curretKnob;
    }
}

function addKnob (knobList, scopeIndex, pathPortion) {
    /**///$.writeln ($.line);
    var currentPortion = pathPortion;
    var restPortion = "";
    if (pathPortion.indexOf ("/") != -1) {
        currentPortion = pathPortion.slice (0, pathPortion.indexOf ("/"));
        restPortion = pathPortion.slice (pathPortion.indexOf ("/")+1);
    }
    var knobIndex = -1;
    for (var k = 0; k < knobList.length; k++) {
        if (knobList[k][0][0] == currentPortion) {
            knobIndex = k;
            break;
        }
    }
    if (knobIndex == -1) {
        var newKnob = new Array;
        newKnob.push (new Array);

        //newKnob[0][0] the folder name
        newKnob[0].push (currentPortion);

        //newKnob[0][1] the scopes' indexes list
        newKnob[0].push (new Array);
        
        //newKnob[0][2] auto load recipients (will be added later)
        //newKnob[0][3] no load recipients (will be added later)
        
        //List of Sub knobs
        newKnob.push (new Array);
        knobList.push (newKnob);
        knobIndex = knobList.length - 1;
    }
    if (restPortion == "") {
        knobList[knobIndex][0][1].push (scopeIndex);
        return true;
    }
    else {
        return addKnob (knobList[knobIndex][1], scopeIndex, restPortion);
    }
}

function getMessages (messagesArray, currentTime) { //Array of four (the folder, Level A Twin Array, Level B Twin Array, Level C Twin Array
    /**///$.writeln ($.line);
    messagesArray[3][0]++;
    var notOkC = true;
    var scannedList = new Array;
    while (notOkC) {
        if (messagesArray[3][0] == messagesArray[3][1].length) {
            messagesArray[3][0] = 0;
            var notOkB = true;
            while (notOkB) {
                messagesArray[2][0]++;
                if (messagesArray[2][0] == messagesArray[2][1].length) {
                    messagesArray[2][0] = 0;
                    while (true) {
                        messagesArray[1][0]++;
                        if (messagesArray[1][0] == messagesArray[1][1].length) {
                            messagesArray[1][0] = -1;
                            messagesArray[1][1] = messagesArray[0].getFiles (isUnhiddenFolder);
                            messagesArray[2][0] = -1;
                            messagesArray[2][1] = new Array;
                            messagesArray[3][0] = -1;
                            messagesArray[3][1] = new Array;
                            return scannedList;
                        }
                        if (messagesArray[1][1][messagesArray[1][0]].exists) {
                            messagesArray[2][1] = messagesArray[1][1][messagesArray[1][0]].getFiles (isUnhiddenFolder);
                            if (messagesArray[2][1].length > 1) {
                                break;
                            }
                            else {
                                if (messagesArray[2][1].length == 1) {
                                    if (File.decode (messagesArray[2][1][0].name) == "dulajun") {
                                        var index2 = messagesArray[2][1][0].getFiles (isUnhiddenFolder);
                                        if (index2.length > 0) {
                                            if (File.decode (index2[index2.length - 1].name) == "9N") {
                                                if (currentTime - messagesArray[2][1][0].modified.getTime () > 30000)
                                                    deleteForcelyFolders (messagesArray[1][1][messagesArray[1][0]], true);
                                            }
                                        }
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                if (messagesArray[2][1][messagesArray[2][0]].exists && File.decode (messagesArray[2][1][messagesArray[2][0]].name)[0] != 'd') {
                    messagesArray[3][1] = messagesArray[2][1][messagesArray[2][0]].getFiles (isUnhiddenFolder);
                    if (messagesArray[3][1].length > 1) {
                        notOkB = false;
                    }
                    else {
                        if (messagesArray[3][1].length == 1) {
                            if (File.decode (messagesArray[3][1][0].name) == "dulajun") {
                                var index3 = messagesArray[3][1][0].getFiles (isUnhiddenFolder);
                                if (index3.length > 0) {
                                    if (File.decode (index3[index3.length - 1].name) == "9N") {
                                        if (currentTime - messagesArray[3][1][0].modified.getTime () > 30000)
                                            deleteForcelyFolders (messagesArray[2][1][messagesArray[2][0]], true);
                                    }
                                }
                            }
                            else {
                                notOkB = false;
                            }
                        }
                        else { //it's zero
                        }
                    }
                }
            }
        }
        if (messagesArray[3][1][messagesArray[3][0]].exists && File.decode (messagesArray[3][1][messagesArray[3][0]].name)[0] != 'd') {
            scannedList = messagesArray[3][1][messagesArray[3][0]].getFiles (isUnhiddenFolder);
            if (scannedList.length > 1) {
                notOkC = false;
            }
            else {
                if (scannedList.length == 1) {
                    if (File.decode (scannedList[0].name) == "dulajun") {
                        var index4 = scannedList[0].getFiles (isUnhiddenFolder);
                        if (index4.length > 0) {
                            if (File.decode (index4[index4.length - 1].name) == "9N") {
                                if (currentTime - scannedList[0].modified.getTime () > 30000)
                                    deleteForcelyFolders (messagesArray[3][1][messagesArray[3][0]], true);
                            }
                        }
                        messagesArray[3][0]++;
                    }
                    else {
                        notOkC = false;
                    }
                }
                else {  // it's zero
                    messagesArray[3][0]++;
                }
            }
        }
        else {
            messagesArray[3][0]++;
        }
    }
    return scannedList;
}

function getWorkingTable (infoContent) {
    /**///$.writeln ($.line);
    //2014/08/14/01/00
    var fromDate = infoContent[1].split ("/");
    var toDate = infoContent[2].split ("/");
    var lines = "Work Time";
    lines += "\n" + infoContent[1];
    lines += "\n" + infoContent[2];
    if (fromDate.length == 5 && toDate.length == 5) {
        var fromYear = parseInt (fromDate[0], 10);
        var fromMonth = parseInt (fromDate[1], 10);
        var fromDay = parseInt (fromDate[2], 10);
        var fromHour = parseInt (fromDate[3], 10);
        var fromMinute = parseInt (fromDate[4], 10);

        var toYear = parseInt (toDate[0], 10);
        var toMonth = parseInt (toDate[1], 10);
        var toDay = parseInt (toDate[2], 10);
        var toHour = parseInt (toDate[3], 10);
        var toMinute = parseInt (toDate[4], 10);
        var notFinished = true;
        
        var workingTimeFolder = new Folder (tsDataPath + "/Working Time");
        
        if (workingTimeFolder.exists) {
            var yearsList = workingTimeFolder.getFiles (isUnhiddenFolder);
            var fromYearIndex = -1;
            for (var y1 = 0; y1 < yearsList.length; y1++) {
                if (fromYear <= parseInt (File.decode (yearsList[y1].name), 10)) {
                    fromYearIndex = y1;
                    break;
                }
            }
            if (fromYearIndex == -1)
                return lines;
            var toYearIndex = -1;
            for (var y2 = yearsList.length - 1; y2 >= fromYearIndex; y2--) {
                if (toYear >= parseInt (File.decode (yearsList[y2].name), 10)) {
                    toYearIndex = y2;
                    break;
                }
            }
            if (toYearIndex == -1)
                return lines;
            for (var yy = fromYearIndex; yy <= toYearIndex; yy++) {
                var monthsList = yearsList[yy].getFiles (isUnhiddenFolder);
                var fromMonthIndex = 0;
                if (fromDate[0] == File.decode (yearsList[yy].name)) {
                    fromMonthIndex = -1;
                    for (var m1 = 0; m1 < monthsList.length; m1++) {
                        if (fromMonth <= parseInt (File.decode (monthsList[m1].name), 10)) {
                            fromMonthIndex = m1;
                            break;
                        }
                    }
                    if (fromMonthIndex == -1)
                        continue;
                }
                var toMonthIndex = monthsList.length - 1;
                if (toDate[0] == File.decode (yearsList[yy].name)) {
                    toMonthIndex = -1;
                    for (var m2 = monthsList.length - 1; m2 >= fromMonthIndex; m2--) {
                        if (toMonth >= parseInt (File.decode (monthsList[m2].name), 10)) {
                            toMonthIndex = m2;
                            break;
                        }
                    }
                    if (toMonthIndex == -1)
                        continue;
                }
                for (var mm = fromMonthIndex; mm <= toMonthIndex; mm++) {
                    var daysList = monthsList[mm].getFiles (isUnhiddenFolder);
                    var fromDayIndex = 0;
                    if (fromDate[1] == File.decode (monthsList[mm].name)) {
                        fromDayIndex = -1;
                        for (var d1 = 0; d1 < daysList.length; d1++) {
                            if (fromDay <= parseInt (File.decode (daysList[d1].name), 10)) {
                                fromDayIndex = d1;
                                break;
                            }
                        }
                        if (fromDayIndex == -1)
                            continue;
                    }
                    var toDayIndex = daysList.length - 1;
                    if (toDate[1] == File.decode (monthsList[mm].name)) {
                        toDayIndex = -1;
                        for (var d2 = daysList.length - 1; d2 >= fromDayIndex; d2--) {
                            if (toDay >= parseInt (File.decode (daysList[d2].name), 10)) {
                                toDayIndex = d2;
                                break;
                            }
                        }
                        if (toDayIndex == -1)
                            continue;
                    }
                    for (var dd = fromDayIndex; dd <= toDayIndex; dd++) {
                        var hoursList = daysList[dd].getFiles (isUnhiddenFolder);
                        var fromHourIndex = 0;
                        if (fromDate[2] == File.decode (daysList[dd].name)) {
                            fromHourIndex = -1;
                            for (var h1 = 0; h1 < hoursList.length; h1++) {
                                if (fromHour <= parseInt (File.decode (hoursList[h1].name), 10)) {
                                    fromHourIndex = h1;
                                    break;
                                }
                            }
                            if (fromHourIndex == -1)
                                continue;
                        }
                        var toHourIndex = hoursList.length - 1;
                        if (toDate[2] == File.decode (daysList[dd].name)) {
                            toHourIndex = -1;
                            for (var h2 = hoursList.length - 1; h2 >= fromHourIndex; h2--) {
                                if (toHour >= parseInt (File.decode (hoursList[h2].name), 10)) {
                                    toHourIndex = h2;
                                    break;
                                }
                            }
                            if (toHourIndex == -1)
                                continue;
                        }
                        for (var hh = fromHourIndex; hh <= toHourIndex; hh++) {
                            var minutesList = hoursList[hh].getFiles (isUnhiddenFile);
                            var fromMinuteIndex = 0;
                            if (fromDate[3] == File.decode (hoursList[hh].name)) {
                                fromMinuteIndex = -1;
                                for (var n1 = 0; n1 < minutesList.length; n1++) {
                                    if (fromMinute <= parseInt (File.decode (minutesList[n1].name), 10)) {
                                        fromMinuteIndex = n1;
                                        break;
                                    }
                                }
                                if (fromMinuteIndex == -1)
                                    continue;
                            }
                            var toMinuteIndex = minutesList.length - 1;
                            if (toDate[3] == File.decode (hoursList[hh].name)) {
                                toMinuteIndex = -1;
                                for (var n2 = minutesList.length - 1; n2 >= fromMinuteIndex; n2--) {
                                    if (toMinute >= parseInt (File.decode (minutesList[n2].name), 10)) {
                                        toMinuteIndex = n2;
                                        break;
                                    }
                                }
                                if (toMinuteIndex == -1)
                                    continue;
                            }
                            for (var nn = fromMinuteIndex; nn <= toMinuteIndex; nn++) {
                                var targetSpanContent = readFile (minutesList[nn]);
                                if (!targetSpanContent) {
                                    continue;
                                }
                                var docsSufix = "";
                                targetSpanContent = targetSpanContent.split ("\n");
                                for (var e = 0; e < targetSpanContent.length; e++) {
                                    var docID;
                                    if (targetSpanContent[e] == "No Document") {
                                        continue;
                                        docID = targetSpanContent[e];
                                    }
                                    else {
                                        var splitted = targetSpanContent[e].split (":");
                                        var fileID_Path_newID = [splitted[0]];
                                        tsGetPath (fileID_Path_newID);
                                        if (fileID_Path_newID[1]) {
                                            if (!isFileExistInScope (fileID_Path_newID[1], infoContent[3]))
                                                continue;
                                            docID = splitted[0] + "," + splitted[1] + "," + splitted[2];
                                        }
                                        else
                                            continue;
                                    }
                                    docsSufix += ":" + docID ;
                                }
                                if (docsSufix != "") {
                                    lines += "\n" + File.decode (yearsList[yy].name) + "/" + File.decode (monthsList[mm].name) + "/" + File.decode (daysList[dd].name) + "/" + File.decode (hoursList[hh].name) + "/" + File.decode (minutesList[nn].name);
                                    lines += docsSufix;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return lines;
}

function isFileExistInScope (targetFilePath, scopeID) {
    var isScopeExist = false;
    var workingKnob = getStation (tsRootsList, targetFilePath.slice (1));
    for (var tw = 2; tw < 4; tw ++) {
        for (var slt = 0; slt < workingKnob[0][tw].length; slt++) {
            if (tsScopesList[workingKnob[0][tw][slt][0]][0] == scopeID) {
                isScopeExist = true;
                break;
            }
        }
        if (isScopeExist)
            break;
    }
    return isScopeExist;
}

function produceWorkingDocument (senderName, infoContent) {
    /**///$.writeln ($.line);
    var splitted = infoContent.split ("\n");
    if (splitted[0] == "Work Time") {
        if (splitted.length > 3) {
            var fromTime = splitted[1];
            var toTime = splitted[2];
            var InDesignList = new Array;
            var timeList = new Array;
            for (var wt = 3; wt < splitted.length; wt++) {
                var span = splitted[wt].split (":");
                var spanItem = new Array;
                spanItem.push (span[0]);
                for (var ind = 1; ind < span.length; ind++) {
                    var spanSplitted = span[ind].split (",");
                    var InDesignID = spanSplitted[0];
                    var InDesignMod = spanSplitted[1];
                    var activityTock = spanSplitted[2];
                    var existIndex = -1;
                    for (var st = 0; st < InDesignList.length; st++) {
                        if (InDesignList[st][0] == InDesignID) {
                            existIndex = st;
                            InDesignList[st][1] += 5;
                            if (parseInt (activityTock, 10) >= 5)
                                InDesignList[st][2] += 5;
                            break;
                        }
                    }
                    var cellItem = new Array;
                    if (existIndex != -1) {
                        cellItem.push (existIndex);
                        cellItem.push (InDesignMod);
                        cellItem.push (spanSplitted[2]);
                        spanItem.push (cellItem);
                    }
                    else {
                        var InDesignItem = new Array;
                        InDesignItem.push (InDesignID);
                        InDesignItem.push (1*5);
                        if (parseInt (activityTock, 10) >= 5)
                            InDesignItem.push (5);
                        else
                            InDesignItem.push (0);
                        InDesignList.push (InDesignItem);
                        cellItem.push (InDesignList.length - 1);
                        cellItem.push (InDesignMod);
                        cellItem.push (activityTock);
                        spanItem.push (cellItem);
                    }
                }
                timeList.push (spanItem);
            }
            var bodyMatrix = new Array;
            
            for (var bm = 0; bm < timeList.length + 3; bm++) {
                var bodyRow = new Array;
                for (var vv = 0; vv < InDesignList.length + 1; vv++) {
                    bodyRow.push ("");
                }
                bodyMatrix.push (bodyRow);
            }
            var total = 0;
            var pure = 0;
            var documentsPaths = new Array;
            for (var bo = 0; bo < InDesignList.length; bo++) {
                documentsPaths.push ("");
                var InDesignName = InDesignList[bo][0];
                if (InDesignName != "No Document") {
                    var fileID_Path_newID = [InDesignName];
                    tsGetPath (fileID_Path_newID);
                    if (fileID_Path_newID[1]) {
                        documentsPaths[bo] = fileID_Path_newID[1];
                        InDesignName = fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/") + 1);
                    }
                    else {
                        InDesignList[bo][0] = "No Document";
                    }
                }
                bodyMatrix[0][bo + 1] = InDesignName;
                total += InDesignList[bo][1];
                pure += InDesignList[bo][2];
                var totalHours = Math.floor (InDesignList[bo][1] / 60);
                var totalMinutes = Math.round (InDesignList[bo][1] % 60);
                var pureHours = Math.floor (InDesignList[bo][2] / 60);
                var pureMinutes = Math.round (InDesignList[bo][2] % 60);      
                if (totalHours < 10)
                    totalHours = "0" + totalHours;
                if (pureHours < 10)
                    pureHours = "0" + pureHours;
                bodyMatrix[1][bo + 1] = totalHours + ":" + totalMinutes;
                bodyMatrix[2][bo + 1] = pureHours + ":" + pureMinutes;
            }
            var totalH = Math.floor (total / 60);
            var totalM = Math.round (total % 60);
            var pureH = Math.floor (pure / 60);
            var pureM = Math.round (pure % 60);
            bodyMatrix[1][0] = "Total Hours: " + totalH + ":" + totalM;
            bodyMatrix[2][0] = "Pure Hours: " + pureH + ":" + pureM;
            for (var tl = 0; tl < timeList.length; tl++) {
                bodyMatrix[tl + 3][0] = timeList[tl][0];
                for (var qt = 1; qt < timeList[tl].length; qt++) {
                    bodyMatrix[tl + 3][timeList[tl][qt][0] + 1] = timeList[tl].length - 1 + "-" + timeList[tl][qt][1] + "-" + timeList[tl][qt][2];
                }
            }
            var previousDatePortion = "";
            for (var ft = 3; ft < bodyMatrix.length; ft++) {
                var textSplitted1 = bodyMatrix[ft][0].split ("/");
                if (previousDatePortion == (textSplitted1[0] + "/" + textSplitted1[1] + "/" + textSplitted1[2])) {
                    bodyMatrix[ft][0] = textSplitted1[3] + ":" + textSplitted1[4];
                }
                else {
                    bodyMatrix[ft][0] = textSplitted1[3] + ":" + textSplitted1[4] + " - " + textSplitted1[0] + "/" + textSplitted1[1] + "/" + textSplitted1[2];
                }
                previousDatePortion = textSplitted1[0] + "/" + textSplitted1[1] + "/" + textSplitted1[2];
            }
            var headLines = "Work Time Sheet for: " + senderName + "*";
            headLines += "From: " + fromTime.slice (0, 10) + " - " + fromTime.slice (11).replace ("/", ":") + "*";
            headLines += "To: " + toTime.slice (0, 10) + " - " + toTime.slice (11).replace ("/", ":") + "$";
            //senderName
            //bodyMatrix
            var pageTitle = "Working Time Report for " + senderName;
            var dateName = new Date().getTime();
            dateName = dateName.toString ();
            var queryFolder = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);          
            queryFolder.create ();
            for (var bmx = 3; bmx < bodyMatrix.length; bmx++) {
                for (var bmy = 1; bmy < bodyMatrix[bmx].length; bmy++) {
                    if (bodyMatrix[bmx][bmy]) {
                        if (documentsPaths[bmy-1]) {
                            var pageNum = bodyMatrix[bmx][bmy].slice (bodyMatrix[bmx][bmy].indexOf ("-") + 1, bodyMatrix[bmx][bmy].lastIndexOf ("-"));
                            var pageAbsolutePath = documentsPaths[bmy-1] + "/" + tsFillZerosIfAllDigits (pageNum, 4)  + ".jpg";
                            var pageFileFrom = new File (tsPagesPath + "/Workshop" + pageAbsolutePath);
                            var pageFileTo = new File (queryFolder.fsName.replace(/\\/g, '/') + pageAbsolutePath);
                            if (pageFileFrom.exists) {
                                pageFileTo.parent.create ();
                                pageFileFrom.copy (pageFileTo);
                                bodyMatrix[bmx][bmy] += "-" + pageAbsolutePath;
                            }
                        }
                    }
                }
            }
            htmlContent = "";
            htmlContent += "<!DOCTYPE html>";
            htmlContent += "\n<html>";
            htmlContent += "\n<head>";
            htmlContent += "\n<title>" + pageTitle + "</title>";
            htmlContent += "\n<style>";

            htmlContent += "\ntable, th, td {";
                htmlContent += "\nborder: 1px solid black;";
                htmlContent += "\nborder-collapse: collapse;";
                htmlContent += "\ntable-layout: fixed;";
                htmlContent += "\nwidth: 150px;";
            htmlContent += "\n}";
            htmlContent += "\nth, td {";
                htmlContent += "\npadding: 5px;";
                htmlContent += "\ntext-align: left;";
                htmlContent += "\nfont-size: 12px;";
                htmlContent += "\nwhite-space: nowrap;";
            htmlContent += "\n}";
            htmlContent += "\nth {";
                htmlContent += "\ntransform: rotate(90deg) translateX(-130px);";
                htmlContent += "\nheight: 300px;";
                htmlContent += "\n}";
            htmlContent += "\n.slim {";
                htmlContent += "\nwidth: 30px;";
            htmlContent += "\n}";
            htmlContent += "\n.total {";
                htmlContent += "\nfont-weight: bold;";
                htmlContent += "\ntext-align: center;";
            htmlContent += "\n}";
            htmlContent += "\n.activeCell {";
                htmlContent += "\ntext-align: center;";
                htmlContent += "\nfont-weight: bold;";
                htmlContent += "\ncolor: white;";
                htmlContent += "\nbackground-color: gray;";
                htmlContent += "\n}";
            htmlContent += "\n.tabletop {";
                htmlContent += "\nposition: fixed;";
                htmlContent += "\ntop: 0;";
                htmlContent += "\nbackground-color: #fff;";
                htmlContent += "\n}";
            htmlContent += "\n.tablebody {";
                htmlContent += "\npadding-top: 450px;";
            htmlContent += "\n}";
            htmlContent += "\n.width30 {";
                htmlContent += "\nwidth: 30px;";
            htmlContent += "\n}";
            htmlContent += "\nimg {";
                htmlContent += "\nwidth: 30px;";
                htmlContent += "\nheight: 17px;";
                htmlContent += "\nborder: 1px solid gray;";
                htmlContent += "\nposition: absolute;";
                htmlContent += "\ndisplay: block;";
                htmlContent += "\nopacity: 0;";
            htmlContent += "\n}";
            htmlContent += "\nimg:hover {";
                htmlContent += "\nheight: auto;";
                htmlContent += "\ntransform: scale(10) translate(50%,50%);";
                htmlContent += "\nopacity: 1;";
            htmlContent += "\n}";

            htmlContent += "\n</style>";
            htmlContent += "\n</head>";
            htmlContent += "\n<div class='tabletop'>";
            htmlContent += "<h4>";
            headLines = headLines.slice (0, -1);
            headLines = headLines.replace (/\*/g, "<br>");
            htmlContent += headLines;
            htmlContent += "</h4><br>";
            htmlContent += "\n<table>";
            for (var x = 0; x < 1; x++) {
                htmlContent += "\n<tr>";
                for (var y = 0; y < bodyMatrix[x].length; y++) {
                    if (y > 0)
                        htmlContent += "\n<th class='slim'>";
                    else
                        htmlContent += "\n<th>";
                    htmlContent += bodyMatrix[x][y];
                    htmlContent += "</th>";
                }
                htmlContent += "\n</tr>";
            }
            for (x = 1; x < 2; x++) {
                htmlContent += "\n<tr>";
                for (var y = 0; y < bodyMatrix[x].length; y++) {
                    htmlContent += "\n<td class='total'>";
                    htmlContent += bodyMatrix[x][y];
                    htmlContent += "</td>";
                }
                htmlContent += "\n</tr>";
            }
            htmlContent += "\n</table>";
            htmlContent += "\n</div>";
            htmlContent += "\n<div class='tablebody'>";
            htmlContent += "\n<table>";
            for (x = 3; x < bodyMatrix.length; x++) {
                htmlContent += "\n<tr>";
                for (var y = 0; y < bodyMatrix[x].length; y++) {
                    var cellPageNum = "";
                    var classText = "";
                    var isThereImage = false;
                    if (bodyMatrix[x][y]) {
                        if (y > 0) {
                            if (x == 3)
                                classText = " class='activeCell width30'";
                            else 
                                classText = " class='activeCell'";
                            bodyMatrix[x][y] = bodyMatrix[x][y].slice (bodyMatrix[x][y].indexOf ("-") + 1);
                            cellPageNum = bodyMatrix[x][y].slice (0, bodyMatrix[x][y].indexOf ("-"));
                            bodyMatrix[x][y] = bodyMatrix[x][y].slice (bodyMatrix[x][y].indexOf ("-") + 1);
                            if (bodyMatrix[x][y].indexOf ("-") != -1) {
                                bodyMatrix[x][y] = bodyMatrix[x][y].slice (bodyMatrix[x][y].indexOf ("-") + 1);
                                isThereImage = true;
                            } 
                        }
                        else {
                            cellPageNum = bodyMatrix[x][y];
                        }
                    }
                    else {

                    }
                    if (x == 3 && y > 0 && !classText) {
                        classText = " class='width30'";
                    }
                    htmlContent += "\n<td" + classText + ">";
                    if (isThereImage) {
                        htmlContent += "<img src='." + bodyMatrix[x][y] + "'>";
                    }
                    htmlContent += cellPageNum;
                    htmlContent += "</td>";
                }
                htmlContent += "\n</tr>";
            }
            htmlContent += "\n</table>";
            htmlContent += "\n</div>";
            htmlContent += "\n<body>";
            htmlContent += "\n</body>";
            htmlContent += "\n</html>";

            writeFile (new File (queryFolder.fsName.replace(/\\/g, '/') + "/index.html"), htmlContent);
            app.document.thumbnail = new Thumbnail (queryFolder);
        }
        else {
            alert (senderName + " hadn't worked any thing in this period !");
        }
    }
}

function produceMessageCell (rootFolder) {
    /**///$.writeln ($.line);
    var newCell;
    if (!rootFolder.exists)
        rootFolder.create ();
    var parentFolder = rootFolder.getFiles (isUnhiddenFolder);
    if (parentFolder.length != 0) {
        parentFolder = parentFolder [parentFolder.length - 1];
        newCell = produceNewFolder (parentFolder, 1, 3);
    }
    if (!newCell) {
        //produce new parent
        var newDate = new Date ().getTime ();
        newDate = fillZeros (newDate, 20);
        parentFolder = new Folder (rootFolder.fsName.replace(/\\/g, '/') + "/" + newDate);
        parentFolder.create ();
        newCell = produceNewFolder (parentFolder, 1, 3);
    }
    return newCell;
}

function getScopeIndex (scopeID) {
    for (var sl = 0; sl < tsScopesList.length; sl++) {
        if (tsScopesList[sl][0] == scopeID)
            return sl;
    }
    return -1;
}

function getSenderIndex (senderID) {
    for (var sndr = 0; sndr < sendersList.length; sndr++) {
        if (senderID == sendersList[sndr][0][0])
            return sndr;
    }
    return -1;
}

function fillTimeGaps (finalResult) {
    finalResult = finalResult.split ("\n");
    var fromTime = finalResult[1].split ("/");
    var yearMonthDayArr = fromTime.slice (0, 3);
    fromTime = fromTime.slice (3);
    var toTime = finalResult[2].split ("/");
    toTime = toTime.slice (3);
    var fromHour = parseInt (fromTime[0], 10);
    var toHour = parseInt (toTime[0], 10);
    var fromMin = parseInt (fromTime[1], 10);
    var toMin = parseInt (toTime[1], 10);
    var originalIndex = 3;
    var thisTime = null;
    var newLines = new Array;
    newLines.push (finalResult[0]);
    newLines.push (finalResult[1]);
    newLines.push (finalResult[2]);
    if (originalIndex < finalResult.length) {
        thisTime = finalResult[originalIndex].split (":");
        thisTime = thisTime[0];
        thisTime = thisTime.split ("/");
        thisTime = thisTime.slice (3);
    }
    for (var h = fromHour; h <= toHour; h++) {
        var fromM = 0;
        var toM = 55;
        if (h == fromHour) {
            fromM = fromMin;
        }
        if (h == toHour) {
            toM = toMin;
        }
        for (var m = fromM; m <= toM; m += 5) {
            var hourDigit = fillZeros (h, 2);
            var minDigit = fillZeros (m, 2);
            if (thisTime) {
                if (hourDigit == thisTime[0] && minDigit == thisTime[1]) {
                    newLines.push (finalResult[originalIndex]);
                    originalIndex++;
                    if (originalIndex < finalResult.length) {
                        thisTime = finalResult[originalIndex].split (":");
                        thisTime = thisTime[0];
                        thisTime = thisTime.split ("/");
                        thisTime = thisTime.slice (3);
                    }
                    else {
                        thisTime = null;
                    }
                }
                else {
                    newLines.push (yearMonthDayArr[0] + "/" + yearMonthDayArr[1] + "/" + yearMonthDayArr[2] + "/" + hourDigit + "/" + minDigit + ":No Document");
                }
            }
            else {
                newLines.push (yearMonthDayArr[0] + "/" + yearMonthDayArr[1] + "/" + yearMonthDayArr[2] + "/" + hourDigit + "/" + minDigit + ":No Document");
            }
        }
    }
    return newLines.join ("\n");
}

function tsCleanPhysical (scopeCleanList) {
    /**///$.writeln ($.line);
    var isDone = false;
    scopeCleanList[3][0]++;
    var notOkC = true;
    var scannedList = new Array;
    var nowTime = new Date ().getTime ();
    while (notOkC) {
        if (scopeCleanList[3][0] == scopeCleanList[3][1].length) {
            scopeCleanList[3][0] = 0;
            var notOkB = true;
            while (notOkB) {
                scopeCleanList[2][0]++;
                if (scopeCleanList[2][0] == scopeCleanList[2][1].length) {
                    scopeCleanList[2][0] = 0;
                    while (true) {
                        scopeCleanList[1][0]++;
                        if (scopeCleanList[1][0] == scopeCleanList[1][1].length) {
                            scopeCleanList[1][0] = -1;
                            var rootCount = scopeCleanList[1][1] = scopeCleanList[0].getFiles (isUnhiddenFolder);
                            scopeCleanList[2][0] = -1;
                            scopeCleanList[2][1] = new Array;
                            scopeCleanList[3][0] = -1;
                            scopeCleanList[3][1] = new Array;
                            if (scopeCleanList[1][1].length == 0)
                                isDone = true;
                            else
                                isDone = false;
                            return isDone;
                        }
                        if (scopeCleanList[1][1][scopeCleanList[1][0]].exists) {
                            scopeCleanList[2][1] = scopeCleanList[1][1][scopeCleanList[1][0]].getFiles (isUnhiddenFolder);
                            if (scopeCleanList[2][1].length > 0) {
                                break;
                            }
                        }
                    }
                }
                if (scopeCleanList[2][1][scopeCleanList[2][0]].exists) {
                    scopeCleanList[3][1] = scopeCleanList[2][1][scopeCleanList[2][0]].getFiles (isUnhiddenFolder);
                    if (scopeCleanList[3][1].length > 0) {
                        notOkB = false;
                    }
                }
            }
        }
        if (scopeCleanList[3][1][scopeCleanList[3][0]].exists) {
            scannedList = scopeCleanList[3][1][scopeCleanList[3][0]].getFiles (isUnhiddenFolder);
            if (scannedList.length > 0) {
                notOkC = false;
            }
            else {
                scopeCleanList[3][0]++;
            }
        }
        else {
            scopeCleanList[3][0]++;
        }
    }
    var deletedCount = 0;
    for (var c = scannedList.length - 1; c >= 0; c--) {
        var isToDelete = true;
        var versionsFolders = scannedList[c].getFiles (isUnhiddenFolder);
        for (var v = 0; v < versionsFolders.length; v++) {
            var allTimes = versionsFolders[v].getFiles (isUnhiddenFolder);
            for (var a = allTimes.length - 2; a >= 0; a--) {
                deleteForcelyFolders (allTimes[a], true);
            }
            if (allTimes.length > 0) {
                var waitedFolder  = new Folder (allTimes[allTimes.length - 1].fsName.replace(/\\/g, '/') + "/Waited");
                if (waitedFolder.exists) {
                    if (nowTime - waitedFolder.created.getTime () < 345600000) {
                        if (waitedFolder.getFiles (isUnhiddenFile).length != 0) {
                            isToDelete = false;
                        }
                        else {
                            if (nowTime - waitedFolder.created.getTime () < 3600000)
                                isToDelete = false;
                        }
                    }
                }
            }
        }
        if (isToDelete) {
            deleteForcelyFolders (scannedList[c], true);
            deletedCount++;
        }
    }
    if (scannedList.length == deletedCount) {
        deleteForcelyFolders (scopeCleanList[3][1][scopeCleanList[3][0]], true);
        if (scopeCleanList[3][1].length == 1) {
            deleteForcelyFolders (scopeCleanList[2][1][scopeCleanList[2][0]], true);
            if (scopeCleanList[2][1].length == 1) {
                deleteForcelyFolders (scopeCleanList[1][1][scopeCleanList[1][0]], true);
            }
        }
    }
    return isDone;
}

function checkInDesignRequest (targetID) {
    /**///$.writeln ($.line);
    for (var de = 0; de < InDesignLoadList.length; de++) {
        if (InDesignLoadList[de] == targetID) {
            var fileID_Path_newID = [InDesignLoadList[de]];
            tsGetPath (fileID_Path_newID);
            if (!fileID_Path_newID[1]) {
                break;
            }
            
            var targetInDesign = BridgeTalk.getSpecifier ("indesign");
            var talkInDesign = new BridgeTalk;
            talkInDesign.target = targetInDesign;
            talkInDesign.onResult = function (returnBtObj)
            { setInDesignScript (returnBtObj.body); }
            talkInDesign.body = 
                "askUser ();\n" +
                "function askUser () {\n" +
                    "var isOK = confirm ('Do you want to open " + fileID_Path_newID[1].slice (fileID_Path_newID[1].lastIndexOf ("/")+1) + " ?');\n" +
                    "if (isOK) {\n" +
                        "return " + "'" + tsWorkshopPath + fileID_Path_newID[1] + "';\n" +
                    "}\n" +
                    "return false;\n" +
                "}";
            talkInDesign.send ();
            function setInDesignScript (theBody) {
                if (theBody) {
                    var targetFile = new File (theBody);
                    if (targetFile.exists) {
                        if (!tsIsShade (targetFile)) {
                            var targetThumbnail = new Thumbnail (targetFile);
                            targetThumbnail.open ();
                        }
                    }
                }
            }
            InDesignLoadList.splice (de, 1);
            break;
        }
    }
}

function tsUpdatePath (senderID, fileID, modificationTime, newPath) {
    /**///$.writeln ($.line);
    var pathTimeFile = new File (tsDataPath + "/IDs" + fileID + "/Path/Change Time");
    var pathTime = readFile (pathTimeFile);
    pathTime = (pathTime == false)? 0 : parseInt (pathTime, 10);
    if (pathTime <= modificationTime) {
        var oldPath;
       if (pathTime != 0) {
            var oldPathRecordFile = new File (tsDataPath + "/IDs" + fileID + "/Path/V/" + pathTime + "/Value");
            if (oldPathRecordFile.exists) {
                var supposedPath = readEncodedFile (oldPathRecordFile);
                if (supposedPath) {
                    if (supposedPath[0] != ':')
                        oldPath = supposedPath;
                }
            }
        }
        else {
            var creatorFile = new File (tsDataPath + "/IDs" + fileID + "/Creator");
            if (!creatorFile.parent.exists)
                creatorFile.parent.create ();
            writeFile (creatorFile, senderID);
        }
        var targetFile;
        var isOldFileExist = false;
        if (oldPath)
            targetFile = new File (tsWorkshopPath + oldPath);
        if (targetFile) {
            if (targetFile.exists)
                isOldFileExist = true;
        }
        if (isOldFileExist) {
            //remove shade file to prevent scanning
            var shadeFile = new File (tsDataPath + "/Shades/" + oldPath);
            if (shadeFile.exists)
                shadeFile.remove ();
            if (newPath[0] != ':') {
                var IDTimePathStepIsUserOldPath = new Array;
                IDTimePathStepIsUserOldPath.push (fileID);
                IDTimePathStepIsUserOldPath.push (modificationTime);
                IDTimePathStepIsUserOldPath.push (newPath);
                IDTimePathStepIsUserOldPath.push (0);
                IDTimePathStepIsUserOldPath.push (false);
                IDTimePathStepIsUserOldPath.push (oldPath);
                tsIDTimePathStepIsUserOldPathList.push (IDTimePathStepIsUserOldPath);
                tsMoveAndRename (targetFile, new File (tsWorkshopPath + newPath), true);
                tsChangePath (fileID, newPath, modificationTime);
                reflectToMirrors (fileID, oldPath, newPath);
                var newShadeFile = new File (tsDataPath + "/Shades/" + newPath);
                if (!newShadeFile.parent.exists)
                    newShadeFile.parent.create ();
                writeFile (newShadeFile,  "TS_ID:" + fileID);
                
            }
            else {
                if (newPath == ":TRASH") {
                    tsMoveToTrash (targetFile, 1, null, false, fileID, false);
                }
                else {
                    tsMoveToTrash (targetFile, 1, newPath, false, fileID, false);
                }
            }
        }
        else {
            if (newPath[0] != ':') {
                var IDTimePathStepIsUserOldPath = new Array;
                IDTimePathStepIsUserOldPath.push (fileID);
                IDTimePathStepIsUserOldPath.push (modificationTime);
                IDTimePathStepIsUserOldPath.push (newPath);
                IDTimePathStepIsUserOldPath.push (0);
                IDTimePathStepIsUserOldPath.push (false);
                IDTimePathStepIsUserOldPath.push (oldPath);
                tsIDTimePathStepIsUserOldPathList.push (IDTimePathStepIsUserOldPath);
                tsChangePath (fileID, newPath, modificationTime);
                var newShadeFile = new File (tsDataPath + "/Shades/" + newPath);
                if (!newShadeFile.parent.exists)
                    newShadeFile.parent.create ();
                writeFile (newShadeFile,  "TS_ID:" + fileID);
                
                var newFile = new File (tsWorkshopPath + newPath);
                if (!newFile.exists) {
                    newFile.parent.create ();
                    writeFile (newFile, "TS_ID:" + fileID);
                }
            }
            else {
                tsChangePath (fileID, newPath, modificationTime);
            }
        }
    }
    return true;
}

function realizeDeletedFiles (suspectedTriples) {
    /**///$.writeln ($.line);
    for (var c = 0; c < suspectedTriples.length; c++) {
        if (suspectedTriples[c][2]) {
            var whiteFile = new File (suspectedTriples[c][0].replace (tsDataPath + "/Shades", tsWorkshopPath));
            if (whiteFile.exists) {
                continue;
            }
            else {
                var shadeFile = new File (suspectedTriples[c][0]);
                shadeFile.remove ();
                if (!isCSFile (whiteFile)) {
                    var idFile = new File (whiteFile.fsName.replace(/\\/g, '/').slice (0, whiteFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/.TREESHADE/" + File.decode (whiteFile.name));
                    if (idFile.exists) {
                            idFile.remove ();
                    }
                }
                if (tsIsRespondToManuallyDeleted) {
                    tsMoveToTrash (whiteFile, 1, null, true, suspectedTriples[c][1], false);
                }
            }
        }
    }
}

function updateProgress () {
    /**///$.writeln ($.line);
    try {
        app.document.navbars.filesystem.top.updatingFolders.text = "Updating folders: " + (tsFoldersChanged.length + growingFolders.length);
    }
    catch (e) {
        
    }    
    
    if (tsFoldersChanged.length == 0) {
        
        
        try {
            if (app.document.navbars.filesystem.top.newIDAlert) {
                app.document.navbars.filesystem.top.newIDAlert.text = "";
            }
        }
        catch (e) {
            
        }        
        
        try {
            if (app.document.navbars.filesystem.top.newFileName) {
                app.document.navbars.filesystem.top.newFileName.text = "";
            }
        }
        catch (e) {
            
        }
    }
}

function tsGetUserInfo (targetFile) {  
    /**///$.writeln ($.line);
    var infoArray = new Array;
    infoArray.push (""); //User ID
    infoArray.push (""); //User User Name
    infoArray.push (""); //User Email
    infoArray.push (""); //User Key
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_READ);
        var xmp = xmpFile.getXMP();
        var TS_USER_ID = xmp.getProperty(treeShadeNamespace, "TS_USER_ID");
        TS_USER_ID = TS_USER_ID + "";
        infoArray[0] = TS_USER_ID;
        var TS_USER_NAME = xmp.getProperty(treeShadeNamespace, "TS_USER_NAME");
        TS_USER_NAME = TS_USER_NAME + "";
        infoArray[1] = TS_USER_NAME;
        var TS_USER_EMAIL = xmp.getProperty(treeShadeNamespace, "TS_USER_EMAIL");
        TS_USER_EMAIL = TS_USER_EMAIL + "";
        infoArray[2] = TS_USER_EMAIL;
        var TS_USER_KEY = xmp.getProperty(treeShadeNamespace, "TS_USER_KEY");
        TS_USER_KEY = TS_USER_KEY + "";
        infoArray[3] = TS_USER_KEY;
        xmpFile.closeFile(XMPConst.CLOSE_UPDATE_SAFELY);
        return infoArray;
    }
    catch (e) {
        return null;
    }
}

function tsGetScopeInfo (targetFile) {  
    /**///$.writeln ($.line);
    var infoArray = new Array;
    infoArray.push (""); //Scope Name
    infoArray.push (""); //Scope Description
    infoArray.push (""); //Scope Email
    infoArray.push (""); //Scope Loading "Auto Load", "No Load"
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_READ);
        var xmp = xmpFile.getXMP();
        var TS_SCOPE_NAME = xmp.getProperty(treeShadeNamespace, "TS_SCOPE_NAME");
        TS_SCOPE_NAME = TS_SCOPE_NAME + "";
        infoArray[0] = TS_SCOPE_NAME;
        var TS_SCOPE_DESCRIPTION = xmp.getProperty(treeShadeNamespace, "TS_SCOPE_DESCRIPTION");
        TS_SCOPE_DESCRIPTION = TS_SCOPE_DESCRIPTION + "";
        infoArray[1] = TS_SCOPE_DESCRIPTION;
        var TS_SCOPE_EMAIL = xmp.getProperty(treeShadeNamespace, "TS_SCOPE_EMAIL");
        TS_SCOPE_EMAIL = TS_SCOPE_EMAIL + "";
        infoArray[2] = TS_SCOPE_EMAIL;
        var TS_SCOPE_LOADING = xmp.getProperty(treeShadeNamespace, "TS_SCOPE_LOADING");
        TS_SCOPE_LOADING = TS_SCOPE_LOADING + "";
        infoArray[3] = TS_SCOPE_LOADING;
        xmpFile.closeFile(XMPConst.CLOSE_UPDATE_SAFELY);
        return infoArray;
    }
    catch (e) {
        return null;
    }
}

function tsGetScopeID (targetFile) {  
    /**///$.writeln ($.line);
    var TS_SCOPE_ID = "";
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_READ);
        var xmp = xmpFile.getXMP();
        TS_SCOPE_ID = xmp.getProperty(treeShadeNamespace, "TS_SCOPE_ID");
        TS_SCOPE_ID = TS_SCOPE_ID + "";
        xmpFile.closeFile(XMPConst.CLOSE_UPDATE_SAFELY);
        return TS_SCOPE_ID;
    }
    catch (e) {
        return null;
    }
}

function tsUpdateUserInfo (targetFile, ID_NAME_EMAIL_KEY) {
    /**///$.writeln ($.line);
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpUpdateFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_UPDATE);
        var xmpUpdate = xmpUpdateFile.getXMP();
        xmpUpdate.setProperty( treeShadeNamespace, "TS_USER_ID", ID_NAME_EMAIL_KEY[0]);
        xmpUpdate.setProperty( treeShadeNamespace, "TS_USER_NAME", ID_NAME_EMAIL_KEY[1]);
        xmpUpdate.setProperty( treeShadeNamespace, "TS_USER_EMAIL", ID_NAME_EMAIL_KEY[2]);
        if (ID_NAME_EMAIL_KEY.length > 3)
            xmpUpdate.setProperty( treeShadeNamespace, "TS_USER_KEY", ID_NAME_EMAIL_KEY[3]);
        if (xmpUpdateFile.canPutXMP(xmpUpdate)) {
            xmpUpdateFile.putXMP(xmpUpdate);
        }
        xmpUpdateFile.closeFile (XMPConst.CLOSE_UPDATE_SAFELY);
        return true;
    }
    catch (error) {
        returned = false;
    }
}

function tsGetMetadata (targetImage, key) {  
    /**///$.writeln ($.line);
    var TS_VALUE = "";
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpFile = new XMPFile(targetImage.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_READ);
        var xmp = xmpFile.getXMP();
        TS_VALUE = xmp.getProperty(treeShadeNamespace, key);
        if (TS_VALUE) 
        TS_VALUE = TS_VALUE + "";
        xmpFile.closeFile(XMPConst.CLOSE_UPDATE_SAFELY);
        return TS_VALUE;
    }
    catch (e) {
        return null;
    }
}

function tsSetMetadata (targetImage, key, value) {
    /**///$.writeln ($.line);
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpUpdateFile = new XMPFile(targetImage.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_UPDATE);
        var xmpUpdate = xmpUpdateFile.getXMP();
        xmpUpdate.setProperty( treeShadeNamespace, key, value);
        if (xmpUpdateFile.canPutXMP(xmpUpdate)) {
            xmpUpdateFile.putXMP(xmpUpdate);
        }
        xmpUpdateFile.closeFile (XMPConst.CLOSE_UPDATE_SAFELY);
        return true;
    }
    catch (error) {
        returned = false;
    }
}

function tsUpdateScopeInfo (targetFile, NAME_DESCRIPTION_EMAIL_LOADING) {
    /**///$.writeln ($.line);
    //TS_SCOPE_NAME
    //TS_SCOPE_DESCRIPTION
    //TS_SCOPE_EMAIL
    //TS_SCOPE_LOADING
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpUpdateFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_UPDATE);
        var xmpUpdate = xmpUpdateFile.getXMP();
        xmpUpdate.setProperty( treeShadeNamespace, "TS_SCOPE_NAME", NAME_DESCRIPTION_EMAIL_LOADING[0]);
        xmpUpdate.setProperty( treeShadeNamespace, "TS_SCOPE_DESCRIPTION", NAME_DESCRIPTION_EMAIL_LOADING[1]);
        xmpUpdate.setProperty( treeShadeNamespace, "TS_SCOPE_EMAIL", NAME_DESCRIPTION_EMAIL_LOADING[2]);
        xmpUpdate.setProperty( treeShadeNamespace, "TS_SCOPE_LOADING", NAME_DESCRIPTION_EMAIL_LOADING[3]);
        if (xmpUpdateFile.canPutXMP(xmpUpdate)) {
            xmpUpdateFile.putXMP(xmpUpdate);
        }
        xmpUpdateFile.closeFile (XMPConst.CLOSE_UPDATE_SAFELY);
        return true;
    }
    catch (error) {
        returned = false;
    }
}

function tsSetScopeID (targetFile, SCOPE_ID) {
    /**///$.writeln ($.line);
    //SCOPE_ID
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpUpdateFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_UPDATE);
        var xmpUpdate = xmpUpdateFile.getXMP();
        xmpUpdate.setProperty( treeShadeNamespace, "TS_SCOPE_ID", SCOPE_ID);
        if (xmpUpdateFile.canPutXMP(xmpUpdate)) {
            xmpUpdateFile.putXMP(xmpUpdate);
        }
        xmpUpdateFile.closeFile (XMPConst.CLOSE_UPDATE_SAFELY);
        return true;
    }
    catch (error) {
        returned = false;
    }
}

function tsIsShade (targetFile) {
    /**///$.writeln ("tsIsShade " + targetFile.fsName.replace(/\\/g, '/') + " " + $.line);
    if (targetFile.length > 128) {
        return false;
    }
    else {
        var fileID = readFile (targetFile);
        if (fileID) {
            fileID = fileID.split (":");
            if (fileID.length > 1) {
                if (fileID[0] == "TS_ID") {
                    return fileID[1];
                }
                else {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        else {
            return null;
        }
    }
}

function tsGetID (targetFile) {  
    /**///$.writeln ("tsGetID " + targetFile.fsName.replace(/\\/g, '/') + " " + $.line);
    var shadeFileID = tsIsShade (targetFile);
    if (shadeFileID) {
        return shadeFileID;
    }
    var isCS = isCSFile (targetFile);
    if (isCS) {
        try {
            if (ExternalObject.AdobeXMPScript == undefined)
                  ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
            XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
            var xmpFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_READ);
            var xmp = xmpFile.getXMP();
            var fileID = xmp.getProperty(treeShadeNamespace, "TS_ID");
            if (!fileID)
                fileID = "";
            fileID = fileID + "";
            xmpFile.closeFile(XMPConst.CLOSE_UPDATE_SAFELY);
            return fileID;
        }
        catch (e) {
            return null;
        }
    }
    else {
        var idFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + File.decode (targetFile.name));
        if (idFile.exists) {
            var fileID = readFile (idFile);
            if (fileID) {
                fileID = fileID.split (":");
                if (fileID.length > 1) {
                    return fileID[1];
                }
            }
        }
        return "";
    }
}

function tsGetPgDocID (targetFile) {  
    /**///$.writeln ("tsGetJpgThumbID " + targetFile.fsName.replace(/\\/g, '/') + " " + $.line);
    try {
        if (ExternalObject.AdobeXMPScript == undefined)
              ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
        XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
        var xmpFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_READ);
        var xmp = xmpFile.getXMP();
        var pgDocID = xmp.getProperty(treeShadeNamespace, "TS_PG_DOCID");
        if (!pgDocID)
            pgDocID = "";
        pgDocID = pgDocID + "";
        xmpFile.closeFile(XMPConst.CLOSE_UPDATE_SAFELY);
        return pgDocID;
    }
    catch (e) {
        return null;
    }
}

function tsUpdateFileState (targetFile, folderIndex, fileIndex) {
    /**///$.writeln ($.line);
    var actualFullPath = targetFile.fsName.replace(/\\/g, '/');
    var tsID = tsGetID (targetFile);
    var finalID = null;
    if (tsID == null && folderIndex != -2) {
        var isGrowing = false;
        if (folderIndex == -1) {
            for (var f = 0; f < growingFolders.length; f++) {
                if (growingFolders[f][0] == targetFile.parent.fsName.replace(/\\/g, '/')) {
                    folderIndex = f;
                    growingFolders[f][1] = tsGrowingInterval;
                    break;
                }
            }
        }
        if (folderIndex == -1) {
            folderIndex = growingFolders.length;
            fileIndex = 0;
            var newGrowingFolder = new Array;
            newGrowingFolder.push (targetFile.parent.fsName.replace(/\\/g, '/'));
            newGrowingFolder.push (tsGrowingInterval);
            var newGrowingFiles = new Array;
            var newGrowingFile = new Array;
            newGrowingFile.push (actualFullPath);
            newGrowingFile.push (targetFile.length);
            newGrowingFiles.push (newGrowingFile);
            newGrowingFolder.push (newGrowingFiles);
            growingFolders.push (newGrowingFolder);
            isGrowing = true;
        }
        else {
            if (fileIndex == -1) {
                for (var g = 0; g < growingFolders[folderIndex][2].length; g++) {
                    if (actualFullPath == growingFolders[folderIndex][2][g][0]) {
                        fileIndex = g;
                        break;
                    }
                }
            }
            if (fileIndex == -1) {
                growingFolders[folderIndex][1] = tsGrowingInterval;
                fileIndex = growingFolders[folderIndex][2].length;
                var newGrowingFile = new Array;
                newGrowingFile.push (actualFullPath);
                newGrowingFile.push (targetFile.length);
                growingFolders[folderIndex][2].push (newGrowingFile);
                isGrowing = true;
            }
        }
        if (!isGrowing) {
            if (growingFolders[folderIndex][2][fileIndex][1] != targetFile.length) {
                growingFolders[folderIndex][1] = tsGrowingInterval;
                isGrowing = true;
            }
        }
        if (isGrowing) {
            return "growing";
        }
        else {
            return false;
        }
    }
    var shadeFile = new File (actualFullPath.replace (tsWorkshopPath, tsDataPath + "/Shades"));
    if (shadeFile.exists) {
        var alternateID = tsGetID (shadeFile);
        if (tsID == alternateID) {
            return tsID;
        }
        else {
            if (tsIsStaticIDs || !tsID) {
                if (!tsUpdateID (targetFile, alternateID))
                    return false;
                if (tsID) {
                    var relationFileIDMark = File (tsDataPath + "/IDs" + alternateID + "/" + "Previous" + " ID");
                    relationFileIDMark.parent.create ();
                    writeFile (relationFileIDMark, tsID);
                }
                tsID = alternateID;
            }
            else if (alternateID) {
                var tripleCells = new Array;
                tripleCells.push (shadeFile.fsName.replace(/\\/g, '/'));
                tripleCells.push (alternateID);
                tripleCells.push (false); 
                if (isOddStage) {
                    suspectedOdd.push (tripleCells);
                }
                else {
                    suspectedEven.push (tripleCells);
                }
            }
        }
    }
    var modificationDate = new Date().getTime ();
    if (!tsID) {
        if (File.decode (targetFile.name)[0] == '[') {
            var newFullPath = checkDynamicName (targetFile, true);
            if (newFullPath) {
                if (folderIndex == -2) {
                    return tsUpdateFileState (File (newFullPath), -2, -1);
                }
                return "adjust";
            }
        }
        finalID = tsBuildID (targetFile, modificationDate, null);
    }
    else {
        var isCopyed = false;
        var fileID_Path_newID = [tsID];
        tsGetPath (fileID_Path_newID);
        var IDRecordContent = fileID_Path_newID[1];
        var tsOldID = "";
        if (!IDRecordContent) {
            Folder (tsDataPath + "/IDs" + tsID).create ();
            IDRecordContent = actualFullPath.replace (tsWorkshopPath, "");
        }
        else {
            if ((tsWorkshopPath + IDRecordContent) != actualFullPath) { 
                var oldPathFile = new File (tsWorkshopPath + IDRecordContent);
                if (oldPathFile.exists) {
                    tsOldID = tsGetID (oldPathFile);
                    if (tsOldID) {
                        if (tsOldID == tsID) {
                            isCopyed = true;
                        }
                    }
                    else {
                        isCopyed = true;
                    }
                }
            }
        }
        if (File.decode (targetFile.name)[0] == '[') {
            var newFullPath = checkDynamicName (targetFile, true);
            if (newFullPath) {
                if (folderIndex == -2) {
                    return tsUpdateFileState (File (newFullPath), -2, -1);
                }
                return "adjust";
            }
        }
        if (isCopyed) {
            finalID = tsBuildID (targetFile, modificationDate, tsOldID);
        }
        else {
            finalID = tsID;
            var newRelativePath = actualFullPath.replace (tsWorkshopPath, "");
            if (!shadeFile.parent.exists) {
                if (!shadeFile.parent.create ())
                    return false;
            }
            if (!writeFile (shadeFile, "TS_ID:" + tsID))
                return false;
            
            //add to tsIDTimePathStepIsUserOldPathList
            var initialStep = -1;
            for (var ap = tsIDTimePathStepIsUserOldPathList.length - 1; ap >= 0; ap--) {
                if (tsIDTimePathStepIsUserOldPathList[ap][0] == tsID) {
                    if (tsIDTimePathStepIsUserOldPathList[ap][3] < 0) {
                        initialStep = 0;
                        tsIDTimePathStepIsUserOldPathList[ap][1] = modificationDate;
                        tsIDTimePathStepIsUserOldPathList[ap][5] = tsIDTimePathStepIsUserOldPathList[ap][2];
                        tsIDTimePathStepIsUserOldPathList[ap][2] = newRelativePath;
                        tsIDTimePathStepIsUserOldPathList[ap][3] = -1;
                        tsIDTimePathStepIsUserOldPathList[ap][4] = true;
                        
                    }
                    else {
                        initialStep = -2;
                    }
                }
            }
            
            var IDTimePathStepIsUserOldPath = new Array;
            if (initialStep < 0) {
                var IDTimePathStepIsUserOldPath = new Array;
                IDTimePathStepIsUserOldPath.push (tsID);
                IDTimePathStepIsUserOldPath.push (modificationDate);
                IDTimePathStepIsUserOldPath.push (newRelativePath);
                IDTimePathStepIsUserOldPath.push (initialStep);
                IDTimePathStepIsUserOldPath.push (true);
                IDTimePathStepIsUserOldPath.push (IDRecordContent);
                tsIDTimePathStepIsUserOldPathList.push (IDTimePathStepIsUserOldPath);
            }
            tsChangePath (tsID, newRelativePath, modificationDate);
            reflectToMirrors (tsID, IDRecordContent, newRelativePath);
            
            for (var x = 0; x < suspectedOdd.length; x++) {
                if (suspectedOdd[x][1] == finalID) {
                    if (suspectedOdd[x][2]) {
                        var oldShadeFile = new File (suspectedOdd[x][0]);
                        oldShadeFile.remove ();
                    }
                    suspectedOdd.splice (x, 1);
                    return finalID;
                }
            }
            for (var y = 0; y < suspectedEven.length; y++) {
                if (suspectedEven[y][1] == finalID) {
                    if (suspectedEven[y][2]) {
                        var oldShadeFile = new File (suspectedEven[y][0]);
                        oldShadeFile.remove ();
                    }
                    suspectedEven.splice (y, 1);
                    return finalID;
                }
            }
        
            //delete old shade file because it is not found in the previous two loops 
            if ((tsWorkshopPath + IDRecordContent) != actualFullPath) {
                var nonSuspectedShadeFile = new File (tsDataPath + "/Shades" + IDRecordContent);
                if (nonSuspectedShadeFile.exists) {
                    var oldShadeContent = readFile (nonSuspectedShadeFile);
                    if (oldShadeContent == "TS_ID:" + tsID) {
                        nonSuspectedShadeFile.remove ();
                    }
                }
            }         
            return finalID;
        }
    }
    return finalID;
}

function checkDynamicName (targetFile, isActual) {
    /**///$.writeln ($.line);
    var name = targetFile.fsName.replace(/\\/g, '/').slice (targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/") + 1);
    var closeCharIndex = name.lastIndexOf ("]");
    var isToUpdate = false;
    if (closeCharIndex == -1)
        isToUpdate = true;
    

    var absolutePath = targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
    var prefix = absolutePath.slice(1, absolutePath.lastIndexOf ("/"));
    if (prefix) {
        prefix = prefix.split ("/");
        var newPrefix = new Array;
        for (var pf = 0; pf < prefix.length; pf++) {
            var targetPortion = prefix[pf];
            if (prefix[pf][0] == '[') {
                var FolderCloseCharIndex = prefix[pf].lastIndexOf ("]");
                if (FolderCloseCharIndex > 0)
                    targetPortion = prefix[pf].slice (1, FolderCloseCharIndex);
            }
            else {
                var partDotIndex = prefix[pf].indexOf (".");
                var partBracketIndex = prefix[pf].indexOf ("[");
                if (partBracketIndex != -1) {
                    if (partDotIndex == -1 || partBracketIndex < partDotIndex) 
                        partDotIndex = partBracketIndex;
                    if (partDotIndex > 1) {
                        if (prefix[pf][partDotIndex -1] == ' ')
                            partDotIndex--;
                    }
                }
                if (partDotIndex != -1)
                    targetPortion = prefix[pf].slice (0, partDotIndex);
            }
            newPrefix.push (targetPortion);
        }
        prefix = newPrefix.join (".");
    }
    else {
        prefix = "";
    }
    if (!isToUpdate) {
        if (prefix != name.slice (1, closeCharIndex))
            isToUpdate = true;
    }
    if (isToUpdate) {
        var dotIndex = name.lastIndexOf (".");
        var extension = "";
        if (dotIndex > 0)
            extension = name.slice (dotIndex);
        var rest = "";
        if (closeCharIndex > 0) {
            if (dotIndex > 0)
                rest = name.slice (closeCharIndex + 1, dotIndex);
            else if (closeCharIndex < name.length - 1)
                rest = name.slice (closeCharIndex + 1);
        }
        if (rest.length > 0) {
            if (rest[0] != ' ')
                rest = " " + rest;
        }
        var newName = "[" + prefix + "]" + rest + extension;
        var order = 0;
        var newFullName = targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/" + newName;
        if (isActual) {
            while (File (newFullName).exists) {
                order++;
                newName = "[" + prefix + "]" + rest + order + extension;
                newFullName = targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/" + newName;
            }
            if (!tsIsShade (targetFile)) {
                if (!isCSFile (targetFile)) {
                    idFile = new File (targetFile.fsName.replace(/\\/g, '/').slice (0, targetFile.fsName.replace(/\\/g, '/').lastIndexOf ("/")) + "/.TREESHADE/" + File.decode (targetFile.name));
                    idFile.rename (newName);
                }
            }
            targetFile.rename (newName);
        }
        return newFullName;
    }
    return false;
}

function tsStartEditing (targetFile, fileID, isToOpen, CVDigitsFinal) {
    /**///$.writeln ($.line);
    if (!CVDigitsFinal) {
        var CVRecordFile = new File (tsDataPath + "/IDs" + fileID  + "/CV");
        if (CVRecordFile.exists) {
            var CVRecordSplitted = readFile (CVRecordFile);
            if (CVRecordSplitted) {
                CVRecordSplitted = CVRecordSplitted.split (":");
                CVDigitsFinal = new Array;
                CVDigitsFinal.push (CVRecordSplitted[0]);
                CVDigitsFinal.push (CVRecordSplitted[1]);
            }
        } 
    }
    if (!CVDigitsFinal) {
        return false;
    }
    
    if (CVDigitsFinal[0] == "new") {
        alert ("The file \n" + targetFile.fsName.replace(/\\/g, '/') + "\n" + "needs a version before marking it under editing.");
        return false;
    }
    var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/Modifying Time");
    var versionTime = readFile (versionTimeFile);
    if (versionTime) {
        var underEditingFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/V/" + versionTime + "/UnderEditing");
        if (underEditingFile.exists) {
            var targetThumbnail = new Thumbnail (targetFile);
            if (targetThumbnail.label == "") {    
                targetThumbnail.label = "Need To Be Checked In";
                targetThumbnail.refresh ();
            }
            if (isToOpen) {
                targetThumbnail.open ();
            }
            return true;
        }
        var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/V/" + versionTime + "/UnderEditingByOther");
        if (underEditingByOtherFile.exists) {
            var editorName = readFile (underEditingByOtherFile);
            alert ("You couldn't edit the file \n" + targetFile.fsName.replace(/\\/g, '/') + "\n" + "\nIt's under editing by " + editorName + ".");
            return false;
        }
    
        //create new version if there is a modifier
        var modifierFile = new Folder (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/V/" + versionTime + "/Modifier");
        if (modifierFile.exists) {
            var PDFExportingFile = new File (tsDataPath + "/No PDF Exporting");
            tsIsStartPDFExporting = !PDFExportingFile.exists;
                
            var versionsFolder = new Folder (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath));
            if (!versionsFolder.exists)
                versionsFolder.create ();
            var maxNumber = 0;
            var allVersions = Folder (tsDataPath + "/IDs" + fileID).getFiles ("ver??");
            if (allVersions.length > 0) {
                maxNumber = parseInt (File.decode (allVersions[allVersions.length-1].name).slice (3), 10);
            }
            maxNumber += 1;
            maxNumber = maxNumber < 10? ("0" + maxNumber.toString ()) : maxNumber.toString ();
            var filePart = new File(versionsFolder.fsName.replace(/\\/g, '/') + "/ver" + maxNumber + " " + File.decode (targetFile.name));
            var digitsFileIDTriple = new Array;
            digitsFileIDTriple.push (maxNumber);
            digitsFileIDTriple.push (filePart);
            digitsFileIDTriple.push (fileID);
            tsCheckIn (targetFile, digitsFileIDTriple, false, false, false, false, isToOpen, true, null);
            var targetThumbnail = new Thumbnail (targetFile);
            if (targetThumbnail.label == "") {    
                targetThumbnail.label = "Need To Be Checked In";
                targetThumbnail.refresh ();
            }  
            if (isToOpen) {
                targetThumbnail.open ();
            }
            return "NEW_VERSION";
        }
    
        if (!underEditingFile.parent.exists) {
            underEditingFile.parent.create ();
        }
        writeFile (underEditingFile, "TREESHADE");
        
        //alert message
        var stateTwin = getTotalGoal (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""), null, fileID, false);
        var fileDotID = fileID.replace (/\//g,"\.");
        fileDotID = fileDotID.slice (1);

        for (var auno = 0; auno < stateTwin.length; auno++) {
            for (var sp = 0; sp < stateTwin[auno].length; sp++) {
                for (var rc = 0; rc < stateTwin[auno][sp][1].length; rc++) {
                    tsIsSendingDone = false;
                    var sendingBoxesItem = new Array;
                    sendingBoxesItem.push ("NewState");
                    sendingBoxesItem.push (fileDotID + ".ver" + CVDigitsFinal[0] + "." + versionTime);
                    sendingBoxesItem.push ("UNDER_EDITING" + ":" + (new Date().getTime()));
                    recipientsList[stateTwin[auno][sp][1][rc]][8][1].push (sendingBoxesItem);
                }
            }
        }
        var targetThumbnail = new Thumbnail (targetFile);
        if (targetThumbnail.label == "") {    
            targetThumbnail.label = "Need To Be Checked In";
            targetThumbnail.refresh ();
        }  
        if (isToOpen) {
            targetThumbnail.open ();
        }
    }
}

function tsCancelEditing (targetFile, fileID, CVDigitsFinal, isInfoUser, isWithCheckout) {
    /**///$.writeln ($.line);
    var fileDotID = fileID.replace (/\//g,"\.");
    fileDotID = fileDotID.slice (1);
    if (isWithCheckout) {
        //remove modifying mark
        var modifiedMarkFile = new File (tsDataPath + "/Messages/Modified/" + fileDotID);
        if (modifiedMarkFile.exists)
            modifiedMarkFile.remove ();
    }
    if (!CVDigitsFinal) {
        var CVRecordFile = new File (tsDataPath + "/IDs" + fileID  + "/CV");
        if (CVRecordFile.exists) {
            var CVRecordSplitted = readFile (CVRecordFile);
            if (CVRecordSplitted) {
                CVRecordSplitted = CVRecordSplitted.split (":");
                CVDigitsFinal = new Array;
                CVDigitsFinal.push (CVRecordSplitted[0]);
                CVDigitsFinal.push (CVRecordSplitted[1]);
            }
        } 
    }
    if (!CVDigitsFinal) {
        return false;
    }
    if (CVDigitsFinal[0] == "new") {
        return false;
    }
    var versionTimeFile =  new File (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/Modifying Time");
    var versionTime = readFile (versionTimeFile);
    if (versionTime) {
        var underEditingByOtherFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/V/" + versionTime + "/UnderEditingByOther");
        if (underEditingByOtherFile.exists) {
            var editorName = readFile (underEditingByOtherFile);
            if (isInfoUser)
                alert ("The file \n" + targetFile.fsName.replace(/\\/g, '/') + "\n" + "is already under editing by " + editorName + ".");
            return false;
        }
        var underEditingFile = new File (tsDataPath + "/IDs" + fileID + "/ver" + CVDigitsFinal[0] + "/V/" + versionTime + "/UnderEditing");
        if (underEditingFile.exists) {
            underEditingFile.remove ();
        }
        var versionFile = new File (targetFile.parent.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsVersionsPath) + "/ver" + CVDigitsFinal[0] + " " + File.decode (targetFile.name));
        if (isWithCheckout)
            tsCheckOut (versionFile , false);
        var cancelTwin = getTotalGoal (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, ""), null, fileID, false);
        for (var auno = 0; auno < cancelTwin.length; auno++) {
            for (var sp = 0; sp < cancelTwin[auno].length; sp++) {
                for (var rc = 0; rc < cancelTwin[auno][sp][1].length; rc++) {
                    tsIsSendingDone = false;
                    var sendingBoxesItem = new Array;
                    sendingBoxesItem.push ("NewState");
                    sendingBoxesItem.push (fileDotID + ".ver" + CVDigitsFinal[0] + "." + versionTime);
                    sendingBoxesItem.push ("CANCEL_UNDER_EDITING" + ":" + (new Date().getTime()));
                    recipientsList[cancelTwin[auno][sp][1][rc]][8][1].push (sendingBoxesItem);
                }
            }
        }
    }
}

function tsMoveAndRename (fileOrFolder, newFileOrFolder, isConsiderSwap) {
    /**///$.writeln ($.line);
    var oldParentPath = fileOrFolder.fsName.replace(/\\/g, '/').slice (0, fileOrFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/"));
    var newParentFolder = new Folder (newFileOrFolder.fsName.replace(/\\/g, '/').slice (0, newFileOrFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/")));
    var newName = newFileOrFolder.fsName.replace(/\\/g, '/').slice (newFileOrFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    var oldName = fileOrFolder.fsName.replace(/\\/g, '/').slice (fileOrFolder.fsName.replace(/\\/g, '/').lastIndexOf ("/")+1);
    var isToMove = oldParentPath != newParentFolder.fsName.replace(/\\/g, '/')? true : false;
    var isToRename = oldName != newName? true : false;
    var isNewExist = newFileOrFolder.exists;
    fileOrFolder.readonly = false;
    if (isToRename) {
        fileOrFolder.readonly = false;
        if (isToMove) {
            var randomDigits = Math.floor(Math.random()*9999);
            randomDigits = fillZeros (randomDigits, 4);
            if (isNewExist && isConsiderSwap) {
                randomDigits = ".swap" + randomDigits + ".";
            }
            else {
                randomDigits = ".temp" + randomDigits + ".";
            }
            newName = randomDigits + newName;
        }
        else if (isNewExist && isConsiderSwap) {
            var randomDigits = Math.floor(Math.random()*9999);
            randomDigits = ".swap" + fillZeros (randomDigits, 4) + ".";
            newName = randomDigits + newName;
        }
        fileOrFolder.rename (newName);
    }
    if (isToMove) {
        if (isNewExist) {
            if (isConsiderSwap) {
                if (!isToRename) {
                    var randomDigits = Math.floor(Math.random()*9999);
                    randomDigits = ".swap" + fillZeros (randomDigits, 4) + ".";
                    newName = randomDigits + newName;
                    fileOrFolder.rename (newName);
                }
            }
            else {
                newFileOrFolder.readonly = false;
                if (newFileOrFolder instanceof Folder) {
                    deleteForcelyFolders (newFileOrFolder, true);
                }
                else
                    newFileOrFolder.remove ();
            }
        }
        else {
            if (!newParentFolder.exists)
                newParentFolder.create ();  
        }
        var oldToMove = new File (oldParentPath + "/" + newName);
        if (oldToMove.exists) {
            var targetThumbnail = new Thumbnail (oldToMove);
            try { targetThumbnail.moveTo (newParentFolder); }
            catch (e) {}
        }
        if (isToRename && !(isNewExist && isConsiderSwap)) {
            File (newParentFolder.fsName.replace(/\\/g, '/') + "/" + newName).rename (newName.slice (10));
        }
    }
    if (isNewExist && isConsiderSwap) {
        //tsConsiderSwapList
        //tsConsiderSwapList[x][0] adding time
        //tsConsiderSwapList[x][1] file path
        //tsConsiderSwapList[x][2] file name
        if (isToRename || isToMove)
            tsConsiderSwapList.push ([new Date ().getTime (), newParentFolder.fsName.replace(/\\/g, '/'), newName]);
    }
    return true;
}

function tsGetTreeShadeThumb (targetFileName) {
    if (targetFileName.slice (-4) == ".txt") {
        return tsTreeShadeThumb;
    }
    else {
        return "/.TREESHADE/.THUMB/";
    }
}

function reflectToMirrors (fileID, oldPath, newPath) {
    /**///$.writeln ($.line);

    //treeshade thumb
    var thumbFile =  File (tsWorkshopPath + oldPath.slice (0, oldPath.lastIndexOf ("/")) + tsGetTreeShadeThumb (oldPath.slice (oldPath.lastIndexOf ("/") + 1)) + oldPath.slice (oldPath.lastIndexOf ("/") + 1) + ".jpg");
    if (!thumbFile.exists) {
        thumbFile =  File (tsWorkshopPath + newPath.slice (0, newPath.lastIndexOf ("/")) + tsGetTreeShadeThumb (oldPath.slice (oldPath.lastIndexOf ("/") + 1)) + oldPath.slice (oldPath.lastIndexOf ("/") + 1) + ".jpg");
    }
    if (thumbFile.exists) {
        tsMoveAndRename (thumbFile, new File (tsWorkshopPath + newPath.slice (0, newPath.lastIndexOf ("/")) + tsGetTreeShadeThumb (newPath.slice (newPath.lastIndexOf ("/") + 1)) + newPath.slice (newPath.lastIndexOf ("/") + 1) + ".jpg"), true);
    }

    //versions
    var oldfullPath = tsVersionsPath + oldPath;
    var oldFolder = new Folder (oldfullPath.slice (0, oldfullPath.lastIndexOf ("/")));
    var oldName = oldfullPath.slice (oldfullPath.lastIndexOf ("/") + 1);
    var newFullPath = tsVersionsPath + newPath;
    var newFolder = new Folder (newFullPath.slice (0, newFullPath.lastIndexOf ("/")));
    var newName = newFullPath.slice (newFullPath.lastIndexOf ("/") + 1);
    var targetFiles = oldFolder.getFiles ("ver?? " + oldName);
    for (var c = 0; c < targetFiles.length; c++) {
        if (!isCSFile (targetFiles[c]) || tsGetID (targetFiles[c]) == fileID)
            tsMoveAndRename (targetFiles[c], new File (newFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (targetFiles[c].name).slice (0, 6) + newName), true);
    }
    if (oldFolder.fsName.replace(/\\/g, '/') != newFolder.fsName.replace(/\\/g, '/'))
        addToTreeEmptyFoldersList (oldPath.slice (0, oldPath.lastIndexOf ("/")));
        
    //final pdf
    oldfullPath = tsFinalPDFPath + oldPath;
    oldFolder = new Folder (oldfullPath.slice (0, oldfullPath.lastIndexOf ("/")));
    oldName = oldfullPath.slice (oldfullPath.lastIndexOf ("/") + 1);
    oldName = oldName.slice (0, oldName.lastIndexOf ("."));
    var targetFile = new File (oldFolder.fsName.replace(/\\/g, '/') + "/" + oldName + ".pdf");
    if (targetFile.exists) {
        newFullPath = tsFinalPDFPath + newPath;
        newFolder = new Folder (newFullPath.slice (0, newFullPath.lastIndexOf ("/")));
        newName = newFullPath.slice (newFullPath.lastIndexOf ("/") + 1);
        newName = newName.slice (0, newName.lastIndexOf ("."));
        tsMoveAndRename (targetFile, new File (newFolder.fsName.replace(/\\/g, '/') + "/" + newName + ".pdf"), true);
    }

    //versions PDFs
    oldfullPath = tsVersionsPDFPath + oldPath;
    oldFolder = new Folder (oldfullPath.slice (0, oldfullPath.lastIndexOf ("/")));
    oldName = oldfullPath.slice (oldfullPath.lastIndexOf ("/") + 1);        
    oldName = oldName.slice (0, oldName.lastIndexOf ("."));
    newFullPath = tsVersionsPDFPath + newPath;
    newFolder = new Folder (newFullPath.slice (0, newFullPath.lastIndexOf ("/")));
    newName = newFullPath.slice (newFullPath.lastIndexOf ("/") + 1);
    newName = newName.slice (0, newName.lastIndexOf ("."));
    targetFiles = oldFolder.getFiles ("ver?? " + oldName + ".pdf");
    for (var r = 0; r < targetFiles.length; r++) {
        var pdfVersionID = tsGetID (targetFiles[r]);
        if (pdfVersionID == fileID)
            tsMoveAndRename (targetFiles[r], new File (newFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (targetFiles[r].name).slice (0, 6) + newName + ".pdf"), true);
    }

    //pages thumbnails
    if (isInDesignFile (File (tsWorkshopPath + newPath))) {
        oldfullPath = tsVersionsPages + oldPath.slice (0, -5);
        oldFolder = new Folder (oldfullPath.slice (0, oldfullPath.lastIndexOf ("/")));
        if (oldFolder.exists) {
            oldName = oldfullPath.slice (oldfullPath.lastIndexOf ("/") + 1);
            newFullPath = tsVersionsPages + newPath.slice (0, -5);
            newFolder = new Folder (newFullPath.slice (0, newFullPath.lastIndexOf ("/")));
            newName = newFullPath.slice (newFullPath.lastIndexOf ("/") + 1);            
            var InDesignFolders = oldFolder.getFiles (isUnhiddenFolder);
            for (var r = 0; r < InDesignFolders.length; r++) {
                if (File.decode (InDesignFolders[r].name).slice (6) == oldName) {
                    var InDesignFoldersSample = InDesignFolders[r].getFiles (isUnhiddenFile);
                    var isToMovePages = true;
                    if (InDesignFoldersSample.length > 0) {
                        var sampleID = tsGetPgDocID (InDesignFoldersSample[0]);
                        if (sampleID != fileID)
                            isToMovePages = false;
                    }
                    if (isToMovePages) 
                        tsMoveAndRename (InDesignFolders[r], new Folder (newFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (InDesignFolders[r].name).slice (0, 6) + newName), true);
                }
            } 
        }
        oldfullPath = tsPagesPath + "/Workshop" + oldPath;
        var workingInDesignFolder = new Folder (oldfullPath);
        if (workingInDesignFolder.exists) {
            oldFolder = new Folder (oldfullPath.slice (0, oldfullPath.lastIndexOf ("/")));
            oldName = oldfullPath.slice (oldfullPath.lastIndexOf ("/") + 1);
            newFullPath = tsPagesPath + "/Workshop" + newPath;
            newFolder = new Folder (newFullPath.slice (0, newFullPath.lastIndexOf ("/")));
            newName = newFullPath.slice (newFullPath.lastIndexOf ("/") + 1);   
            tsMoveAndRename (workingInDesignFolder, new Folder (newFolder.fsName.replace(/\\/g, '/') + "/" + newName), true);
        }
    }
}

function tsUpdateID (targetFile, targetID) {
    /**///$.writeln ($.line);
    var returned = true;
    if (!targetFile.exists) {
        targetFile.parent.create ();
        if (!writeFile (targetFile, "TS_ID:" + targetID))
            returned = false;
    }
    else {
        if (tsIsShade (targetFile)) {
            if (!writeFile (targetFile, "TS_ID:" + targetID))
                returned = false;
        }
        else {
            var isCS = isCSFile (targetFile);
            if (isCS) {
                try {
                    if (ExternalObject.AdobeXMPScript == undefined)
                          ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');
                     XMPMeta.registerNamespace(treeShadeNamespace, treeShadePrefix);
                    var xmpUpdateFile = new XMPFile(targetFile.fsName.replace(/\\/g, '/'), XMPConst.UNKNOWN, XMPConst.OPEN_FOR_UPDATE);
                    var xmpUpdate = xmpUpdateFile.getXMP();
                    xmpUpdate.setProperty( treeShadeNamespace, "TS_ID", targetID);
                    if (xmpUpdateFile.canPutXMP(xmpUpdate)) {
                        xmpUpdateFile.putXMP(xmpUpdate);
                        xmpUpdateFile.closeFile (XMPConst.CLOSE_UPDATE_SAFELY);
                    }
                    else {
                        xmpUpdateFile.closeFile (XMPConst.CLOSE_UPDATE_SAFELY);
                        returned = false;
                    }
                }
                catch (error) {
                    return false;
                }
                tsMarkFakeModified (targetFile.modified.getTime (), targetFile, targetID);
            }
            else {
                var idFile = new File (targetFile.parent.fsName.replace(/\\/g, '/') + "/.TREESHADE/" + File.decode (targetFile.name));
                if (!idFile.parent.exists) {
                    idFile.parent.create ();
                }
                returned = writeFile (idFile, "TS_ID:" + targetID);
            }
        }
    }
    return returned;
}

function tsBuildID (targetFile, modificationDate, previousID) { 
    /**///$.writeln ($.line);
    var shadeFile = new File (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsDataPath + "/Shades"));
    var traceFile = new File (targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsDataPath + "/Traces/Inside"));
    var relativePath = targetFile.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
    var newID = produceNewID (Folder (tsDataPath + "/IDs"), relativePath, modificationDate, previousID);
    if (!newID) {
        return false;
    }
    if (!shadeFile.parent.exists)
        shadeFile.parent.create ();
    if (!traceFile.parent.exists)
        traceFile.parent.create ();
    if (!tsUpdateID (targetFile, newID))
        return false;
    if (!writeFile (shadeFile, "TS_ID:" + newID))
        return false;
    if (!writeFile (traceFile, "TS_ID:" + newID))
        return false;

    var IDTimePathStepIsUserOldPath = new Array;
    IDTimePathStepIsUserOldPath.push (newID);
    IDTimePathStepIsUserOldPath.push (modificationDate);
    IDTimePathStepIsUserOldPath.push (relativePath);
    IDTimePathStepIsUserOldPath.push (-1);
    IDTimePathStepIsUserOldPath.push (true);
    IDTimePathStepIsUserOldPath.push (null);
    tsIDTimePathStepIsUserOldPathList.push (IDTimePathStepIsUserOldPath);
    tsChangePath (newID, relativePath, modificationDate);
    try {
        if (app.document.navbars.filesystem.top.newIDAlert) {
            var showID = newID.slice (1);
            showID = showID.slice (showID.indexOf ("/"));
            app.document.navbars.filesystem.top.newIDAlert.text = showID;
        }
        if (app.document.navbars.filesystem.top.newFileName) {
            app.document.navbars.filesystem.top.newFileName.text = File.decode (targetFile.name);
        }   
    }
    catch (e) {}
    if (isInDesignFile (targetFile)) {
        var targetInDesign = BridgeTalk.getSpecifier ("indesign");
        var talkInDesign = new BridgeTalk;
        talkInDesign.target = targetInDesign;
        talkInDesign.onResult = function (returnBtObj)
        { setInDesignScript (returnBtObj.body); }
        talkInDesign.body = 
            "testExisting ();" +
            "function testExisting () {" +
                "for (var a = 0; a < app.documents.length; a++) " +
                "{" + 
                    "var resultPath = app.documents[a].filePath.fsName.replace(/\\/g, '/');" + //replace(/\\/g, '/')
                    "if (resultPath + '/' + app.documents[a].name == '" + targetFile.fsName.replace(/\\/g, '/') + "') {" +
                        "var returnedValue = resultPath + '/' + app.documents[a].name;" +
                        "app.documents[a].metadataPreferences.setProperty('http://ns.dulajun.com/treeshade/', 'TS_ID', '" + newID + "');" +
                        //"app.documents[a].save ();" +
                        "return '" + newID + "';" +
                    "}" +
                "}" +
                "return false;" +
            "}";
        talkInDesign.send ();
        function setInDesignScript (theBody) {
            if (theBody) {
                if (theBody != "false") {
                    //mark the document as opened
                    var docDotID = theBody;
                    docDotID = docDotID.replace (/\//g,"\.");
                    docDotID = docDotID.slice (1);
                    var openedMarkFile = new File (tsDataPath + "/Opened Documents/" + docDotID);
                    if (!openedMarkFile.parent.exists)
                        openedMarkFile.parent.create ();
                    writeFile (openedMarkFile, new Date().getTime());
                }
            }
        } 
    }
    /*else if (File.decode (targetFile.parent.name) == "fonts") {
        var digitsFileTitleTriple = getWorkshopVersionInfo (targetFile, null);
        tsCheckIn (targetFile, digitsFileTitleTriple, true, false, false, true, false, true, null);
    }*/
    return newID;
}

function writeEncodedFile (targetFile, fileNewContent) {
    try {
        targetFile.open ("write");
        targetFile.write (File.encode (fileNewContent));
        targetFile.close ();
    }
    catch (e) {return false;}
    return true;
}

function readEncodedFile (targetFile) {
    var content = "";
    if (targetFile.exists) {
        try {
            targetFile.open ("read");
            content = File.decode (targetFile.read());
            targetFile.close ();
        }
        catch (e) {return false;}
        return content;
    }
    else {
        return false;
    }
}

function writeFile (targetFile, fileNewContent) {
    try {
        targetFile.open ("write");
        targetFile.write (fileNewContent);
        targetFile.close ();
    }
    catch (e) {return false;}
    return true;
}

function readFile (targetFile) {
    var content = "";
    if (targetFile.exists) {
        try {
            targetFile.open ("read");
            content = targetFile.read();
            targetFile.close ();
        }
        catch (e) {return false}
        content = content.replace (/\r\n/g, "\n");
        return content;
    }
    else {
        return false;
    }
}

function produceNewID (IDsCellsFolder, pathRecord, modificationDate, previousID) {
    /**///$.writeln ($.line);
    var blockFolder = new Folder (IDsCellsFolder.fsName.replace(/\\/g, '/') + "/" + tsUserID + tsPrefixID);
    var idFolder = produceNewFolder (blockFolder, 3, 3);
    if (!idFolder) {
        tsPrefixID = fillZeros (parseInt (tsPrefixID, 10) + 1, 2);
        writeFile (File (tsDataPath + "/IDsPrefix"), tsPrefixID);
        blockFolder = new Folder (IDsCellsFolder.fsName.replace(/\\/g, '/') + "/" + tsUserID + tsPrefixID);
        blockFolder.create ();
        idFolder = produceNewFolder (blockFolder, 3, 3);
    }
    if (idFolder) {
        var pathTimeFile = new File (idFolder + "/Path/Change Time");
        writeFile (pathTimeFile, modificationDate);
        var valueFile = new File (idFolder + "/Path/V/" + pathTimeFile + "/Value");
        writeEncodedFile (valueFile, pathRecord);
        if (previousID) {
            writeFile (File (idFolder + "/Previous ID"), previousID);
            //Copy Inherited information
            var previousAutoCheckInMarkFile = new File (tsDataPath + "/IDs" + previousID + "/Auto Check In Mark");
            if (previousAutoCheckInMarkFile.exists) {
                previousAutoCheckInMarkFile.copy (idFolder + "/Auto Check In Mark");
            }
            var originalIDMarkFile = new File (tsDataPath + "/IDs" + previousID + "/Original ID");
            if (originalIDMarkFile.exists) {
                originalIDMarkFile.copy (idFolder + "/Original ID");
            }
            else {
                writeFile (File (idFolder + "/Original ID"), previousID);
            }
        }
        var relativeString = idFolder.fsName.replace(/\\/g, '/').replace (IDsCellsFolder.fsName.replace(/\\/g, '/'), "");
        return relativeString;
    }
    return false;
}

function produceNewFolder (parentFolder, digitsCount, levels) {
    /**///$.writeln ($.line);
    levels --;
    var lastFolder;
    if (Folder (parentFolder.fsName.replace(/\\/g, '/') + "/dulajun").exists) {
        lastFolder = Folder (parentFolder.fsName.replace(/\\/g, '/') + "/dulajun").getFiles (isUnhiddenFolder);
        if (lastFolder.length > 1) {
            for (var r = 0; r < lastFolder.length - 1; r++) {
                lastFolder[r].remove ();
            }
            lastFolder = [lastFolder[lastFolder.length - 1]];
        }
        if (lastFolder.length == 1) {
            if (File.decode (lastFolder[0].name).length > digitsCount) {
                return false;
            }
        }
        else {
            return false;
        }
    }
    else {
        var dulajunFolder = new Folder (parentFolder.fsName.replace(/\\/g, '/') + "/dulajun");
        dulajunFolder.create();
        var lastString = (levels == 0)? "-1" : fillZeros (0, digitsCount);
        var tempFolder = new Folder (dulajunFolder.fsName.replace(/\\/g, '/') + "/" + lastString);
        tempFolder.create ();
        lastFolder = new Array;
        lastFolder.push (tempFolder);
        Folder (parentFolder.fsName.replace(/\\/g, '/') + "/" + fillZeros (0, digitsCount)).create ();
    }
    var maxFolder = new Folder (parentFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (lastFolder[0].name));  
    var nextNumber = parseInt (File.decode (maxFolder.name), 10) + 1; 
    if (levels == 0) {
        if (nextNumber >= Math.pow(10, digitsCount)) {
            lastFolder[0].rename (File.decode (lastFolder[0].name) + "N");
            return false;
        }
        else {
            var nextNumberFilled = fillZeros (nextNumber, digitsCount);
            lastFolder[0].rename (nextNumberFilled);
            var finalFolder = new Folder (parentFolder.fsName.replace(/\\/g, '/') + "/" + nextNumberFilled); 
            finalFolder.create (); 
            return finalFolder;
        }
    }
    else {
        var finalFolder = produceNewFolder (maxFolder, digitsCount, levels);
        if (!finalFolder) {
            if (nextNumber >= Math.pow(10, digitsCount)) {
                lastFolder[0].rename (File.decode (lastFolder[0].name) + "N");
                return false;
            }
            else {
                var nextNumberFilled = fillZeros (nextNumber, digitsCount);
                lastFolder[0].rename (nextNumberFilled);
                var nextFolder = new Folder (parentFolder.fsName.replace(/\\/g, '/') + "/" + nextNumberFilled);
                nextFolder.create ();
                return produceNewFolder (nextFolder, digitsCount, levels);
            }
        }
        else {
            return finalFolder;
        }
    }   
}

function fillZeros (number, digitsCount) {
	var digits = number.toString();
	while (digits.length < digitsCount)
		digits = "0" + digits;
	return digits;
}

function isUnhiddenFolder (targetFile) {
    if (targetFile instanceof Folder) {
        if (File.decode (targetFile.name)[0] != ".")
            return true;
    }
    return false;
}

function isUnhiddenFile (targetFile) {
    if (targetFile instanceof Folder)
        return false;
    if (targetFile.hidden || File.decode (targetFile.name)[0] == '.')
        return false;
    return true;
}

function tsIsLabelFile (targetFile) {
    if (targetFile instanceof Folder)
        return false;
    if (targetFile.hidden || targetFile.name[0] != '-')
        return false;
    return true;
}

function isUnhiddenShortcutFile (targetFile) {
    if (targetFile instanceof Folder)
        return false;
    if (targetFile.hidden)
        return false;
    if (!targetFile.alias)
        return false;
    return true;
}

function isAcceptedFile (targetFile) {
    if (targetFile instanceof Folder)
        return false;
    if (targetFile.hidden || File.decode (targetFile.name)[0] == '.') {
        return false;
    }
    if (File.decode (targetFile.name).slice (-5) == ".idlk" || File.decode (targetFile.name).slice (-4) == ".tmp" || File.decode (targetFile.name).slice (-4) == ".lst" || File.decode (targetFile.name).slice (-8) == ".txt.jpg" || File.decode (targetFile.name).slice(0, 2) == "~$")
        return false;
    if (File.decode (targetFile.name) == "| Browse in Bridge to Resume Scanning")
        return false;
    if (File.decode (targetFile.name).search(/ver\d\d /i) == 0) {
        if (targetFile.fsName.replace(/\\/g, '/').indexOf ("/Workshop/") != -1) {
            return false;
        }
    }
    return true;
}

function isPDFVerFile (targetFile) {
    if (targetFile instanceof Folder)
        return false;
    if (File.decode (targetFile.name).search(/ver\d\d /i) == 0 && File.decode (targetFile.name).slice (-4) == ".pdf") {
        return true;
    }
    return false;
}

function isAcceptedSyncedFile (targetFile) {
    if (targetFile instanceof Folder)
        return false;
    if (targetFile.hidden)
        return false;
    if ((File.decode (targetFile.name).slice (File.decode (targetFile.name).lastIndexOf ("."))).toLowerCase() == ".!sync")
        return false;
    return true;
}

function isUnhiddenFileOrFolder (targetFile) {
    if (targetFile.hidden || File.decode (targetFile.name)[0] == '.')
        return false;
    return true;
}

function isAcceptedFileOrFolder (targetFile) {
    if (targetFile instanceof Folder) {
        if (File.decode (targetFile.name).search(/ver\d\d /i) == 0 || File.decode (targetFile.name).indexOf ("untitled folder") == 0 || File.decode (targetFile.name)[0] == '.') 
            return false;
    }
    else {
        if (targetFile.hidden || File.decode (targetFile.name)[0] == '.') {
            return false;
        }
        if (File.decode (targetFile.name).slice (-5) == ".idlk" || File.decode (targetFile.name).slice (-4) == ".tmp" || File.decode (targetFile.name).slice (-4) == ".lst" || File.decode (targetFile.name).slice (-8) == ".txt.jpg" || File.decode (targetFile.name).slice(0, 2) == "~$")
            return false;
        if (File.decode (targetFile.name) == "| Browse in Bridge to Resume Scanning")
            return false;
        if (File.decode (targetFile.name).search(/ver\d\d /i) == 0) {
            if (targetFile.fsName.replace(/\\/g, '/').indexOf ("/Workshop/") != -1) {
                return false;
            }
        }
    }
    return true;
}

function isAcceptedFolder (targetFile) {
    if (targetFile instanceof Folder) {
        if (File.decode (targetFile.name).search(/ver\d\d /i) == 0 || File.decode (targetFile.name).indexOf ("untitled folder") == 0 || File.decode (targetFile.name)[0] == '.') 
            return false;
        return true;
    }
    return false;
}

function isInDesignOrAcceptedFolder (targetFile) {
    if (targetFile instanceof Folder) {
        if (File.decode (targetFile.name).search(/ver\d\d /i) == 0 || File.decode (targetFile.name).indexOf ("untitled folder") == 0 || File.decode (targetFile.name)[0] == '.') 
            return false;
        return true;
    }
    if (targetFile.hidden)
        return false;
    if (File.decode (targetFile.name).slice(File.decode (targetFile.name).length - 5).toLowerCase() == ".indd")
        return true;
    return false;
}

function isCSFile (targetFile) {
    if (targetFile instanceof Folder) {
        return false;
    }
    if (targetFile.hidden)
        return false;
    var dotIndex = File.decode (targetFile.name).lastIndexOf (".");
    if (dotIndex == -1) {
        return false;
    }
    else {
        var fileExtension = File.decode (targetFile.name).slice (dotIndex);
        fileExtension = fileExtension.toLowerCase();
        for (var c = 0; c < CSExtensionList.length; c++) {
            if (fileExtension == CSExtensionList[c]) {
                return true;
            }
        }
    }
    return false;
}

function isJpgFile (targetFile) {
    if (targetFile instanceof Folder) {
        return false;
    }
    if (targetFile.hidden)
        return false;
    if (File.decode (targetFile.name).slice(File.decode (targetFile.name).length - 4).toLowerCase() == ".jpg")
        return true;
    return false;
}

function isJpgOrPngFile (targetFile) {
    if (targetFile instanceof Folder) {
        return false;
    }
    if (targetFile.hidden)
        return false;
    if (File.decode (targetFile.name).slice(File.decode (targetFile.name).length - 4).toLowerCase() == ".jpg")
        return true;
    if (File.decode (targetFile.name).slice(File.decode (targetFile.name).length - 4).toLowerCase() == ".png")
        return true;
    return false;
}

function isInDesignFile (targetFile) {
    if (targetFile instanceof Folder) {
        return false;
    }
    if (targetFile.hidden)
        return false;
    if (File.decode (targetFile.name).slice(File.decode (targetFile.name).length - 5).toLowerCase() == ".indd")
        return true;
    return false;
}

function tsIsLiveSnippetFile (targetFile) {
    if (targetFile instanceof Folder) {
        return false;
    }
    if (targetFile.hidden)
        return false;
    if (File.decode (targetFile.name).slice(File.decode (targetFile.name).length - 4).toLowerCase() == ".txt")
        return true;
    return false;
}

function isInDesignFolder (targetFolder) {
    if (targetFolder instanceof Folder) {
        if (targetFolder.name.search (/^ver\d\d/) == 0 || targetFolder.name.search (/.indd$/) != -1)
            return true;
    }
    return false;
}

function isAnyOfThese (targetFile) {
    var string = File.decode (targetFile.name).slice (0, (File.decode (targetFile.name).lastIndexOf (".") != -1)? File.decode (targetFile.name).lastIndexOf (".") : File.decode (targetFile.name).length);
    if (string.slice (0, 3) == "ver")
        string = string.slice (6);
    for (var c = 0; c < tsToBeSelectedList.length; c++) {
        if (tsToBeSelectedList[c] == string)
            return true;
    }
    return false;
}

function shootFolder (targetFolder) {
    /**///$.writeln ($.line);
    var isUnderCheckingOut = false;
    for (var vw = tsVersionsToWorkshopList.length -1 ; vw >= 0; vw--) {
        if (tsVersionsToWorkshopList[vw][2].parent.fsName.replace(/\\/g, '/') == targetFolder.fsName.replace(/\\/g, '/')) { //tsVersionsToWorkshopList[x][2] destination file
            isUnderCheckingOut = true;
            break;
        }
    }
    var isAdjust = false;
    var folderIndex = -1;
    for (var q = growingFolders.length - 1; q >= 0; q --) {
        if (growingFolders[q][0] == targetFolder.fsName.replace(/\\/g, '/')) {
            folderIndex = q;
            growingFolders[q][1] -= 1;
            if (growingFolders[q][1] > 0) {
                return false;
            }
            else {
                break;
            }
        }
    }
    var startingShotFile = new File ((targetFolder.fsName.replace(/\\/g, '/') + "/startingDate").replace (tsWorkshopPath, tsDataPath + "/Shots"));
    if (!startingShotFile.parent.exists) {
        startingShotFile.parent.create();
    }
    if (folderIndex != -1) {
        for (var g = growingFolders[folderIndex][2].length - 1; g >= 0; g--) {
            var growingFile = new File (growingFolders[folderIndex][2][g][0]);
            var result = tsUpdateFileState (growingFile, folderIndex, g);
            if (result == "growing") {
                return "growing";
            }
            else if (result == "adjust") {
                isAdjust = true;
            }
        }
    }
    if (!writeFile (startingShotFile, "TS")) {
        return false;
    }
    var allFiles = targetFolder.getFiles (isAcceptedFileOrFolder);
    for (var i = allFiles.length -1; i >= 0; i--) {
        if (allFiles[i] instanceof Folder) {

        }
        else {
            var updateResult = tsUpdateFileState (allFiles[i], folderIndex, -1);
            if (updateResult == "growing") {
                return "growing";
            }
            else if (updateResult == "adjust") {
                isAdjust = true;
            }
        }
    }
    if (isAdjust) {
        return "adjust";
    }
    if (isUnderCheckingOut) {
        return "checkout";
    }
    var startingDate;
    if (startingShotFile.exists) {
        startingDate = startingShotFile.modified.getTime ();
    }
    else {
        startingDate = new Date ().getTime ();
    }
    var folderDate = targetFolder.modified.getTime (); 
    var isDateChanged = (startingDate <= folderDate)? true : false;
    if (isDateChanged) { 
        if (folderIndex != -1) {
            growingFolders[folderIndex][1] = tsGrowingInterval;
        }
        else {
            folderIndex = growingFolders.length;
            var fileIndex = 0;
            var newGrowingFolder = new Array;
            newGrowingFolder.push (targetFolder.fsName.replace(/\\/g, '/'));
            newGrowingFolder.push (tsGrowingInterval);
            var newGrowingFiles = new Array;
            newGrowingFolder.push (newGrowingFiles);
            growingFolders.push (newGrowingFolder);
        } 
        return "growing";
    }
    else {
        if (folderIndex != -1) {
            growingFolders.splice (folderIndex, 1);
        }
    }
    var shadeFolder = new Folder (targetFolder.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, tsDataPath + "/Shades")); 
    var shadeFiles = shadeFolder.getFiles (isAcceptedFileOrFolder);

    for (var x = shadeFiles.length - 1; x >= 0; x--) {
        if (shadeFiles[x] instanceof Folder) {

        }
        else {
            var isDeleted = true;
            for (var y = allFiles.length - 1; y >= 0; y--) {
                if (allFiles[y] instanceof Folder) {
    
                }
                else {
                    if (File.decode (allFiles[y].name) == File.decode (shadeFiles[x].name)) {
                        isDeleted = false;
                        break;
                    }
                }
            }
            if (isDeleted) {
                var tripleCells = new Array;
                tripleCells.push (shadeFiles[x].fsName.replace(/\\/g, '/'));
                var fileContent = readFile (shadeFiles[x]);
                if (!fileContent)
                    continue;
                tripleCells.push (fileContent.split (":")[1]);
                tripleCells.push (true);
                if (isOddStage) {
                    suspectedOdd.push (tripleCells);
                }
                else {
                    suspectedEven.push (tripleCells);
                }
            }
        }
    }
    var shotDateFile = new File ((targetFolder.fsName.replace(/\\/g, '/') + "/shotDate").replace (tsWorkshopPath, tsDataPath + "/Shots"));
    if (!shotDateFile.parent.exists)
        shotDateFile.parent.create ();
    else {
        if (shotDateFile.exists) {
            if (allFiles.length == 0) {
                if (targetFolder.fsName.replace(/\\/g, '/') != tsWorkshopPath) {
                    try {
                        if ((app.document.thumbnail.spec.fsName.replace(/\\/g, '/') + "/").indexOf (targetFolder.fsName.replace(/\\/g, '/') + "/") == 0) {
                            app.document.thumbnail = new Thumbnail (targetFolder.parent.fsName.replace(/\\/g, '/'));
                        }
                        var absolutePath = targetFolder.fsName.replace(/\\/g, '/').replace (tsWorkshopPath, "");
                        addToTreeEmptyFoldersList (absolutePath);
                    }
                    catch (e) {}
                }
            }
        }
    }
    if (!writeFile (shotDateFile, "TS")) {
        return false;
    }
    else {
        try {
            if (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') == targetFolder.fsName.replace(/\\/g, '/')) {
                if (app.document) {
                    if (app.document.navbars) {
                        if (app.document.navbars.filesystem) {
                            if (app.document.navbars.filesystem.top) {
                                if (app.document.navbars.filesystem.top.waitOK) {
                                    app.document.navbars.filesystem.top.waitOK.text = "UPDATED.";
                                    if (app.document.navbars.filesystem.bottom) {
                                        if (!app.document.navbars.filesystem.bottom.workshopLid) {
                                            app.document.navbars.filesystem.bottom.workshopLid = app.document.navbars.filesystem.bottom.graphics.newBrush( app.document.navbars.filesystem.bottom.graphics.BrushType.SOLID_COLOR, [0.36, 0.89, 0.4, 1]);
                                        }
                                        app.document.navbars.filesystem.bottom.graphics.backgroundColor = app.document.navbars.filesystem.bottom.workshopLid;
                                        app.document.navbars.filesystem.bottom.visible = false;
                                        app.document.navbars.filesystem.bottom.visible = true;                                        
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (e) {
            //$.writeln ("Error " + $.line);
        }
    }
//    startingShotFile.remove ();
    return true;
}

function getSuspectedFiles (suspectedFolder) {
    /**///$.writeln ($.line);
    var allFiles = suspectedFolder.getFiles ();
    var suspectedFiles = new Array;
    for (var c = 0; c < allFiles.length; c++) {
        if (allFiles[c] instanceof Folder) {
            getSuspectedFiles (allFiles[c]);
        }
        else if (!allFiles[c].hidden) {
            suspectedFiles.push (allFiles[c]); 
        }
    }
    if (suspectedFiles.length > 0) {
        tsSuspectedFolders.push (suspectedFiles); 
    }
}

function deleteForcelyFolders (targetFolder, isWithFolder) { 
    /**///$.writeln ($.line);
    if (!targetFolder) {
        return false;
    }
    var allFiles = targetFolder.getFiles ();
    for (var c = 0; c < allFiles.length; c++) {
        if (allFiles[c]) {
            if (allFiles[c] instanceof Folder) {
                deleteForcelyFolders (allFiles[c], true);
            }
            else {
                allFiles[c].remove();
            }
        }
    }
    if (isWithFolder)
        targetFolder.remove();
    return true;
}

function tsDeleteEmptyFolders (targetFolder) { 
    /**///$.writeln ($.line);
    var allFiles = targetFolder.getFiles ();
    var notAcceptedFiles = new Array;
    var notAcceptedFolders = new Array;
    for (var c = 0; c < allFiles.length; c++) {
        var isAccepted = isAcceptedFileOrFolder (allFiles[c]);
        if (isAccepted) {
            return false;
        }
        if (allFiles[c] instanceof Folder) {
            notAcceptedFolders.push (allFiles[c]);
        }
        else {
            notAcceptedFiles.push (allFiles[c]);
        }
    }
    for (var hf = 0; hf < notAcceptedFiles.length; hf++) {
        notAcceptedFiles[hf].remove();
    }
    for (var hd = 0; hd < notAcceptedFolders.length; hd++) {
        deleteForcelyFolders (notAcceptedFolders[hd], true);
    }
    try {
        if (app.document.thumbnail.spec.fsName.replace(/\\/g, '/') == targetFolder.fsName.replace(/\\/g, '/'))
            app.document.thumbnail = new Thumbnail (app.document.thumbnail.spec.parent);
    }
    catch (e) {}
    targetFolder.remove();
    return true;
}

function getGlobalWhiteChanges (targetFolder, isCurrent) { 
    /**///$.writeln ($.line);
    if (!isCurrent) {
        var copyingLockFile = new File (targetFolder.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
        if (copyingLockFile.exists) {
            return false;
        }
    }

    var isChanged = false;
    var shotDateFile = new File ((targetFolder.fsName.replace(/\\/g, '/') + "/shotDate").replace (tsWorkshopPath, tsDataPath + "/Shots")); 
    var isDateChanged = false;
    if (shotDateFile.exists) {
        var shotDate = shotDateFile.modified.getTime (); 
        var folderDate = targetFolder.modified.getTime ();
        isDateChanged = (shotDate <= folderDate)? true : false;
        if (isDateChanged) {
            isChanged = true;
        }
    }
    else {
        isChanged = true;
    }
    if (isChanged) {
        for (var fc = 0; fc < tsFoldersChanged.length; fc++) {
            if (tsFoldersChanged[fc] == targetFolder.fsName.replace(/\\/g, '/')) {
                tsFoldersChanged.splice (fc, 1);
                break;
            }
        }
        tsFoldersChanged.unshift (targetFolder.fsName.replace(/\\/g, '/'));
    }
    if (!isCurrent) {
        var allFolders = targetFolder.getFiles (isAcceptedFolder);
        for (var c = 0; c < allFolders.length; c++) {
            getGlobalWhiteChanges (allFolders[c], isCurrent);
        }
    }
}

function getGlobalBlackChanges (targetFolder, isCurrent) { 
    /**///$.writeln ($.line);
    var shotDateFile = new File (targetFolder.fsName.replace(/\\/g, '/') + "/shotDate"); 
    var isChanged = false;
    var isDateChanged = false;
    var whiteFolder = new Folder (targetFolder.fsName.replace(/\\/g, '/').replace (tsDataPath + "/Shots", tsWorkshopPath));

    if (!isCurrent) {
        var copyingLockFile = new File (whiteFolder.fsName.replace(/\\/g, '/') + "/| Browse in Bridge to Resume Scanning");
        if (copyingLockFile.exists) {
            return false;
        }
    }
    if (shotDateFile.exists) {
        if (whiteFolder.exists) {
            var shotDate = shotDateFile.modified.getTime (); 
            var whiteFolderDate = whiteFolder.modified.getTime ();
            isDateChanged = (shotDate <= whiteFolderDate)? true : false;
            if (isDateChanged) {
                isChanged = true;
            }
        }
        else {
            var shadeFolder = new Folder (targetFolder.fsName.replace(/\\/g, '/').replace (tsDataPath + "/Shots", tsDataPath + "/Shades"));
            if (shadeFolder.exists) {
                var allShadeFiles = shadeFolder.getFiles (isAcceptedFile);
                for (var c = 0; c < allShadeFiles.length; c++) {
                    var tripleCells = new Array;
                    tripleCells.push (allShadeFiles[c].fsName.replace(/\\/g, '/'));
                    var fileContent = readFile (allShadeFiles[c]);
                    if (!fileContent)
                        continue;
                    tripleCells.push (fileContent.split (":")[1]);
                    tripleCells.push (false);
                    if (isOddStage) {
                        suspectedOdd.push (tripleCells);
                    }
                    else {
                        suspectedEven.push (tripleCells);
                    }
                }
                var allShadeToDelete = shadeFolder.getFiles ();
                for (var d = 0; d < allShadeToDelete.length; d++) {
                    allShadeToDelete[d].remove ();
                }
                shadeFolder.remove ();
            }
            var allShotsToDelete = targetFolder.getFiles ();
            for (var s = 0; s < allShotsToDelete.length; s++) {
                allShotsToDelete[s].remove ();
            }
            targetFolder.remove ();
        }
    }
    else {
        if (whiteFolder.exists) {
            isChanged = true;
        }
    }
    if (isChanged) {
        for (var fc = 0; fc < tsFoldersChanged.length; fc++) {
            if (tsFoldersChanged[fc] == whiteFolder.fsName.replace(/\\/g, '/')) {
                tsFoldersChanged.splice (fc, 1);
                break;
            }
        }
        tsFoldersChanged.unshift (whiteFolder.fsName.replace(/\\/g, '/')); 
    }
    if (!isCurrent) {
        var allFolders = targetFolder.getFiles (isUnhiddenFolder);
        for (var i = 0; i < allFolders.length; i++) {
            getGlobalBlackChanges (allFolders[i], isCurrent);
        }
    }
}

function tsGoToTree () {
    /**///$.writeln ($.line);
    if (!Folder (tsWorkshopPath).exists) {
        alert ("The 'Workshop' location isn't exist!");
        return false;
    }
    var folderParent = app.document.thumbnail.spec;
    var selectedFiles = new Array;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        if (isInDesignFolder (app.document.thumbnail.spec)) {
            folderParent = app.document.thumbnail.spec.parent;
            selectedFiles.push (app.document.thumbnail.spec);
        }
        else {
            for (var c = 0; c < app.document.selections.length; c++) {
                selectedFiles.push (app.document.selections[c].spec);
            }
        }
    }
    else {
        if (folderParent.fsName.replace(/\\/g, '/') == tsWorkshopPath) {
            var dateName = new Date().getTime();
            dateName = dateName.toString ();
            var labelFolderBrowse = new Folder (tsRootFolderPath + "/Workflow/Queries/" + dateName);
            labelFolderBrowse.create ();
            var allSubFolders = folderParent.getFiles (isAcceptedFolder);
            var isBrowse = false;
            for (var a = 0; a < allSubFolders.length; a++) {
                var labelFile = allSubFolders[a].getFiles (tsIsLabelFile);
                if (labelFile.length == 1) {
                    var shortcutFile = new File (labelFolderBrowse.fsName.replace(/\\/g, '/') + "/" + tsGetPureName (File.decode (labelFile[0].name), false));
                    if (!shortcutFile.exists) {
                        shortcutFile.createAlias (labelFile[0]);
                        isBrowse = true;
                    }
                }
            }
            if (isBrowse) {
                app.document.thumbnail = new Thumbnail (labelFolderBrowse);
                return true;
            }
        }
        for (var c = 0; c < app.document.selections.length; c++) {
            selectedFiles.push (app.document.selections[c].spec);
        }
    }
    var rootPath = "";
    var isToRoot = false;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath !="")
        isToRoot = true;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath !="")
        rootPath = tsVersionsPath;   
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "")
        rootPath = tsFinalPDFPath;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "")
        rootPath = tsVersionsPDFPath;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsPagesPath, "");
        rootPath = rootPath.slice (1);
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsPagesPath + "/" + rootPath;
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsTrashPath, "");
        rootPath = rootPath.slice (1);
        var subPages = "";
        if (rootPath.slice (0, rootPath.indexOf ("/")) == tsPagesPath.slice (tsPagesPath.lastIndexOf ("/") + 1)) {
            subPages = rootPath.slice (rootPath.indexOf ("/") + 1);
            if (subPages.indexOf ("/") >= 0)
                subPages = subPages.slice (0, subPages.indexOf ("/"));
        }
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsTrashPath + "/" + rootPath + (subPages == ""? "" : "/" + subPages);
    }
    if (rootPath) {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (rootPath, "");
    }
    var targetFolder = new Folder (tsWorkshopPath + rootPath);
    targetFolder.create ();
    if (targetFolder.exists && !isToRoot) {
        var stringList = new Array;
        for (var d = 0; d < selectedFiles.length; d++) {
            var string = File.decode (selectedFiles[d].name).slice (0, (File.decode (selectedFiles[d].name).lastIndexOf (".") != -1)? File.decode (selectedFiles[d].name).lastIndexOf (".") : File.decode (selectedFiles[d].name).length);
            if (string.slice (0, 3) == "ver")
                string = string.slice (6);
            var isRepeated = false;
            for (var k = 0; k < stringList.length; k++) {
                if (stringList[k] == string) {
                    isRepeated = true;
                    break;
                }
            }
            if (!isRepeated)
                stringList.push (string);
        }
        if (stringList.length > 0) {
            tsToBeSelectedList = stringList;
            tsLoadStage = 1;
        }
        labelTreeItems (targetFolder);
        app.document.thumbnail = new Thumbnail (targetFolder);
    }
    else {
        if (!isToRoot) {
            var toParent = targetFolder.parent;
            while (!toParent.exists) {
                toParent = toParent.parent;
            }
            app.document.thumbnail = new Thumbnail (toParent);
        }
        else {
            app.document.thumbnail = new Thumbnail (new Folder (tsWorkshopPath));
        }
    }
}

function tsGoToVersions () {
    /**///$.writeln ($.line);
    var folderParent = app.document.thumbnail.spec;
    var selectedFiles = new Array;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        if (isInDesignFolder (app.document.thumbnail.spec)) {
            folderParent = app.document.thumbnail.spec.parent;
            selectedFiles.push (app.document.thumbnail.spec);
        }
        else {
            for (var c = 0; c < app.document.selections.length; c++) {
                selectedFiles.push (app.document.selections[c].spec);
            }
        }
    }
    else {
        for (var c = 0; c < app.document.selections.length; c++) {
            selectedFiles.push (app.document.selections[c].spec);
        }
    }
    var rootPath = "";
    var isToRoot = false;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath !="")
        isToRoot = true;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath !="")
        rootPath = tsWorkshopPath;   
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "")
        rootPath = tsFinalPDFPath; 
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "")
        rootPath = tsVersionsPDFPath;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsPagesPath, "");
        rootPath = rootPath.slice (1);
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsPagesPath + "/" + rootPath;
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsTrashPath, "");
        rootPath = rootPath.slice (1);
        var subPages = "";
        if (rootPath.slice (0, rootPath.indexOf ("/")) == tsPagesPath.slice (tsPagesPath.lastIndexOf ("/") + 1)) {
            subPages = rootPath.slice (rootPath.indexOf ("/") + 1);
            if (subPages.indexOf ("/") >= 0)
                subPages = subPages.slice (0, subPages.indexOf ("/"));
        }
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsTrashPath + "/" + rootPath + (subPages == ""? "" : "/" + subPages);
    }
    if (rootPath) {folderParent
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (rootPath, "");
    }
    var targetFolder = new Folder (tsVersionsPath + rootPath);
    targetFolder.create();
    if (targetFolder.exists && !isToRoot) {
        var stringList = new Array;
        for (var d = 0; d < selectedFiles.length; d++) {
//                if (selectedFiles[d] instanceof Folder)
//                    continue;
            var string = File.decode (selectedFiles[d].name).slice (0, (File.decode (selectedFiles[d].name).lastIndexOf (".") != -1)? File.decode (selectedFiles[d].name).lastIndexOf (".") : File.decode (selectedFiles[d].name).length);
            if (string.slice (0, 3) == "ver")
                string = string.slice (6);
            var isRepeated = false;
            for (var k = 0; k < stringList.length; k++) {
                if (stringList[k] == string) {
                    isRepeated = true;
                    break;
                }
            }
            if (!isRepeated)
                stringList.push (string);
        }
        if (stringList.length > 0) {
            tsToBeSelectedList = stringList;
            tsLoadStage = 1;
        }
        labelVersions (targetFolder);
        app.document.thumbnail = new Thumbnail (targetFolder);
    }
    else {
        if (!isToRoot) {
            var toParent = targetFolder.parent;
            while (!toParent.exists) {
                toParent = toParent.parent;
            }
            app.document.thumbnail = new Thumbnail (toParent);
        }
        else {
            app.document.thumbnail = new Thumbnail (new Folder (tsVersionsPath));
        }
    }
}

function tsGoToFinalPDF () {
    /**///$.writeln ($.line);
    var folderParent = app.document.thumbnail.spec;
    var selectedFiles = new Array;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        if (isInDesignFolder (app.document.thumbnail.spec)) {
            folderParent = app.document.thumbnail.spec.parent;
            selectedFiles.push (app.document.thumbnail.spec);
        }
        else {
            for (var c = 0; c < app.document.selections.length; c++) {
                selectedFiles.push (app.document.selections[c].spec);
            }
        }
    }
    else {
        for (var c = 0; c < app.document.selections.length; c++) {
            selectedFiles.push (app.document.selections[c].spec);
        }
    }
    var rootPath = "";
    var isToRoot = false;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath !="")
        isToRoot = true;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath !="")
        rootPath = tsWorkshopPath;   
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "")
        rootPath = tsVersionsPath; 
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "")
        rootPath = tsVersionsPDFPath;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsPagesPath, "");
        rootPath = rootPath.slice (1);
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsPagesPath + "/" + rootPath;
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsTrashPath, "");
        rootPath = rootPath.slice (1);
        var subPages = "";
        if (rootPath.slice (0, rootPath.indexOf ("/")) == tsPagesPath.slice (tsPagesPath.lastIndexOf ("/") + 1)) {
            subPages = rootPath.slice (rootPath.indexOf ("/") + 1);
            if (subPages.indexOf ("/") >= 0)
                subPages = subPages.slice (0, subPages.indexOf ("/"));
        }
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsTrashPath + "/" + rootPath + (subPages == ""? "" : "/" + subPages);
    }
    if (rootPath) {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (rootPath, "");
    }
    var targetFolder = new Folder (tsFinalPDFPath + rootPath);
    targetFolder.create();
    if (targetFolder.exists && !isToRoot) {
        var stringList = new Array;
        for (var d = 0; d < selectedFiles.length; d++) {
//                if (selectedFiles[d] instanceof Folder)
//                    continue;
            var string = File.decode (selectedFiles[d].name).slice (0, (File.decode (selectedFiles[d].name).lastIndexOf (".") != -1)? File.decode (selectedFiles[d].name).lastIndexOf (".") : File.decode (selectedFiles[d].name).length);
            if (string.slice (0, 3) == "ver")
                string = string.slice (6);
            var isRepeated = false;
            for (var k = 0; k < stringList.length; k++) {
                if (stringList[k] == string) {
                    isRepeated = true;
                    break;
                }
            }
            if (!isRepeated)
                stringList.push (string);
        }
        if (stringList.length > 0) {
            tsToBeSelectedList = stringList;
            tsLoadStage = 1;
        }
        labelFinalPDF (targetFolder);
        app.document.thumbnail = new Thumbnail (targetFolder);
    }
    else {
        if (!isToRoot) {
            var toParent = targetFolder.parent;
            while (!toParent.exists) {
                toParent = toParent.parent;
            }
            app.document.thumbnail = new Thumbnail (toParent);
        }
        else {
            app.document.thumbnail = new Thumbnail (new Folder (tsFinalPDFPath));
        }
    }
}

function tsGoToPages () {
    /**///$.writeln ($.line);
    var folderParent = app.document.thumbnail.spec;
    var selectedFiles = new Array;
    for (var c = 0; c < app.document.selections.length; c++) {
        selectedFiles.push (app.document.selections[c].spec);
    }
    var rootPath = "";
    var fromKind = "";
    var isToRoot = false;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath !="") {
        isToRoot = true;
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath !="") {
        rootPath = tsWorkshopPath;
        fromKind = "/Workshop";
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "") {
        rootPath = tsVersionsPath; 
        fromKind = "/Versions";
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "") {
        rootPath = tsFinalPDFPath;
        fromKind = "/Workshop";
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "") {
        rootPath = tsVersionsPDFPath;
        fromKind = "/Versions";
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsTrashPath, "");
        rootPath = rootPath.slice (1);
        var subPages = "";
        if (rootPath.slice (0, rootPath.indexOf ("/")) == tsPagesPath.slice (tsPagesPath.lastIndexOf ("/") + 1)) {
            subPages = rootPath;
            subPages = subPages.slice (subPages.indexOf ("/") + 1);
            if (subPages.indexOf ("/") >= 0)
                subPages = subPages.slice (0, subPages.indexOf ("/"));
        }
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath += (subPages ==""? "" : "/" + subPages);
        fromKind = rootPath;
        rootPath = tsTrashPath + "/" + rootPath;
        switch("/" + fromKind) {
            case tsPagesPath.slice (tsPagesPath.lastIndexOf ("/")) + "/Workshop":
                fromKind = "/Workshop";
                break;
            case tsPagesPath.slice (tsPagesPath.lastIndexOf ("/")) + "/Versions":
                fromKind = "/Versions";
                break;
            case tsWorkshopPath.slice (tsWorkshopPath.lastIndexOf ("/")):
                fromKind = "/Workshop";
                break;
            case tsVersionsPath.slice (tsVersionsPath.lastIndexOf ("/")):
                fromKind = "/Versions";
                break;
            case tsFinalPDFPath.slice (tsFinalPDFPath.lastIndexOf ("/")):
                fromKind = "/Workshop";
                break;
            case tsVersionsPDFPath.slice (tsVersionsPDFPath.lastIndexOf ("/")):
                fromKind = "/Versions";
                break;
            default:
                fromKind = "/Workshop";
        }
    }
    if (rootPath) {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (rootPath, "");
    }
    var targetFolder = new Folder (tsPagesPath + fromKind + rootPath);
    targetFolder.create();
    if (targetFolder.exists && !isToRoot) {
        var stringList = new Array;
        var InDesignFolder;
        if (selectedFiles.length == 1) {
            if (isInDesignFile (selectedFiles[0])) {
                InDesignFolder = new Folder (targetFolder.fsName.replace(/\\/g, '/') + "/" + File.decode (selectedFiles[0].name));
            }
        }
        if (InDesignFolder) {
            if (InDesignFolder.exists) {
                targetFolder = InDesignFolder;
            } 
        }
        else {
            for (var d = 0; d < selectedFiles.length; d++) {
//                if (selectedFiles[d] instanceof Folder)
//                    continue;
                var string = File.decode (selectedFiles[d].name).slice (0, (File.decode (selectedFiles[d].name).lastIndexOf (".") != -1)? File.decode (selectedFiles[d].name).lastIndexOf (".") : File.decode (selectedFiles[d].name).length);
                if (string.slice (0, 3) == "ver")
                    string = string.slice (6);
                var isRepeated = false;
                for (var k = 0; k < stringList.length; k++) {
                    if (stringList[k] == string) {
                        isRepeated = true;
                        break;
                    }
                }
                if (!isRepeated)
                    stringList.push (string);
            }
            if (stringList.length > 0) {
                tsToBeSelectedList = stringList;
                tsLoadStage = 1;
            }
        }
        app.document.thumbnail = new Thumbnail (targetFolder);
    }
    else {
        if (!isToRoot) {
            var toParent = targetFolder.parent;
            while (!toParent.exists) {
                toParent = toParent.parent;
            }
            app.document.thumbnail = new Thumbnail (toParent);
        }
        else {
            app.document.thumbnail = new Thumbnail (new Folder (tsPagesPath));
        }
    }
}

function tsGoToVersionsPDF () {
    /**///$.writeln ($.line);
    var folderParent = app.document.thumbnail.spec;
    var selectedFiles = new Array;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        if (isInDesignFolder (app.document.thumbnail.spec)) {
            folderParent = app.document.thumbnail.spec.parent;
            selectedFiles.push (app.document.thumbnail.spec);
        }
        else {
            for (var c = 0; c < app.document.selections.length; c++) {
                selectedFiles.push (app.document.selections[c].spec);
            }
        }
    }
    else {
        for (var c = 0; c < app.document.selections.length; c++) {
            selectedFiles.push (app.document.selections[c].spec);
        }
    }
    var rootPath = "";
    var isToRoot = false;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath !="")
        isToRoot = true;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath !="")
        rootPath = tsWorkshopPath;   
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "")
        rootPath = tsVersionsPath; 
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "")
        rootPath = tsFinalPDFPath;
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsPagesPath, "");
        rootPath = rootPath.slice (1);
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsPagesPath + "/" + rootPath;
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsTrashPath, "");
        rootPath = rootPath.slice (1);
        var subPages = "";
        if (rootPath.slice (0, rootPath.indexOf ("/")) == tsPagesPath.slice (tsPagesPath.lastIndexOf ("/") + 1)) {
            subPages = rootPath.slice (rootPath.indexOf ("/") + 1);
            if (subPages.indexOf ("/") >= 0)
                subPages = subPages.slice (0, subPages.indexOf ("/"));
        }
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        rootPath = tsTrashPath + "/" + rootPath + (subPages == ""? "" : "/" + subPages);
    }
    if (rootPath) {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (rootPath, "");
    }
    var targetFolder = new Folder (tsVersionsPDFPath + rootPath);
    targetFolder.create();
    if (targetFolder.exists && !isToRoot) {
        var stringList = new Array;
        for (var d = 0; d < selectedFiles.length; d++) {
//                if (selectedFiles[d] instanceof Folder)
//                    continue;
            var string = File.decode (selectedFiles[d].name).slice (0, (File.decode (selectedFiles[d].name).lastIndexOf (".") != -1)? File.decode (selectedFiles[d].name).lastIndexOf (".") : File.decode (selectedFiles[d].name).length);
            if (string.slice (0, 3) == "ver")
                string = string.slice (6);
            var isRepeated = false;
            for (var k = 0; k < stringList.length; k++) {
                if (stringList[k] == string) {
                    isRepeated = true;
                    break;
                }
            }
            if (!isRepeated)
                stringList.push (string);
        }
        if (stringList.length > 0) {
            tsToBeSelectedList = stringList;
            tsLoadStage = 1;
        }
        labelPrevPDF (targetFolder);
        app.document.thumbnail = new Thumbnail (targetFolder);
    }
    else {
        if (!isToRoot) {
            var toParent = targetFolder.parent;
            while (!toParent.exists) {
                toParent = toParent.parent;
            }
            app.document.thumbnail = new Thumbnail (toParent);
        }
        else {
            app.document.thumbnail = new Thumbnail (new Folder (tsVersionsPDFPath));
        }
    }
}

function tsGoToTrash () {
    /**///$.writeln ($.line);
    var folderParent = app.document.thumbnail.spec;
    var selectedFiles = new Array;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        if (isInDesignFolder (app.document.thumbnail.spec)) {
            folderParent = app.document.thumbnail.spec.parent;
            selectedFiles.push (app.document.thumbnail.spec);
        }
        else {
            for (var c = 0; c < app.document.selections.length; c++) {
                selectedFiles.push (app.document.selections[c].spec);
            }
        }
    }
    else {
        for (var c = 0; c < app.document.selections.length; c++) {
            selectedFiles.push (app.document.selections[c].spec);
        }
    }
    var rootPath = "";
    var fromKind = "";
    var isToRoot = false;
    if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsTrashPath + "/") == 0 && tsTrashPath !="") {
        isToRoot = true;
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsWorkshopPath + "/") == 0 && tsWorkshopPath !="") {
        rootPath = tsWorkshopPath;
        fromKind = tsWorkshopPath.slice (tsWorkshopPath.lastIndexOf ("/"));
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPath + "/") == 0 && tsVersionsPath != "") {
        rootPath = tsVersionsPath; 
        fromKind = tsVersionsPath.slice (tsVersionsPath.lastIndexOf ("/"));
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsFinalPDFPath + "/") == 0 && tsFinalPDFPath != "") {
        rootPath = tsFinalPDFPath;
        fromKind = tsFinalPDFPath.slice (tsFinalPDFPath.lastIndexOf ("/"));
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsVersionsPDFPath + "/") == 0 && tsVersionsPDFPath != "") {
        rootPath = tsVersionsPDFPath;
        fromKind = tsVersionsPDFPath.slice (tsVersionsPDFPath.lastIndexOf ("/"));
    }
    else if ((folderParent.fsName.replace(/\\/g, '/') + "/").indexOf (tsPagesPath + "/") == 0 && tsPagesPath != "") {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (tsPagesPath, "");
        rootPath = rootPath.slice (1);
        if (rootPath.indexOf ("/") >= 0)
            rootPath = rootPath.slice (0, rootPath.indexOf ("/"));
        fromKind = tsPagesPath.slice (tsPagesPath.lastIndexOf ("/")) + "/" + rootPath;
        rootPath = tsPagesPath + "/" + rootPath;
    }
    if (rootPath) {
        rootPath = folderParent.fsName.replace(/\\/g, '/').replace (rootPath, "");
    }
    var targetFolder = new Folder (tsTrashPath + fromKind + rootPath);
    targetFolder.create();
    if (targetFolder.exists && !isToRoot) {
        var stringList = new Array;
        for (var d = 0; d < selectedFiles.length; d++) {
//                if (selectedFiles[d] instanceof Folder)
//                    continue;
            var string = File.decode (selectedFiles[d].name).slice (0, (File.decode (selectedFiles[d].name).lastIndexOf (".") != -1)? File.decode (selectedFiles[d].name).lastIndexOf (".") : File.decode (selectedFiles[d].name).length);
            if (string.slice (0, 3) == "ver")
                string = string.slice (6);
            var isRepeated = false;
            for (var k = 0; k < stringList.length; k++) {
                if (stringList[k] == string) {
                    isRepeated = true;
                    break;
                }
            }
            if (!isRepeated)
                stringList.push (string);
        }
        if (stringList.length > 0) {
            tsToBeSelectedList = stringList;
            tsLoadStage = 1;
        }
        app.document.thumbnail = new Thumbnail (targetFolder);
    }
    else {
        if (!isToRoot) {
            var toParent = targetFolder.parent;
            while (!toParent.exists) {
                toParent = toParent.parent;
            }
            app.document.thumbnail = new Thumbnail (toParent);
        }
        else {
            app.document.thumbnail = new Thumbnail (new Folder (tsTrashPath));
        }
    }
}

function buildNavbar (doc) 
{
    /**///$.writeln ($.line);
    var topbar = doc.navbars.filesystem.top;
    var bottombar = doc.navbars.filesystem.bottom;
    // display it
    topbar.visible = true;
    bottombar.visible = true;
    var totalWidth = topbar.bounds[2]-topbar.bounds[0];
    // set the height
    topbar.height = 60;
    bottombar.height = 4;
    // add a ScriptUI display frame
    //topbar.iconLogo = topbar.add ("image", [5, 6, 106, 23], undefined); 
    var buttonWidth = totalWidth / 6;

    topbar.goToTree = topbar.add( "statictext", [0, 0, buttonWidth, 20], "Workshop");
    topbar.goToTree.justify = "center";
    topbar.goToPages = topbar.add( "statictext", [buttonWidth, 0, buttonWidth * 2, 20], "Pages");
    topbar.goToPages.justify = "center";
    topbar.goToVersions = topbar.add( "statictext", [buttonWidth * 2, 0, buttonWidth * 3, 20], "Versions");
    topbar.goToVersions.justify = "center";
    topbar.goToFinalPDF = topbar.add( "statictext", [buttonWidth * 3, 0, buttonWidth * 4, 20], "Final PDF");
    topbar.goToFinalPDF.justify = "center";
    topbar.goToVersionsPDF = topbar.add( "statictext", [buttonWidth * 4, 0, buttonWidth * 5, 20], "Versions PDFs");
    topbar.goToVersionsPDF.justify = "center";
    topbar.goToTrash = topbar.add( "statictext", [buttonWidth * 5, 5, buttonWidth * 6, 20], "Trash");
    topbar.goToTrash.justify = "center";

    topbar.locationSlider = topbar.add( "slider", [0, 20, totalWidth, 30], undefined);
    topbar.locationSlider.minvalue = 0; 
    topbar.locationSlider.maxvalue = 6; 
    topbar.locationSlider.value = 0;

    topbar.locationSlider.onChange = function () {
        if (topbar.locationSlider.value < 1) {
            topbar.locationSlider.value = 0.5;
            tsGoToTree ();
        }
        else if (topbar.locationSlider.value < 2) {
            topbar.locationSlider.value = 1.5;
            tsGoToPages ();
        }
        else if (topbar.locationSlider.value < 3) {
            topbar.locationSlider.value = 2.5;
            tsGoToVersions ();
        }
        else if (topbar.locationSlider.value < 4) {
            topbar.locationSlider.value = 3.5;
            tsGoToFinalPDF ();
        }
        else if (topbar.locationSlider.value < 5) {
            topbar.locationSlider.value = 4.5;
            tsGoToVersionsPDF ();
        }
        else if (topbar.locationSlider.value <= 6) {
            topbar.locationSlider.value = 5.5;
            tsGoToTrash ();
        }
    }
    
    topbar.goToTree.onClick = function topbarGoToTree () {
        tsGoToTree ();
    }
    topbar.goToVersions.onClick = function() {
        tsGoToVersions ();
    }
    topbar.goToFinalPDF.onClick = function() {
        tsGoToFinalPDF ();
    }
    topbar.goToPages.onClick = function() {
        tsGoToPages ();
    }
    topbar.goToVersionsPDF.onClick = function() {
        tsGoToVersionsPDF ();
    }
    topbar.goToTrash.onClick = function() {
        tsGoToTrash ();
    }

    topbar.waitOK = topbar.add( "statictext", [12, 32, 120, 55], "Wait...");
    topbar.updatingLinks = topbar.add( "statictext", [130, 32, 270, 55], undefined);
    topbar.Downloading = topbar.add( "statictext", [280, 32, 400, 55], undefined);
    topbar.updatingFolders = topbar.add( "statictext", [410, 32, 550, 55], undefined);
    topbar.newIDAlert = topbar.add( "statictext", [560, 32, 660, 55], undefined);
    topbar.newFileName = topbar.add( "statictext", [670, 32, totalWidth - 30, 55], undefined);
    topbar.mainLoopRun = topbar.add( "statictext", [totalWidth - 20, 32, totalWidth, 55], undefined);
    
    bottombar.lidBar = bottombar.add( "statictext", [0, 0, totalWidth, 4], "");
    topbar.onResize = function()
    {
        /**///$.writeln ($.line);
        var totalWidth = topbar.bounds[2]-topbar.bounds[0];
        var buttonWidth = totalWidth / 6;
        topbar.goToTree.bounds = [0, 0, buttonWidth, 20];
        topbar.goToPages.bounds = [buttonWidth, 0, buttonWidth * 2, 20];
        topbar.goToVersions.bounds = [buttonWidth * 2, 0, buttonWidth * 3, 20];
        topbar.goToFinalPDF.bounds = [buttonWidth * 3, 0, buttonWidth * 4, 20];
        topbar.goToVersionsPDF.bounds = [buttonWidth * 4, 0, buttonWidth * 5, 20];
        topbar.goToTrash.bounds = [buttonWidth * 5, 0, totalWidth, 20];
        topbar.locationSlider.bounds = [0, 20, totalWidth, 30];
        topbar.newFileName.bounds = [670, 32, totalWidth - 30, 55];
        topbar.mainLoopRun.bounds = [totalWidth - 20, 32, totalWidth, 55];
    }
    bottombar.onResize = function() {
        bottombar.lidBar.bounds = [0, 0, bottombar.bounds[2]-bottombar.bounds[0], 4];
    }
}

main ();