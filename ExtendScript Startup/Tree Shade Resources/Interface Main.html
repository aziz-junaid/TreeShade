const http = require('http');
const https = require('https');
const fs = require('fs');
const path = require('path');
const nodemailer = require('nodemailer');
const QRCode = require('qrcode');
const formidable = require('formidable');
const OpenAI = require("openai");
const { Console } = require('console');
const puppeteer = require('puppeteer');
const isOutputToWorkshop = false;
const thumbPortion1 = '.TREESHADE';
const thumbPortion2 = '.THUMB';
const lsSnippetDynamicTag = "::";
const isWithoutThumb = false;
const isToShowOnlyLastVersion = false;
const isInitializeWhatsapp = false;
const tsVersionNumber = "9.3.6";
const tsRoot = __dirname;
let faviconData = null;
let cacheRemovingDelay = 5000;
let idGettingtolerance = 10000;
let filesCache = [];
let shadesCache = [];
let previousCache = [];
let pathTimeCache = [];
let pathValueCache = [];
let docsPlacesCache = [];
let jpgCache = [];
let webpCache = [];
let svgCache = [];
let pngCache = [];
let gifCache = [];
let cssCache = [];
let jsCache = [];
let downloadCache = [];
let pdfCache = [];
let fontCache = [];
let vcardCache = [];
let HTMLPage = '';
let locationReplaceHTML = "<!DOCTYPE html>";
locationReplaceHTML += "<html>";
locationReplaceHTML += "<body onload=\"location.replace ('***')\">";
locationReplaceHTML += "</body>";
locationReplaceHTML += "</html>";

let browserWhatsapp, pageWhatsapp;
let whatsappQueue = [];
let sendingWhatsapp = false;

async function initializeWhatsapp() {
    browserWhatsapp = await puppeteer.launch({ headless: false });
    pageWhatsapp = await browserWhatsapp.newPage();
    await pageWhatsapp.goto('https://web.whatsapp.com');
    console.log('Please scan the QR code to log in:');
    await pageWhatsapp.waitForSelector('canvas', { timeout: 0 });
    console.log('WhatsApp Web is ready.');
}

async function sendMessageWhatsapp(number, message) {
    if (isInitializeWhatsapp) {
        number = preprocessNumber(number);
        if (!validateNumber(number)) {
            console.error('Invalid number format:', number);
            return;
        }
        whatsappQueue.push({ number, message });
        processQueueWhatsapp();
    }
}

function preprocessNumber(number) {
    let cleanNumber = number.replace(/[\s-]/g, '');
    if (cleanNumber.startsWith('+')) {
        return cleanNumber;
    } else if (cleanNumber.length === 9) {
        return '+966' + cleanNumber;
    } else if (cleanNumber.length === 10 && cleanNumber.startsWith('0')) {
        return '+966' + cleanNumber.substring(1);
    }
    return cleanNumber;
}

function validateNumber(number) {
    let cleanNumber = number.replace(/[\s-]/g, '');
    if (cleanNumber.startsWith('+')) {
        cleanNumber = cleanNumber.substring(1);
    }
    return /^\d{9,}$/.test(cleanNumber);
}

async function processQueueWhatsapp() {
    if (sendingWhatsapp || whatsappQueue.length === 0) {
        return;
    }
    sendingWhatsapp = true;
    const { number, message } = whatsappQueue.shift();

    const newChatSelector = 'button[title="New chat"][aria-label="New chat"]';
    const searchNumberSelector = '[aria-label="Search name or number"][role="textbox"]';
    const typeMessageSelector = '[aria-label="Type a message"]';

    try {
        await pageWhatsapp.click(newChatSelector);
        await pageWhatsapp.waitForSelector(searchNumberSelector);
        const searchInput = await pageWhatsapp.$(searchNumberSelector);
        await searchInput.type(number);

        // Wait for the target in browser context
        const target = await pageWhatsapp.evaluateHandle(() => {
            function waitForSibling() {
                return new Promise((resolve) => {
                    const interval = setInterval(() => {
                        const notInContacts = document.querySelector('.x9f619.x4f6e3x.x1jchvi3');
                        const listItem = document.querySelector('.x10l6tqk.xh8yej3.x1g42fcv[role="listitem"]');
                        const next = notInContacts?.nextElementSibling || listItem?.nextElementSibling;
                        if (next) {
                            clearInterval(interval);
                            resolve(next);
                        }
                    }, 100);
                });
            }
            return waitForSibling();
        });

        await target.click();

        await pageWhatsapp.waitForSelector(typeMessageSelector);
        await pageWhatsapp.type(typeMessageSelector, message);
        await pageWhatsapp.keyboard.press('Enter');
        console.log(`Message sent to ${number}`);
    } catch (error) {
        console.error(`Failed to send message to ${number}: ${error}`);
    } finally {
        sendingWhatsapp = false;
        processQueueWhatsapp();
    }
}





if (isInitializeWhatsapp) {
    process.on('SIGINT', closeWhatsapp);
    process.on('SIGTERM', closeWhatsapp);
    initializeWhatsapp().catch(console.error);
}

async function closeWhatsapp() {
    console.log('Closing WhatsApp browser...');
    await browserWhatsapp.close();
    process.exit();
}
let basicMainOption = '<!-- basic main option -->' +
                        '<div id="main_trsd_main" class="w3-col w3-animate-top mainCon">' +
                            '<div id="mi1_trsd_main" class="mainItem1" style="display: none">' +
                            '</div>' +
                            '<div id="mi2_trsd_main" class="mainItem2" style="display: none">' +
                            '</div>' +
                            '<div id="mi3_trsd_main" class="mainItem3" style="display: none">' +
                            '</div>' +
                            '<div id="mi4_trsd_main" class="mainItem4" style="display: none">' +
                                '<div class="optionsCon">' +
                                    '<div class="optionCon selectedOptionCon" onclick="optionClicked(this, true)" data-paired="" id="op_trsd_main" data-flags="<TS_FLAGS>">' +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                            '<div id="mi5_trsd_main" class="mainItem5">' +
                                '<div class="optionPocket" id="pocket_trsd_main">' +
                                '</div>' +
                            '</div>' +
                        '</div>';



function solveAbbreviation (text) {
    let dotsMatch = text.match (/^\.+\//);
    if (dotsMatch) {
        dotsMatch = dotsMatch[0].slice (0, -1);
        text = text.replace (dotsMatch, "<PP" + dotsMatch + ">");
    }
    let doubleSlashesMatch = text.match (/^\/\//);
    if (doubleSlashesMatch) {
        text = text.replace (doubleSlashesMatch[0], "<Root_Path>/");
    }
    text = text.replace(/<Root_Path>/gi,               "<RP>");
    text = text.replace(/<Parent_Relative([^<>]+>)/gi, "<PR$1");
    text = text.replace(/<Parent_Path([^<>]+>)/gi,     "<PP$1");
    text = text.replace(/<Parent_Folder([^<>]+>)/gi,   "<PF$1");
    text = text.replace(/<File_Complete>/gi,           "<FC>");
    text = text.replace(/<File_Name>/gi,               "<FN>");
    text = text.replace(/<File_Display>/gi,            "<FD>");
    text = text.replace(/<File_Level>/gi,              "<FL>");
    text = text.replace(/<File_Identifier>/gi,         "<FI>");
    text = text.replace(/<File_Hash>/gi,               "<FH>");
    text = text.replace(/<First_Folder>/gi,            "<FF>");
    text = text.replace(/<Last_Folder>/gi,             "<LF>");
    text = text.replace(/<New_Folder>/gi,              "<NF>");
    text = text.replace(/<Day_Seconds>/gi,             "<DS>");
    text = text.replace(/<Day_Minutes>/gi,             "<DM>");
    text = text.replace(/<Day_Hours>/gi,               "<DH>");
    text = text.replace(/<Weekday_Order>/gi,           "<WO>");
    text = text.replace(/<Weekday_Name>/gi,            "<WN>");
    text = text.replace(/<Weekday_Abbreviation>/gi,    "<WA>");
    text = text.replace(/<Month_Date>/gi,              "<MD>");
    text = text.replace(/<Month_Order>/gi,             "<MO>");
    text = text.replace(/<Month_Name>/gi,              "<MN>");
    text = text.replace(/<Month_Abbreviation>/gi,      "<MA>");
    text = text.replace(/<Year_Full>/gi,               "<YF>");
    text = text.replace(/<Year_Abbreviation>/gi,       "<YA>");
    text = text.replace(/<Time_Decimal>/gi,            "<TD>");
    text = text.replace(/<Time_Hexadecimal>/gi,        "<TH>");
    text = text.replace(/<Time_Minimum>/gi,           "<TM>");
    text = text.replace(/<Random_([^<>]+>)/gi,         "<R_$1");
    text = text.replace(/<R>/gi,                    "<R_A1_8>");
    text = text.replace(/<Fill_([^<>]+>)/gi,         "<F_$1");
    text = text.replace(/Content_([^<>]+>)/gi,         "<C_$1");
    text = text.replace(/<Replace_This([^<>]+>)/gi,   "<RT$1");
    return text;
}

function solvePathCode (pathData, targetFork, infoObj) {
    // //
    // ./
    //RP <Root_Path>
    //PR <Parent_Relative.>
    //PP <Parent_Path.>
    //PF <Parent_Folder.>
    //FC <File_Complete>
    //FN <File_Name>
    //FD <File_Display>
    //FL <File_Level>
    //FI <File_Identifier>
    //FH <File_Hash>
    //FF <First_Folder>
    //LF <Last_Folder>
    //NF <New_Folder>
    //DS <Day_Seconds>
    //DM <Day_Minutes>
    //DH <Day_Hours>
    //WO <Weekday_Order>
    //WN <Weekday_Name>
    //WA <Weekday_Abbreviation>
    //MD <Month_Date>
    //MO <Month_Order>
    //MN <Month_Name>
    //MA <Month_Abbreviation>
    //YF <Year_Full>
    //YA <Year_Abbreviation>
    //TD <Time_Decimal>
    //TH <Time_Hexadecimal>
    //TM <Time_Minimum>
    //R <Random_Style_Long>
    //a small litters, A capital litters, h small hexadecimal, H large hexadecimal, 1 numbers
    //F <Fill_Long>
    //C <Content_Pure>
    //RT <Replace_This/From/To>
    //used properties: portion, isPathSolved, sourcePath, root
    let isPhraseOrEmail = (pathData.snippetType == "Phrase" || pathData.snippetType == "Eval" || pathData.isEmail || pathData.isWhatsapp);
    if (targetFork.portion.length > 0 && targetFork.portion == "/" && !isPhraseOrEmail) {
        targetFork.portion = targetFork.portion.slice (1);
    }
    if (targetFork.portion == "") {
        if (isPhraseOrEmail || pathData.snippetType == "URL" || pathData.snippetType == "ID") {
            if (targetFork.root == null) {
                targetFork.root = "";
            }
            targetFork.filesFound = [];
            targetFork.filesFound.push ({name: "", result: ""});
            if (isPhraseOrEmail) {
                targetFork.filesFound[0].result = targetFork.root;
                if (pathData.snippetType == "Eval") {
                    targetFork.filesFound[0].result = String(eval (targetFork.filesFound[0].result));
                }
            }
            else if (pathData.snippetType == "URL") {
                targetFork.filesFound[0].result = getImageFileURL (pathData.hostName, targetFork.root) + "/";
            }
            else if (pathData.snippetType == "ID") {
                targetFork.filesFound[0].result = targetFork.root.replace(/ /g, '_space_').replace(/\./g, '_dot_');
            }
        }
        targetFork.isPathSolved = true;
        return true;
    }
    let dealPart = targetFork.portion;
    let readDirType = "";
    let pfIndex = 0;
    if (isPhraseOrEmail) {
        dealPart = targetFork.portion;
        targetFork.portion = "";
        targetFork.root = null;
    }
    else if (targetFork.portion.indexOf ("/") != -1) {
        dealPart = targetFork.portion.slice (0, targetFork.portion.indexOf ("/"));
        targetFork.portion = targetFork.portion.slice (targetFork.portion.indexOf ("/") + 1);
    }
    else {
        targetFork.portion = "";
    }
    let matches = null;
    let theDate = new Date();
    do {
        matches = dealPart.match (/<(RP|PR|PP|PF|FC|FN|FD|FL|FI|FH|FF|LF|NF|DS|DM|DH|WO|WN|WA|MD|MO|MN|MA|YF|YA|TD|TH|TM|R_|F_|C_|RT|\?_)[^<>]*>/gi);
        if (matches) {
            matches = matches[0];
            let firstThree = matches.slice (0, 3).toUpperCase();
            let deepCount = 1;
            let targetParent = '';
            switch(firstThree) {
                case "<?_":
                    let paras = matches.slice (3, -1);
                    if (paras == "") {
                        dealPart = dealPart.replace (matches, infoObj.urlEndMark);
                    }
                    else {
                        paras = paras.split ("_");
                        let paraValue = "";
                        if (paras.length > 1) {
                            paraValue = paras[1]; //This is the default value like <?_ln_en> So if there is no parameters for the language it return en
                        }
                        let paraSplitted = infoObj.urlEndMark.split ("&");
                        for (let ps = 0; ps < paraSplitted.length; ps++) {
                            let keyValue = paraSplitted[ps].split ("=");
                            if (keyValue.length > 1 && paras[0] == keyValue[0]) {
                                keyValue.splice (0, 1);
                                paraValue = keyValue.join ("=");
                                break;
                            }
                        }
                        dealPart = dealPart.replace (matches, paraValue);
                    }
                    break;
                case "<RP": case "<rp":
                    dealPart = dealPart.replace (matches, path.join (tsRoot, ""));
                    break;
                case "<PR": case "<pr":
                    deepCount = matches.slice (3, -1);
                    if (deepCount) {
                        deepCount = deepCount.length;
                    }
                    else {
                        deepCount = 1;
                    }
                    targetParent = pathData.sourcePath;
                    for (let pml = 1; pml < deepCount; pml++) {
                        targetParent = path.dirname (targetParent);
                    }
                    targetParent = path.relative(path.join (tsRoot, "Workshop"), targetParent);
                    let matchIndex = dealPart.indexOf (matches);
                    dealPart = dealPart.replace (matches, targetParent);
                    if (dealPart.includes(path.sep)) {
                        const parts = dealPart.split(path.sep);
                        dealPart = parts.pop();
                        if (targetFork.root == null) {
                            if (matchIndex == 0) {
                                dealPart = path.join(path.join (tsRoot, "Workshop"),  ...parts, dealPart);
                            }
                            else {
                                dealPart = path.join(...parts, dealPart);
                            }
                        }
                        else {
                            targetFork.root = path.join(targetFork.root, ...parts);
                        }
                    }
                    break;
                case "<PP": case "<pp":
                    deepCount = matches.slice (3, -1);
                    if (deepCount) {
                        deepCount = deepCount.length;
                    }
                    else {
                        deepCount = 1;
                    }
                    targetParent = pathData.sourcePath;
                    for (let pml = 1; pml < deepCount; pml++) {
                        targetParent = path.dirname (targetParent);
                    }
                    dealPart = dealPart.replace (matches, targetParent);
                    break;
                case "<PF": case "<pf":
                    deepCount = matches.slice (3, -1);
                    if (deepCount) {
                        if (deepCount.indexOf ("+") != -1) {
                            deepCount = deepCount.replace ("+", "");
                            pfIndex = 1;
                        }
                        else if (deepCount.indexOf ("-") != -1) {
                            deepCount = deepCount.replace ("-", "");
                            pfIndex = -1;
                        }
                        deepCount = deepCount.length;
                    }
                    else {
                        deepCount = 1;
                    }
                    targetParent = pathData.sourcePath;
                    let targetParentFolder = path.basename (targetParent);
                    for (let pml = 1; pml < deepCount; pml++) {
                        targetParent = path.dirname (targetParent);
                        targetParentFolder = path.basename (targetParent);
                    }
                    readDirType = "PF";
                    dealPart = dealPart.replace (matches, targetParentFolder);
                    break;
                case "<FC": case "<fc":
                    let fileName = pathData.sourceName;
                    if (fileName.indexOf (".") != -1) {
                        fileName = fileName.slice (0, fileName.lastIndexOf ("."));
                    }
                    dealPart = dealPart.replace (matches, fileName);
                    break;
                case "<FN": case "<fn":
                    let filePureName = pathData.sourceName;
                    filePureName = getPureName (filePureName, false);
                    dealPart = dealPart.replace (matches, filePureName);
                    break;
                case "<FD": case "<fd":
                    let fileDisplayName = pathData.sourceName;
                    fileDisplayName = getPureDisplayName (fileDisplayName);
                    dealPart = dealPart.replace (matches, fileDisplayName);
                    break;
                case "<FL": case "<fl":
                    let fileLevel = path.relative(infoObj.postObj.mainPath, pathData.sourcePath);
                    if (fileLevel === "") {
                        fileLevel = 0;
                    }
                    else {
                        fileLevel = fileLevel.split (/[/\\]/).length;
                    }
                    dealPart = dealPart.replace (matches, String (fileLevel));
                    break;
                case "<FI": case "<fi":
                    let identifierBranch = pathData.sourcePath;
                    identifierBranch = path.relative(path.join (tsRoot, "Workshop"), identifierBranch);
                    identifierBranch = identifierBranch.split (path.sep).join ("/");
                    let identifierName = pathData.sourceName;
                    identifierName = getPureName (identifierName, false);
                    dealPart = dealPart.replace (matches, "/" + identifierBranch + "/" + identifierName);
                    break;
                case "<FH": case "<fh":
                    let hashBranch = pathData.sourcePath;
                    hashBranch = path.relative(path.join (tsRoot, "Workshop"), hashBranch);
                    hashBranch = hashBranch.split (path.sep).join ("/");
                    let hashName = pathData.sourceName;
                    hashName = getPureName (hashName, false);
                    dealPart = dealPart.replace (matches, generateNumericHash("/" + hashBranch + "/" + hashName));
                    break;
                case "<FF": case "<ff":
                    readDirType = "FF";
                    dealPart = dealPart.replace (matches, "");
                    break;
                case "<LF": case "<lf":
                    readDirType = "LF";
                    dealPart = dealPart.replace (matches, "");
                    break;
                case "<NF": case "<nf":
                    readDirType = "NF";
                    dealPart = dealPart.replace (matches, "");
                    break;
                case "<DS": case "<ds":
                    let daySeconds = tsFillZeros (theDate.getSeconds(), 2);
                    dealPart = dealPart.replace (matches, daySeconds);
                    break;
                case "<DM": case "<dm":
                    let dayMinutes = tsFillZeros (theDate.getMinutes(), 2);
                    dealPart = dealPart.replace (matches, dayMinutes);
                    break;
                case "<DH": case "<dh":
                    let dayHours = tsFillZeros (theDate.getHours(), 2);
                    dealPart = dealPart.replace (matches, dayHours);
                    break;
                case "<WO": case "<wo":
                    let weekdayOrder = (theDate.getDay() + 1).toString ();
                    dealPart = dealPart.replace (matches, weekdayOrder);
                    break;
                case "<WN": case "<wn":
                    let weekdayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                    let weekdayName = weekdayNames[theDate.getDay()];
                    dealPart = dealPart.replace (matches, weekdayName);
                    break;
                case "<WA": case "<wa":
                    let weekdayAbbs = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                    let weekdayAbb = weekdayAbbs[theDate.getDay()];
                    dealPart = dealPart.replace (matches, weekdayAbb);
                    break;
                case "<MD": case "<md":
                    let monthDate = tsFillZeros (theDate.getDate(), 2);
                    dealPart = dealPart.replace (matches, monthDate);
                    break;
                case "<MO": case "<mo":
                    let monthOrder = tsFillZeros (theDate.getMonth() + 1, 2);
                    dealPart = dealPart.replace (matches, monthOrder);
                    break;
                case "<MN": case "<mn":
                    let monthsNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                    let monthName = monthsNames[theDate.getMonth()];
                    dealPart = dealPart.replace (matches, monthName);
                    break;
                case "<MA": case "<ma":
                    let monthsNamesAbb = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Oct", "Dec"];
                    let monthAbb = monthsNamesAbb[theDate.getMonth()];
                    dealPart = dealPart.replace (matches, monthAbb);
                    break;
                case "<YF": case "<yf":
                    let yearFull = theDate.getFullYear().toString ();
                    dealPart = dealPart.replace (matches, yearFull);
                    break;
                case "<YA": case "<ya":
                    let yearAbb = theDate.getFullYear().toString ().slice (2);
                    dealPart = dealPart.replace (matches, yearAbb);
                    break;
                case "<TD": case "<td":
                    let timeNumbers = theDate.getTime ().toString ();
                    dealPart = dealPart.replace (matches, timeNumbers);
                    break;
                case "<TH": case "<th":
                    let timeHexa = theDate.getTime ().toString (16);
                    dealPart = dealPart.replace (matches, timeHexa);
                    break;
                case "<TM": case "<tm":
                    let timeMinimum = theDate.getTime ().toString (36);
                    dealPart = dealPart.replace (matches, timeMinimum);
                    break;
                case "<R_": case "<r_":
                    readDirType = "NF";
                    let randomPhrases = matches.slice (3, -1).split ("_");
                    let capital = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    let small = "abcdefghijklmnopqrstuvwxyz";
                    let numbers = "0123456789";
                    let capitalHexa = "0123456789ABCDEF";
                    let smallHexa = "0123456789abcdef";
                    let combination = "";
                    let theLong = 4;
                    if (randomPhrases.length > 0) {
                        if (randomPhrases[0].indexOf ('A') != -1) {
                            combination += capital;
                        }
                        if (randomPhrases[0].indexOf ('a') != -1) {
                            combination += small;
                        }
                        if (randomPhrases[0].indexOf ('1') != -1) {
                            combination += numbers;
                        }
                        if (randomPhrases[0].indexOf ('H') != -1) {
                            combination += capitalHexa;
                        }
                        if (randomPhrases[0].indexOf ('h') != -1) {
                            combination += smallHexa;
                        }
                    }
                    if (randomPhrases.length > 1) {
                        let longGet = parseInt (randomPhrases[1], 10);
                        if (longGet != null) {
                            theLong = longGet;
                        }
                    }
                    let randomCode = makeRandom (theLong, combination);
                    dealPart = dealPart.replace (matches, randomCode);
                    break;
                case "<F_": case "<f_":
                    dealPart = dealPart.replace (matches, "");
                    let digitsMatch = dealPart.match (/\d+/);
                    if (digitsMatch) {
                        digitsMatch = digitsMatch[0];
                        let fillPhrases = matches.slice (3, -1).split ("_");
                        fillPhrases = parseInt (fillPhrases[0], 10);
                        if (fillPhrases) {
                            let filledDigits = digitsMatch;
                            while (filledDigits.length < fillPhrases)
                                filledDigits = "0" + filledDigits;
                            dealPart = dealPart.replace (digitsMatch, filledDigits);
                        }
                    }
                    break;
                case "<C_": case "<c_":
                    let targetPureName = matches.slice (3, -1);
                    let targetContent = "";
                    for (let ffd = 0; ffd < infoObj.postObj.formFields.length; ffd++) {
                        if (!infoObj.postObj.formFields[ffd].isToDelete && infoObj.postObj.formFields[ffd].fieldContent.indexOf ("op_") != 0) {
                            let testedPureName = getPureName (infoObj.postObj.formFields[ffd].fileName, false);
                            if (testedPureName == targetPureName) {
                                targetContent = infoObj.postObj.formFields[ffd].fieldContent;
                                break;
                            }
                        }
                    }
                    dealPart = dealPart.replace (matches, targetContent);
                    break;
                case "<RT": case "<rt":
                    dealPart = dealPart.replace (matches, "");
                    if (matches.search (/\//) != -1) {
                        let replaceChain = matches.slice (matches.search (/\//) + 1, -1).split (/(?<!\\)\//);
                        for (let rc = 0; rc < replaceChain.length - 1; rc+=2) {
                            dealPart = dealPart.replace(new RegExp(replaceChain[rc], 'g'), replaceChain[rc+1]);
                        }
                    }
                    break;
                default:
                    dealPart = dealPart.replace (matches, "");
            }
        }
    } while (matches);
    if (targetFork.root == null) {
        targetFork.root = dealPart;
        solvePathCode (pathData, targetFork, infoObj);
    }
    else {
        if (dealPart == '') {
            dealPart = '.+';
        }
        let readFullPath = path.join (targetFork.root , 'ts_sort.txt');
        let extendObj = {dealPart: dealPart, readDirType: readDirType, pfIndex: pfIndex};
        function sortFolders (err, optionsTSSortContent) {
            let optionsSortList = '';
            if(err) {
                optionsSortList = [];
            }
            else {
                if (optionsTSSortContent.indexOf ('\r\n') != -1) {
                    optionsSortList = optionsTSSortContent.split ('\r\n');
                }
                else {
                    optionsSortList = optionsTSSortContent.split ('\n');
                }
            }
            if (err == null) {
                addFileContent (readFullPath, filesCache, optionsTSSortContent);
            }
            let es = {extendObj: extendObj, optionsSortList: optionsSortList};
            fs.readdir(path.join (targetFork.root), { withFileTypes: true }, function (err, dirents) {
                //handling error
                if (err) {
                    console.log('Unable to scan directory1: ' + err);
                }
                else {
                    if (targetFork.portion == "" && pathData.snippetType != null) {
                        targetFork.filesFound = [];
                        let filesNames = dirents
                        .filter(dirent => dirent.isFile())
                        .map(dirent => dirent.name);
                        for (let fln = filesNames.length - 1; fln >= 0; fln--) {
                            if (filesNames[fln] == 'ts_sort.txt' || 
                                filesNames[fln][0] == '.' ||
                                filesNames[fln].slice (-5) == ".idlk" || 
                                filesNames[fln].slice (-4) == ".tmp" || 
                                filesNames[fln].slice (-4) == ".lst" || 
                                filesNames[fln].slice(0, 2) == "~$") {
                                filesNames.splice (fln, 1);
                            }
                        }
                        let sortIndex = 0;
                        for (let sl = 0; sl < es.optionsSortList.length; sl++) {
                            let pureFileName = es.optionsSortList[sl];
                            for (let fln = sortIndex; fln < filesNames.length; fln++) {
                                if (getPureName (filesNames[fln], false) == pureFileName) {
                                    if (fln != sortIndex) {
                                        let swapCell = filesNames[fln];
                                        filesNames[fln] = filesNames[sortIndex];
                                        filesNames[sortIndex] = swapCell;
                                    }
                                    sortIndex++;
                                    break;
                                }
                            }
                        }
                        for (let fln = 0; fln < filesNames.length; fln++) {
                            let m = filesNames[fln].match (new RegExp(es.extendObj.dealPart, ''));
                            if (m && m[0] == filesNames[fln]) {
                                let fileNameAndResult = {name: filesNames[fln], result: null};
                                targetFork.filesFound.push (fileNameAndResult);
                                if (pathData.snippetType == "Place") {

                                }
                                else if (pathData.snippetType == "Output") {
                                    fileNameAndResult.result = path.join(targetFork.root, filesNames[fln]);
                                }
                                else if (pathData.snippetType == "Name") {
                                    let nameWithoutExt = fileNameAndResult.name;
                                    if (nameWithoutExt.indexOf (".") != -1) {
                                        nameWithoutExt = nameWithoutExt.slice (0, nameWithoutExt.lastIndexOf ("."));
                                    }
                                    fileNameAndResult.result = nameWithoutExt;
                                }
                                else if (pathData.snippetType == "Pure") {
                                    fileNameAndResult.result = getPureName (fileNameAndResult.name, false);
                                }
                                else if (pathData.snippetType == "Display") {
                                    fileNameAndResult.result = getPureDisplayName (fileNameAndResult.name);
                                }
                                else if (pathData.snippetType == "Extension") {
                                    let theExt = "";
                                    if (fileNameAndResult.name.indexOf (".") != -1) {
                                        theExt = fileNameAndResult.name.slice (fileNameAndResult.name.lastIndexOf (".") + 1);
                                    }
                                    fileNameAndResult.result = theExt;
                                }
                                else if (pathData.snippetType == "URL") {
                                    fileNameAndResult.result = getImageFileURL (pathData.hostName, path.join(targetFork.root, filesNames[fln]));
                                    let deepCountDown = pathData.descendingDeep;
                                    while (fileNameAndResult.result.indexOf ("/") != -1 && deepCountDown--) {
                                        fileNameAndResult.result = fileNameAndResult.result.slice (0, fileNameAndResult.result.lastIndexOf ("/"));
                                    }
                                    if (pathData.isURLWithoutWorkshop) {
                                        fileNameAndResult.result = fileNameAndResult.result.replace ("/Workshop/", "/");
                                    }
                                }
                                else if (pathData.snippetType == "Path") {
                                    fileNameAndResult.result = path.relative(path.join (tsRoot, "Workshop"), path.join(targetFork.root, fileNameAndResult.name));
                                    fileNameAndResult.result = fileNameAndResult.result.split (path.sep).join ("/");
                                    let deepCountDown = pathData.descendingDeep;
                                    while (fileNameAndResult.result.indexOf ("/") != -1 && deepCountDown--) {
                                        fileNameAndResult.result = fileNameAndResult.result.slice (0, fileNameAndResult.result.lastIndexOf ("/"));
                                    }
                                }
                                else if (pathData.snippetType == "ID") {
                                    fileNameAndResult.result = path.relative(path.join (tsRoot, "Workshop"), path.join(targetFork.root, filesNames[fln]));
                                    fileNameAndResult.result = fileNameAndResult.result.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_");
                                }
                            }
                        }
                        if (targetFork.filesFound.length === 0 && pathData.snippetType === "Output") {
                            targetFork.filesFound.push({
                                name: regexToNormalText(es.extendObj.dealPart),
                                result: path.join(targetFork.root, regexToNormalText(es.extendObj.dealPart))
                            });
                        }
                        targetFork.isPathSolved = true;
                        return true;
                    }
                    else {
                        let foldersNames = dirents
                        .filter(dirent => dirent.isDirectory())
                        .map(dirent => dirent.name);
                        if (es.extendObj.readDirType != "") {
                            for (let fdn = foldersNames.length - 1; fdn >= 0; fdn--) {
                                if (foldersNames[fdn].search(/ver\d\d /i) == 0 || foldersNames[fdn].indexOf ("untitled folder") == 0 || foldersNames[fdn][0] == '.') {
                                    foldersNames.splice (fdn, 1);
                                }
                            }
                        }
                        let sortIndex = 0;
                        for (let sl = 0; sl < es.optionsSortList.length; sl++) {
                            let pureFileName = es.optionsSortList[sl];
                            for (let fdn = sortIndex; fdn < foldersNames.length; fdn++) {
                                if (foldersNames[fdn] == pureFileName) {
                                    if (fdn != sortIndex) {
                                        let swapCell = foldersNames[fdn];
                                        foldersNames[fdn] = foldersNames[sortIndex];
                                        foldersNames[sortIndex] = swapCell;
                                    }
                                    sortIndex++;
                                    break;
                                }
                            }
                        }
                        let matchFolders = [];
                        let isNeedToCreate = false;
                        for (let fdn = 0; fdn < foldersNames.length; fdn++) {
                            let m = foldersNames[fdn].match (new RegExp(es.extendObj.dealPart, ''));
                            if (m && m[0] == foldersNames[fdn]) {
                                matchFolders.push (fdn);
                            }
                        }
                        if (matchFolders.length > 0) {
                            if (pathData.snippetType != null && pathData.snippetType != "Output") {
                            }
                            else {
                                if (pfIndex == -1) {
                                    if (matchFolders[0] > 0) {
                                        matchFolders = [matchFolders[0] - 1];
                                    }
                                    else {
                                        matchFolders = [matchFolders[0]];
                                    }
                                }
                                else if (pfIndex == 1) {
                                    if (matchFolders[matchFolders.length - 1] < foldersNames.length - 1) {
                                        matchFolders = [matchFolders[matchFolders.length - 1] + 1];
                                    }
                                    else {
                                        matchFolders = [matchFolders[matchFolders.length - 1]];
                                    }
                                }
                                else if (es.extendObj.readDirType == "LF" || es.extendObj.readDirType == "NF") {
                                    matchFolders = [matchFolders[matchFolders.length - 1]];
                                }
                                else {
                                    matchFolders = [matchFolders[0]];
                                }
                            }
                        }
                        
                        if (matchFolders.length == 0) {
                            if (pathData.snippetType != null && pathData.snippetType != "Output") {
                                targetFork.filesFound = [{name: es.extendObj.dealPart, result: ""}];
                                targetFork.isPathSolved = true;
                                return false;
                            }
                            if (es.extendObj.dealPart == '.+') {
                                matchFolders = "0001";
                            }
                            else {
                                matchFolders = es.extendObj.dealPart;
                            }
                            isNeedToCreate = true;
                        }
                        else if (pathData.snippetType != null && pathData.snippetType != "Output") {
                            //creating new forks
                            if (matchFolders.length > 1) {
                                let forkIndex = 0;
                                for (let f = 0; f < pathData.fork.length; f++) {
                                    if (targetFork === pathData.fork[f]) {
                                        forkIndex = f;
                                        break;
                                    }
                                }
                                for (let mf = 1; mf < matchFolders.length; mf++) {
                                    let newFork = cloneObj (targetFork);
                                    newFork.root = path.join (newFork.root, foldersNames[matchFolders[mf]]);
                                    pathData.fork.splice (forkIndex + mf, 0, newFork);
                                    solvePathCode (pathData, newFork, infoObj);
                                }
                            }
                            targetFork.root = path.join (targetFork.root, foldersNames[matchFolders[0]]);
                            solvePathCode (pathData, targetFork, infoObj);
                            return true;
                        }
                        else {
                            matchFolders = foldersNames[matchFolders[0]];
                        }
                        if (es.extendObj.readDirType == "NF") {
                            if (!isNeedToCreate) {
                                let ni = tsNextIncrement (matchFolders, "2");
                                if (ni) {
                                    matchFolders = ni;
                                } 
                                isNeedToCreate = true;
                            }              
                        }
                        targetFork.root = path.join (targetFork.root, matchFolders);
                        if (isNeedToCreate) {
                            fs.mkdir(targetFork.root, { recursive: true }, (err) => {
                                if (err) {
                                    return console.error(err);
                                }
                                solvePathCode (pathData, targetFork, infoObj);
                            });
                        }
                        else {
                            solvePathCode (pathData, targetFork, infoObj);
                        }
                    }
                }
            });
        }
    
        if (readDirType == "" && targetFork.portion != "") { //pfIndex == 0 && 
            sortFolders ("No Sort", null);
        }
        else {
            let testedContent = getFileContent (readFullPath, filesCache);
            if (testedContent != null) {
                sortFolders (false, testedContent);
            }
            else {
                fs.readFile (readFullPath, 'UTF-8', sortFolders);
            }
        }
    }
}

function getFileContent (testFullPath, toScanList) {
    let result = null;
    let fcc = -1;
    for (fcc = toScanList.length - 1; fcc >= 0; fcc--) {
        if (testFullPath == toScanList[fcc].fullPath) {
            if (cacheRemovingDelay != 0 && (((new Date ().getTime ()) - toScanList[fcc].addingTime) > cacheRemovingDelay)) {
                toScanList.splice (fcc, 1);
                break;
            }
            toScanList[fcc].pickLoop++;
            result = toScanList[fcc].content;
            if (fcc < (toScanList.length - 1)) {
                if (toScanList[fcc].pickLoop > 10) {
                    toScanList[fcc].pickLoop = 0;
                    let swap = toScanList[fcc];
                    toScanList[fcc] = toScanList[fcc + 1];
                    toScanList[fcc + 1] = swap;
                }
            }
            break;
        }
    }
    return result;
}

function updateFileContent (testFullPath, toScanList, newContent) {
    let fcc = -1;
    for (fcc = toScanList.length - 1; fcc >= 0; fcc--) {
        if (testFullPath == toScanList[fcc].fullPath) {
            toScanList[fcc].content = newContent;
            return true;
        }
    }
    addFileContent (testFullPath, toScanList, newContent);
    return false;
}

function addFileContent (toAddFullPath, toAddList, fileContent) {
    toAddList.push ({fullPath: toAddFullPath, content: fileContent, pickLoop: 0, addingTime: new Date ().getTime ()});
    if (toAddList.length > 1000) {
        toAddList.splice (0, 100);
    }
}

function cloneObj (theObj) {
    if (typeof theObj === 'object') {
        if (Array.isArray (theObj)) {
            let cloned = [];
            for (let i = 0; i < theObj.length; i++) {
                cloned.push (cloneObj (theObj[i]));
            }
            return cloned;
        }
        else {
            let cloned = {};
            for (let key in theObj) {
                cloned[key] = cloneObj (theObj[key]);
            }
            return cloned;
        }
    }
    else {
        return theObj;
    }
}

function makeRandom (length, characters) {
    let result = '';
    let charactersLength = characters.length;
    for (let i = 0; i < length; i++ ) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
   return result;
}

function tsNextIncrement (oldText, Appendix) {
    if (oldText.search (/[0-9A-Z]+(?![\w])/) != -1) {
        let shiftPhrase = oldText.match (/[0-9A-Z]+(?![\w])/)[0];
        if (oldText.search (/^ID[A-Z0-9]+/) != -1) {
            shiftPhrase = "ID" + tsNextCapitalSequence (shiftPhrase.slice (2));
        }
        else {
            shiftPhrase = tsNextCapitalSequence (shiftPhrase);
        }
        oldText = oldText.replace (/[0-9A-Z]+(?![\w])/, shiftPhrase);
        return oldText;
    }
    else if (Appendix) {
        return oldText + Appendix;
    }
    return null;
}

function tsFillZeros (number, digitsCount) {
	let digits = number.toString();
	while (digits.length < digitsCount)
		digits = "0" + digits;
	return digits;
}

function solveText(sourceText) {
    let splittedText = sourceText.split(/<ts>/i);
    if (splittedText.length < 2) return [sourceText];

    for (let st = splittedText.length - 1; st >= 0; st--) {
        let portionText = splittedText[st].split(/<\/ts>/i);
        if (portionText.length > 1) {
            for (let pt = portionText.length - 1; pt > 0; pt--) {
                portionText.splice(pt, 0, "</ts>");
            }
            splittedText.splice(st, 1, ...portionText);
        }
        if (st > 0) {
            splittedText.splice(st, 0, "<ts>");
        }
    }

    let objectsArr = [];
    let level = 0;
    for (let st = 0; st < splittedText.length; st++) {
        if (splittedText[st].search(/^<ts>$/i) == 0) {
            level++;
        }
        objectsArr.push({ level, text: splittedText[st] });
        if (splittedText[st].search(/^<\/ts>$/i) == 0) {
            level--;
        }
    }

    let returnedSplittedText = [];
    let wasPreviousOuterTag = false;
    for (let ob = 0; ob < objectsArr.length; ob++) {
        if (objectsArr[ob].text.search(/^<ts>$/i) == 0 || objectsArr[ob].text.search(/^<\/ts>$/i) == 0) {
            if (objectsArr[ob].level > 1) {
                if (wasPreviousOuterTag) {
                    returnedSplittedText.push(objectsArr[ob].text);
                    wasPreviousOuterTag = false;
                } else {
                    returnedSplittedText[returnedSplittedText.length - 1] += objectsArr[ob].text;
                    wasPreviousOuterTag = false;
                }
            } else {
                returnedSplittedText.push(objectsArr[ob].text);
                wasPreviousOuterTag = true;
            }
        } else {
            if (wasPreviousOuterTag) {
                returnedSplittedText.push(objectsArr[ob].text);
            } else {
                if (returnedSplittedText.length === 0) {
                    returnedSplittedText.push(objectsArr[ob].text);
                } else {
                    returnedSplittedText[returnedSplittedText.length - 1] += objectsArr[ob].text;
                }
            }
            wasPreviousOuterTag = false;
        }
    }
    return returnedSplittedText;
}

function extractNestedTags (inputText) {
    let solvedText = solveText (inputText);
    let returnedText = "";
    let tempPlaceholder = "TS_TEMP_PLACEHOLDER";
    let extractedTagsArray = [];
    for (let st = 0; st < solvedText.length; st++) {
        if (solvedText[st].search (/^<ts>$/i) == 0) {
            if (st < (solvedText.length - 3)) {
                extractedTagsArray.push (solvedText[st] + solvedText[st+1] + solvedText[st+2]);
                returnedText += tempPlaceholder;
                st+=2;
            }
            else {
                returnedText += solvedText[st];
            }
        }
        else {
            returnedText += solvedText[st];
        }
    }
    return {returnedText, extractedTagsArray};
}

function reconstructNestedTags (extractedObject) {
    const { returnedText, extractedTagsArray } = extractedObject;
    let reconstructedText = returnedText;
    for (let i = 0; i < extractedTagsArray.length; i++) {
        reconstructedText = reconstructedText.replace("TS_TEMP_PLACEHOLDER", extractedTagsArray[i]);
    }
    return reconstructedText;
}


function tsNextCapitalSequence (c) {
    let u = c.toUpperCase();
    if (tsSame (u, 'Z')){
        let txt = '';
        let i = u.length;
        while (i--) {
            txt += '0';
        }
        return (txt+'0');
    } else {
        let p = "";
        let q = "";
        if(u.length > 1){
            p = u.substring(0, u.length - 1);
            q = String.fromCharCode(p.slice(-1).charCodeAt(0));
        }
        let l = u.slice(-1).charCodeAt(0);
        let z = tsNextLetter (l);
        if(z==='0'){
            return p.slice(0,-1) + tsNextLetter (q.slice(-1).charCodeAt(0)) + z;
        } else {
            return p + z;
        }
    }
}

function tsNextLetter (l){
    if(l<90){
        return String.fromCharCode(l + 1);
    }
    else{
        return '0';
    }
}

function tsSame (str, character){
    let i = str.length;
    while (i--) {
        if (str[i]!==character){
            return false;
        }
    }
    return true;
}

function escapeSpecialTags(input) {
    input = input.replace(/<code>(.*?)<\/code>/gs, (match, content) => {
        const escapedContent = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return `<code>${escapedContent}</code>`;
    });
    return input;
}

function createList (targetText, fileFullPath, infoObj, idsFromParents) {
    targetText = escapeSpecialTags (targetText);
    let returnedList = [];
    let solvedText = solveText (targetText);
    if (solvedText) {
        for (let st = 0; st < solvedText.length; st++) {
            let textPortion = {fileFullPath: null, isSnippet: false, text: solvedText[st], pathsMap: null, ids: idsFromParents.slice (), idGettingAttempts: 0, initTime: new Date ().getTime ()};
            let isSTTag = (solvedText[st].search (/^<ts>$/i) == 0 && st < (solvedText.length - 3));
            if (isSTTag)
                textPortion.text = solvedText[st + 1];
            let isNested = false;
            let isToGetID = (textPortion.text.search (/<id#[^<>]+>/i) != -1);
            if (textPortion.text.search (/<ts>/i) != -1) {
                if (!isToGetID) {
                    textPortion.text = "<id#TSFAKEFORNESTED>" + textPortion.text;
                    isToGetID = true;
                }
                isNested = true;
            }
            textPortion.fileFullPath = fileFullPath;
            if (!isToGetID)
                textPortion.isSnippet = true;
            if (isToGetID) {
                if (isSTTag && !isNested) {
                    textPortion.text = "<ts>" + textPortion.text + "</ts>";
                }
                textPortion.idGettingAttempts++;
            }
            else if (textPortion.text.search (/<id_[^<>]+>/i) != -1) {
                let idsNew = textPortion.text.match (/<id_[^<>]+>/ig);
                textPortion.text = textPortion.text.replace (/<id_[^<>]+>/ig, '');
                for (let inw = 0; inw < idsNew.length; inw++) {
                    let extractedId = idsNew[inw].slice (4, -1);
                    if (!extractedId.startsWith('@')) {
                        let hashBranch = path.relative(path.join (tsRoot, "Workshop"), fileFullPath);
                        let hashBranchSplitted = hashBranch.split (path.sep);
                        hashBranchSplitted[hashBranchSplitted.length - 1] = getPureName (hashBranchSplitted[hashBranchSplitted.length - 1], false);
                        extractedId = generateNumericHash("/" + hashBranchSplitted.join ("/")) + extractedId;
                    }
                    textPortion.ids.push (extractedId);
                }
            }
            let pm = {hostName: infoObj.hostName, sourcePath: path.dirname (fileFullPath), sourceName: path.basename (fileFullPath), fork: [], isDone: false, isEmail: false, snippetType: false, isQR: false, isFunction: false, isDownload: false, isFakePlace: false, descendingDeep: 0, isURLWithoutWorkshop: false, separator: ""};
            textPortion.pathsMap = pm;
            textPortion.pathsMap.fork = [{root: null, portion: null, isPathSolved: false, filesFound: null}];
            if (isToGetID) {
                textPortion.pathsMap.fork[0].root = path.dirname (fileFullPath);
                textPortion.pathsMap.fork[0].isPathSolved = true;
                textPortion.pathsMap.fork[0].filesFound = [{name: path.basename (fileFullPath), result: ""}];
            }
            else {
                textPortion.pathsMap.snippetType = "Phrase";
                let textPortionDeal = textPortion.text;
                if (textPortionDeal.search (/<Phrase>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Phrase>$/i, "");
                }
                else if (textPortionDeal.search (/<Eval>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Eval>$/i, "");
                    textPortion.pathsMap.snippetType = "Eval";
                }
                else if (textPortionDeal.search (/<Place>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Place>$/i, "");
                    textPortion.pathsMap.snippetType = "Place";
                }
                else if (textPortionDeal.search (/<Output>$/i) != -1 || textPortionDeal.search (/<QR>$/i) != -1 || textPortionDeal.search (/<Function>$/i) != -1 || textPortionDeal.search (/<Download>$/i) != -1 || textPortionDeal.search (/<Email>$/i) != -1 || textPortionDeal.search (/<Whatsapp>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Output>$/i, "");
                    textPortion.pathsMap.snippetType = "Output";
                    if (textPortionDeal.search (/<QR>$/i) != -1) {
                        textPortionDeal = textPortionDeal.replace (/<QR>$/i, "");
                        textPortion.pathsMap.isQR = true;
                    }
                    else if (textPortionDeal.search (/<Download>$/i) != -1) {
                        textPortionDeal = textPortionDeal.replace (/<Download>$/i, "");
                        textPortion.pathsMap.isDownload = true;
                    }
                    else if (textPortionDeal.search (/<Function>$/i) != -1) {
                        textPortionDeal = textPortionDeal.replace (/<Function>$/i, "");
                        textPortion.pathsMap.isFunction = true;
                    }
                    else if (textPortionDeal.search (/<Email>$/i) != -1) {
                        textPortionDeal = textPortionDeal.replace (/<Email>$/i, "");
                        textPortion.pathsMap.isEmail = true;
                    }
                    else if (textPortionDeal.search (/<Whatsapp>$/i) != -1) {
                        textPortionDeal = textPortionDeal.replace (/<Whatsapp>$/i, "");
                        textPortion.pathsMap.isWhatsapp = true;
                    }
                }
                else if (textPortionDeal.search (/<Name>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Name>$/i, "");
                    textPortion.pathsMap.snippetType = "Name";
                }
                else if (textPortionDeal.search (/<Pure>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Pure>$/i, "");
                    textPortion.pathsMap.snippetType = "Pure";
                }
                else if (textPortionDeal.search (/<Display>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Display>$/i, "");
                    textPortion.pathsMap.snippetType = "Display";
                }
                else if (textPortionDeal.search (/<Extension>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<Extension>$/i, "");
                    textPortion.pathsMap.snippetType = "Extension";
                }
                else if (textPortionDeal.search (/<url\.*>$/i) != -1) {
                    textPortion.pathsMap.snippetType = "URL";
                    let urlTag = textPortionDeal.match (/<url\.*>$/i)[0];
                    textPortionDeal = textPortionDeal.replace (/<url\.*>$/i, "");
                    if (urlTag.length > 5) {
                        textPortion.pathsMap.descendingDeep = urlTag.length - 5;
                    }
                    if (urlTag.search (/URL/) != -1) {
                        textPortion.pathsMap.isURLWithoutWorkshop = true;
                    }
                }
                else if (textPortionDeal.search (/<Path\.*>$/i) != -1) {
                    textPortion.pathsMap.snippetType = "Path";
                    let relativeTag = textPortionDeal.match (/<Path\.*>$/i)[0];
                    textPortionDeal = textPortionDeal.replace (/<Path\.*>$/i, "");
                    if (relativeTag.length > 6) {
                        textPortion.pathsMap.descendingDeep = relativeTag.length - 6;
                    }
                }
                else if (textPortionDeal.search (/<ID>$/i) != -1) {
                    textPortionDeal = textPortionDeal.replace (/<ID>$/i, "");
                    textPortion.pathsMap.snippetType = "ID";
                }
                if (textPortionDeal.search (/<Separator\/(([^<>]+)|(<[^<>]+>))+>$/i) != -1) {
                    textPortion.pathsMap.separator = textPortionDeal.match (/<Separator\/(([^<>]+)|(<[^<>]+>))+>$/i)[0];
                    textPortion.pathsMap.separator = textPortion.pathsMap.separator.slice (11, -1).replace(/\\n|\\t|\\r|\\b|\\f|\\v/g, match => {
                                                                                                                                            return {
                                                                                                                                            '\\n': '\n',
                                                                                                                                            '\\t': '\t',
                                                                                                                                            '\\r': '\r',
                                                                                                                                            '\\b': '\b',
                                                                                                                                            '\\f': '\f',
                                                                                                                                            '\\v': '\v'
                                                                                                                                            }[match];
                                                                                                    });
                    textPortionDeal = textPortionDeal.replace (/<Separator\/(([^<>]+)|(<[^<>]+>))+>$/i, "");
                }
                textPortion.pathsMap.fork[0].portion = textPortionDeal;
                textPortion.pathsMap.fork[0].portion = solveAbbreviation (textPortion.pathsMap.fork[0].portion);
                solvePathCode (textPortion.pathsMap, textPortion.pathsMap.fork[0], infoObj);
            }
            if (isSTTag)
                st += 2;
            returnedList.push (textPortion);
        }
    }
    return returnedList;
}

function downloadFile(fileUrl, fullPathWithoutExt, retries = 3, delay = 2000) {
    try {
        const parsedUrl = new URL(fileUrl);
        const protocol = parsedUrl.protocol === 'https:' ? https : http;
        const originalFileName = path.basename(parsedUrl.pathname);
        const extension = path.extname(originalFileName) || '.bin';
        const outputPath = `${fullPathWithoutExt}${extension}`;

        fs.mkdirSync(path.dirname(outputPath), { recursive: true });

        const options = {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Referer': parsedUrl.origin
            }
        };

        const file = fs.createWriteStream(outputPath);

        protocol.get(fileUrl, options, (response) => {            
            if (response.statusCode === 403 && retries > 0) {
                console.warn(`[WARN] Access denied. Retrying in ${delay / 1000} seconds...`);
                setTimeout(() => downloadFile(fileUrl, fullPathWithoutExt, retries - 1, delay), delay);
                return;
            }
            
            if (response.statusCode !== 200) {
                console.error(`[ERROR] Failed to download: ${response.statusCode}`);
                return;
            }

            response.pipe(file);

            file.on('finish', () => {
                file.close();
            });

        }).on('error', (err) => {
            fs.unlink(outputPath, () => {});
            console.error(`[ERROR] Download failed: ${err.message}`);
        });

    } catch (error) {
        console.error(`${fileUrl}: ${error.message}`);
    }
}

function getLooping (res, docsObj, infoObj) {
    if (!HTMLPage) {
        setTimeout(getLooping, 100, res, docsObj, infoObj);
        return false;
    }
    if (infoObj.postObj.htmlFileContent == null) {
        infoObj.postObj.htmlFileContent = false;
        let readFullPath = '';
        function textHandler (err, data) {
            if(err) {
                infoObj.postObj.htmlFileContent = HTMLPage;
            }
            else {
                if (err == null) {
                    addFileContent (readFullPath, filesCache, data);
                }
                let ffi = infoObj.postObj.formFields.length;
                if (data.search (/<ts>Index<Output><\/ts>/i) == -1) {
                    data = "<ts>Index<Output></ts>" + data;
                }
                infoObj.postObj.formFields.push ({subPath: '', fileName: infoObj.postObj.htmlFileName, fieldContent: data, isRequested: true, isDone: true, textSnippets: null});
                infoObj.postObj.formFields[ffi].textSnippets = {loopingCount: 0, list: [], isDeadEnd: false, isReadyToOutput: false, outputtedCount: 0};
                let fileFullPath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[ffi].subPath, infoObj.postObj.formFields[ffi].fileName);
                infoObj.postObj.formFields[ffi].textSnippets.list = createList (infoObj.postObj.formFields[ffi].fieldContent, fileFullPath, infoObj, []);
                infoObj.postObj.htmlFileContent = data;
            }
        }
        if (infoObj.postObj.htmlFileName == null) {
            infoObj.postObj.htmlFileName = "http-form.html";
            textHandler (false, HTMLPage);
        }
        else {
            readFullPath = path.join(infoObj.postObj.mainPath , infoObj.postObj.htmlFileName);
            let testedContent = getFileContent (readFullPath, filesCache);
            if (testedContent != null) {
                textHandler (false, testedContent);
            }
            else {
                fs.readFile (readFullPath, 'UTF-8', textHandler);
            }
        }
    }
    if (infoObj.postObj.htmlFileContent == null || infoObj.postObj.htmlFileContent === false) {
        setTimeout(getLooping, 100, res, docsObj, infoObj);
        return false;
    }

    if (infoObj.postObj.tsKey.isFact) {
        if (!infoObj.postObj.tsKey.isCodeRequested) {
            let readFullPath = path.join(infoObj.postObj.mainPath , infoObj.tsKeyFileName);
            function keyHandler (err, data) {
                if(err) {
                    throw err;
                }
                if (err === null) {
                    addFileContent (readFullPath, filesCache, data);
                }
                if (data.indexOf ('\r\n') != -1) {
                    infoObj.postObj.tsKey.code = data.split ('\r\n');
                }
                else {
                    infoObj.postObj.tsKey.code = data.split ('\n');
                }
                for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                    infoObj.postObj.tsKey.code[isc] = infoObj.postObj.tsKey.code[isc].split (":");
                }
            }
            let testedContent = getFileContent (readFullPath, filesCache);
            if (testedContent != null) {
                keyHandler (false, testedContent);
            }
            else {
                fs.readFile (readFullPath, 'UTF-8', keyHandler);
            }
            infoObj.postObj.tsKey.isCodeRequested = true;
            setTimeout(getLooping, 100, res, docsObj, infoObj);
            return false;
        }
        else if (infoObj.postObj.tsKey.code == null) {
            setTimeout(getLooping, 100, res, docsObj, infoObj);
            return false;
        }
    }
    if (infoObj.postObj.isPost && infoObj.postObj.tsKey.isFact && !infoObj.postObj.tsKey.isDone) {
        if (infoObj.postObj.tsKey.code != null && infoObj.postObj.tsKey.fork[0].portion == null) {
            let theCode = "<pp>";
            let buttonOrder = 0;
            let lowerLettersList = "0abcdefghijklmnopqrstuvwxyz";
            let upperLettersList = "0ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                if (infoObj.postObj.tsKey.code[isc][0] == "" || infoObj.postObj.tsKey.code[isc].length == 1)
                    continue;
                buttonOrder++;
                if (infoObj.postObj.tsKey.code[isc][0] == infoObj.postObj.tsKey.submitName) {
                    theCode = infoObj.postObj.tsKey.code[isc][1];
                    if (infoObj.postObj.tsKey.code[isc][1].search (/<Void>/i) != -1) {
                        infoObj.postObj.postType = "<Void>";
                        theCode = theCode.replace (/<Void>/i, "");
                    }
                    if (infoObj.postObj.tsKey.code[isc][1].search (/<Static>/i) != -1) {
                        infoObj.postObj.isBtnStatic = true;
                        docsObj.isOutputDirRequest = true;
                        infoObj.postObj.isRemoveDone = true;
                        docsObj.docsList = [];
                        docsObj.isReadDone = true;
                        theCode = theCode.replace (/<Static>/i, "");
                    }
                    else {
                        infoObj.postObj.isBtnStatic = false;
                    }
                    if (!infoObj.postObj.isBtnStatic && infoObj.postObj.tsKey.code[isc].length > 2) {
                        let afterPart = '';
                        if (infoObj.postObj.tsKey.code[isc][2].indexOf ('!') != -1) {
                            afterPart = infoObj.postObj.tsKey.code[isc][2].slice (infoObj.postObj.tsKey.code[isc][2].indexOf ('!'));
                        }
                        let theNumber = parseInt (infoObj.postObj.tsKey.code[isc][2], 10);
                        if (theNumber > 0) {
                            theNumber--;
                            if (theNumber == 0) {
                                for (let isci = 0; isci < infoObj.postObj.tsKey.code.length; isci++) {
                                    if (infoObj.postObj.tsKey.code[isci][0] == "" || infoObj.postObj.tsKey.code[isci].length < 3)
                                        continue;
                                    if (infoObj.postObj.tsKey.code[isci][0] != infoObj.postObj.tsKey.submitName) {
                                        if (buttonOrder < lowerLettersList.length) {
                                            infoObj.postObj.tsKey.code[isci][2] = infoObj.postObj.tsKey.code[isci][2].replace (lowerLettersList[buttonOrder] + "?", '');
                                            infoObj.postObj.tsKey.code[isci][2] = infoObj.postObj.tsKey.code[isci][2].replace (upperLettersList[buttonOrder] + "?", '');
                                        }
                                        infoObj.postObj.tsKey.code[isci][2] = infoObj.postObj.tsKey.code[isci][2].replace (buttonOrder + '?', '');
                                        if (infoObj.postObj.tsKey.code[isci][2].indexOf ('!' + buttonOrder) != -1) {
                                            infoObj.postObj.tsKey.code[isci][2] = 'the' + buttonOrder + 'clicked?' + infoObj.postObj.tsKey.code[isci][2].replace ('!' + buttonOrder, '');
                                        }
                                        else if (buttonOrder < lowerLettersList.length) {
                                            if (infoObj.postObj.tsKey.code[isci][2].indexOf ("!" + lowerLettersList[buttonOrder]) != -1) {
                                                infoObj.postObj.tsKey.code[isci][2] = 'the' + upperLettersList[buttonOrder] + 'clicked?' + infoObj.postObj.tsKey.code[isci][2].replace ("!" + lowerLettersList[buttonOrder], '');
                                            }
                                            else if (infoObj.postObj.tsKey.code[isci][2].indexOf ("!" + upperLettersList[buttonOrder]) != -1) {
                                                infoObj.postObj.tsKey.code[isci][2] = 'the' + upperLettersList[buttonOrder] + 'clicked?' + infoObj.postObj.tsKey.code[isci][2].replace ("!" + upperLettersList[buttonOrder], '');
                                            }
                                        }
                                    }
                                }
                            }
                            infoObj.postObj.tsKey.code[isc][2] = theNumber + afterPart;
                        }
                    }
                }
            }
            infoObj.postObj.tsKey.fork[0].portion = theCode;
            infoObj.postObj.tsKey.fork[0].portion = solveAbbreviation (infoObj.postObj.tsKey.fork[0].portion);
            infoObj.postObj.tsKey.sourceName = infoObj.postObj.tsKey.fork[0].portion.slice (infoObj.postObj.tsKey.fork[0].portion.lastIndexOf ("/") + 1);
            solvePathCode (infoObj.postObj.tsKey, infoObj.postObj.tsKey.fork[0], infoObj);
        }
        else if (infoObj.postObj.tsKey.fork[0].isPathSolved) {
            if (!infoObj.postObj.tsKey.isFolderRequested) {
                fs.readdir(path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion), function (err, files) {
                    //handling error
                    if (err) {
                        console.log('Unable to scan directory2: ' + err);
                    }
                    else {
                        let filesNames = [];
                        //listing all files using forEach
                        files.forEach(function (file) {
                            // Do whatever you want to do with the file
                            filesNames.push (file); 
                        });
                        let isExist = false;
                        let tsKeyOldFullName = "";
                        for (let fln = filesNames.length - 1; fln >= 0; fln--) {
                            if (filesNames[fln].indexOf ("ts_key") != -1) {
                                isExist = true;
                                tsKeyOldFullName = filesNames[fln];
                                break;
                            }
                        }
                        if (infoObj.postObj.postType == "<Void>" && infoObj.postObj.isBtnStatic) {
                            infoObj.postObj.tsKey.isDone = true;
                        }
                        else if (isExist) {
                            let tsKeyNewFullName = tsKeyOldFullName;
                            if (infoObj.postObj.postType != "<Void>" && !infoObj.postObj.isBtnStatic) {
                                let tsKeyPhrase = tsKeyOldFullName.match (/ts_key(_\w+)*/)[0];
                                tsKeyPhrase = tsKeyPhrase.split ("_");
                                let newNum = 0;
                                if (tsKeyPhrase.length > 2) {
                                    let oldNum = parseInt (tsKeyPhrase[2], 10);
                                    if (!isNaN(oldNum)) {
                                        newNum = oldNum + 1;
                                    }
                                    tsKeyPhrase[2] = newNum;
                                }
                                else {
                                    tsKeyPhrase.push (newNum);
                                }
                                tsKeyNewFullName = tsKeyOldFullName.replace (/ts_key(_\w+)*/, tsKeyPhrase.join ("_"));
                            }
                            fs.unlink(path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, tsKeyOldFullName), function (err) {
                                if (err) throw err;
                                let theShiftContent = [];
                                for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                                    theShiftContent.push (infoObj.postObj.tsKey.code[isc].join (":"));
                                }
                                theShiftContent = theShiftContent.join ('\n');
                                updateFileContent (path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, tsKeyNewFullName), filesCache, theShiftContent);
                                fs.writeFile(path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, tsKeyNewFullName), theShiftContent, (err) => {
                                    if (err) throw err;
                                    fs.rename(path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, thumbPortion1, tsKeyOldFullName), path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, thumbPortion1, tsKeyNewFullName), function (err) {
                                        if (err) throw err;
                                        infoObj.postObj.tsKey.isDone = true;
                                        //update file id
                                        if (infoObj.postObj.postType != "<Void>") {
                                            let markFullName = path.relative(path.join (tsRoot, "Workshop"), path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, tsKeyNewFullName));
                                            markFullName = markFullName.split (path.sep).join ("  ");
                                            let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                                            fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                                                if (err) throw err;
                                            });
                                        }
                                    });
                                });
                            });
                        }
                        else {
                            fs.mkdir(path.join(infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, thumbPortion1), { recursive: true }, (err) => {
                                if (err) {
                                    throw err;
                                }
                                fs.copyFile(path.join(infoObj.postObj.mainPath, thumbPortion1, infoObj.tsKeyFileName), path.join(infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, thumbPortion1, infoObj.tsKeyFileName), (err) => {
                                    if (err) throw err;
                                    let theShiftContent = [];
                                    for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                                        theShiftContent.push (infoObj.postObj.tsKey.code[isc].join (":"));
                                    }
                                    theShiftContent = theShiftContent.join ('\n');
                                    updateFileContent (path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, infoObj.tsKeyFileName), filesCache, theShiftContent);
                                    fs.writeFile (path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, infoObj.tsKeyFileName), theShiftContent, (err) => {
                                        if (err) throw err;
                                        infoObj.postObj.tsKey.isDone = true;
                                        //update file id
                                        let markFullName = path.relative(path.join (tsRoot, "Workshop"), path.join(infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion, infoObj.tsKeyFileName));
                                        markFullName = markFullName.split (path.sep).join ("  ");
                                        let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                                        fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                                            if (err) throw err;
                                        });
                                    });
                                });
                            });
                        }
                    }
                });
                infoObj.postObj.tsKey.isFolderRequested = true;
            }
        }
        setTimeout(getLooping, 100, res, docsObj, infoObj);
        return false;
    }
    if (infoObj.postObj.tsKey.isFact && infoObj.postObj.tsKey.isDone && !infoObj.postObj.tsKey.isRedirectingDone) {
        infoObj.postObj.mainPath = path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion);
        infoObj.requrl = "/" + path.relative(tsRoot, path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion));
        infoObj.requrl = infoObj.requrl.split (path.sep).join ("/");
        docsObj.outputPath = getOutputPath (path.relative(tsRoot, path.join (infoObj.postObj.tsKey.fork[0].root, infoObj.postObj.tsKey.fork[0].portion)));
        infoObj.postObj.tsKey.isRedirectingDone = true;
    }
    if (!infoObj.postObj.isSourceAndDesPathsSolved) {
        for (let fl = 0; fl < infoObj.postObj.formFields.length; fl++) {
            if (infoObj.postObj.formFields[fl].isRequested) {
                continue;
            }
            if (!infoObj.postObj.formFields[fl].isToDelete) {
                if (infoObj.postObj.formFields[fl].fieldContent.indexOf ("op_") == 0) {
                    let tempFieldContent = infoObj.postObj.formFields[fl].fieldContent.replace (/:.*:/g, "");
                    let optionsPathSplitted = tempFieldContent.split ("_trsd_option_sep_");
                    if (optionsPathSplitted.length > 2) {
                        if (optionsPathSplitted[1].indexOf ("_dot_TREESHADE") == -1) {
                            let optionsSourceRoot = optionsPathSplitted[1].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                            let optionsSourceFile = optionsPathSplitted[2].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                            let targetNameWithoutExt = infoObj.postObj.formFields[fl].fileName;
                            if (targetNameWithoutExt.indexOf (".") != -1) {
                                targetNameWithoutExt = targetNameWithoutExt.slice (0, targetNameWithoutExt.lastIndexOf ("."));
                            }
                            let sourceExt = "";
                            if (optionsSourceFile.indexOf (".") != -1) {
                                sourceExt = optionsSourceFile.slice (optionsSourceFile.lastIndexOf ("."));
                            }
                            infoObj.postObj.formFields[fl].nameWithoutRenamePartAndExt = targetNameWithoutExt;
                            if (infoObj.postObj.formFields[fl].newName != '') {
                                if (targetNameWithoutExt.search (/(?<!^)\[[^\[\]]+\]$/) != -1) {
                                    targetNameWithoutExt = targetNameWithoutExt.replace (/(?<!^)\[[^\[\]]+\]$/, '[' + infoObj.postObj.formFields[fl].newName + ']');
                                }
                                else {
                                    targetNameWithoutExt += ' [' + infoObj.postObj.formFields[fl].newName + ']';
                                }
                            }
                            let optionTargetPath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, targetNameWithoutExt + sourceExt);
                            infoObj.postObj.formFields[fl].optionsSourceRoot = optionsSourceRoot;
                            infoObj.postObj.formFields[fl].optionsSourceFile = optionsSourceFile;
                            infoObj.postObj.formFields[fl].targetNameWithoutExt = targetNameWithoutExt;
                            infoObj.postObj.formFields[fl].sourceExt = sourceExt;
                            infoObj.postObj.formFields[fl].optionTargetPath = optionTargetPath;

                            if (path.join (tsRoot, "Workshop", infoObj.postObj.formFields[fl].optionsSourceRoot, infoObj.postObj.formFields[fl].optionsSourceFile) 
                                == path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, infoObj.postObj.formFields[fl].nameWithoutRenamePartAndExt + infoObj.postObj.formFields[fl].sourceExt)) {
                                if (infoObj.postObj.formFields[fl].optionsSourceFile != (infoObj.postObj.formFields[fl].targetNameWithoutExt + infoObj.postObj.formFields[fl].sourceExt)) {
                                    infoObj.postObj.formFields[fl].isToRename = true;
                                }
                                else {
                                    infoObj.postObj.formFields[fl].isToSkip = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        infoObj.postObj.isSourceAndDesPathsSolved = true;
    }
    if (!infoObj.postObj.isFieldsAndFilesRequested) {
        for (let fl = 0; fl < infoObj.postObj.formFields.length; fl++) {
            if (infoObj.postObj.formFields[fl].isRequested) {
                continue;
            }
            if (infoObj.postObj.formFields[fl].isToDelete) {
                if (!infoObj.postObj.formFields[fl].isToClean && !infoObj.postObj.isFieldsNonDeletedDone) {
                    continue;
                }
                infoObj.postObj.formFields[fl].isRequested = true;
                let toDeletePath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, infoObj.postObj.formFields[fl].fileName);
                fs.unlink(toDeletePath, function (err) {
                    if (err) {
                        //console.log('There is no file to delete: ' + err);
                    }
                    infoObj.postObj.formFields[fl].isDone = true;
                    //update file id
                    let optionTargetPath = toDeletePath;
                    let markFullName = path.relative(path.join (tsRoot, "Workshop"), optionTargetPath);
                    markFullName = markFullName.split (path.sep).join ("  ");
                    let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                    fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                        if (err) {
                            console.log (err);
                        }
                    });
                });
            }
            else {
                if (!infoObj.postObj.isFieldsCleanDone) {
                    continue;
                }
                if (infoObj.postObj.formFields[fl].isToRename && !infoObj.postObj.isFieldsNonRenamedDone) {
                    continue;
                }
                infoObj.postObj.formFields[fl].isRequested = true;
                if (infoObj.postObj.formFields[fl].fieldContent.indexOf ("op_") == 0) {
                    infoObj.postObj.formFields[fl].fieldContent = infoObj.postObj.formFields[fl].fieldContent.replace (/:.*:/g, "");
                    let optionsPathSplitted = infoObj.postObj.formFields[fl].fieldContent.split ("_trsd_option_sep_");
                    if (optionsPathSplitted.length > 2) {
                        if (optionsPathSplitted[1].indexOf ("_dot_TREESHADE") != -1) {
                            fs.mkdir(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath), { recursive: true }, (err) => {
                                if (err) {
                                    infoObj.postObj.formFields[fl].isDone = true;
                                }
                                else {
                                    let optionsPathSplitted = infoObj.postObj.formFields[fl].fieldContent.split ("_trsd_option_sep_");
                                    let optionsSourceRoot = optionsPathSplitted[1].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                                    let optionsSourceFile = optionsPathSplitted[2].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                                    let optionTargetPath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, infoObj.postObj.formFields[fl].fileName);
                                    fs.copyFile(path.join (tsRoot, "Workshop", optionsSourceRoot, optionsSourceFile), optionTargetPath, fs.constants.COPYFILE_EXCL, (err) => {
                                        if (err) {
                                            infoObj.postObj.formFields[fl].isDone = true;
                                        }
                                        else {
                                            infoObj.postObj.formFields[fl].isDone = true;
                                        }
                                    });
                                }
                            });
                        }
                        else {
                            if (infoObj.postObj.formFields[fl].isToRename || infoObj.postObj.formFields[fl].isToSkip) {
                                if (infoObj.postObj.formFields[fl].isToRename) {
                                    fs.rename(path.join (tsRoot, "Workshop", infoObj.postObj.formFields[fl].optionsSourceRoot, ".TREESHADE", infoObj.postObj.formFields[fl].optionsSourceFile), 
                                              path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, ".TREESHADE", infoObj.postObj.formFields[fl].targetNameWithoutExt + infoObj.postObj.formFields[fl].sourceExt), function (err) {
                                        fs.rename(path.join (tsRoot, "Workshop", infoObj.postObj.formFields[fl].optionsSourceRoot, infoObj.postObj.formFields[fl].optionsSourceFile), infoObj.postObj.formFields[fl].optionTargetPath, function (err) {
                                            infoObj.postObj.formFields[fl].isDone = true;
                                            //update file id
                                            let optionTargetPath = infoObj.postObj.formFields[fl].optionTargetPath;
                                            let markFullName = path.relative(path.join (tsRoot, "Workshop"), optionTargetPath);
                                            markFullName = markFullName.split (path.sep).join ("  ");
                                            let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                                            fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                                                if (err) throw err;
                                            });
                                        });
                                    });
                                }
                                else {
                                    infoObj.postObj.formFields[fl].isDone = true;
                                }
                            }
                            else {
                                fs.unlink(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, infoObj.postObj.formFields[fl].fileName), function (err) {
                                    if (err) {
                                        //console.log('There is no file to delete: ' + err);
                                    }
                                    fs.mkdir(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, thumbPortion1, thumbPortion2), { recursive: true }, (err) => {
                                        if (err) {
                                            console.log(err);
                                            infoObj.postObj.formFields[fl].isDone = true;
                                        }
                                        else {
                                            let optionsSourceRoot = infoObj.postObj.formFields[fl].optionsSourceRoot;
                                            let optionsSourceFile = infoObj.postObj.formFields[fl].optionsSourceFile;
                                            let targetNameWithoutExt = infoObj.postObj.formFields[fl].targetNameWithoutExt;
                                            let sourceExt = infoObj.postObj.formFields[fl].sourceExt;
                                            let optionTargetShadeFile = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, thumbPortion1, targetNameWithoutExt + sourceExt);
                                            function assigningPreviousHandler (shadeErr) {
                                                if (shadeErr) {
                                                    //may the file is Creative Cloud file and has no shade id, so ignore
                                                }
                                                let optionsSourceRoot = infoObj.postObj.formFields[fl].optionsSourceRoot;
                                                let optionsSourceFile = infoObj.postObj.formFields[fl].optionsSourceFile;
                                                let optionTargetPath = infoObj.postObj.formFields[fl].optionTargetPath;
                                                fs.copyFile(path.join (tsRoot, "Workshop", optionsSourceRoot, optionsSourceFile), optionTargetPath, (err) => {
                                                    if (err) {
                                                        console.log('Error 498: copying option source. ' + err);
                                                    }
                                                    infoObj.postObj.formFields[fl].isDone = true;
                                                    //update file id
                                                    let optionTargetPath = infoObj.postObj.formFields[fl].optionTargetPath;
                                                    let markFullName = path.relative(path.join (tsRoot, "Workshop"), optionTargetPath);
                                                    markFullName = markFullName.split (path.sep).join ("  ");
                                                    let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                                                    fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                                                        if (err) throw err;
                                                    });
                                                });
                                            }
                                            let targetShadeFullPath = infoObj.postObj.formFields[fl].optionTargetPath.replace ("Workshop", ".Data" + path.sep + "Shades");
                                            let isTargetShadeFileExist = false;
                                            try {
                                                if (fs.existsSync(targetShadeFullPath)) {
                                                    isTargetShadeFileExist = true;
                                                }
                                            } catch(err) {
                                                isTargetShadeFileExist = false;
                                            }
                                            if (isTargetShadeFileExist) {
                                                let targetShadeContent = getFileContent (targetShadeFullPath, shadesCache);
                                                function targetShadeContentHandler (tscErr, tscData) {
                                                    if (tscErr) {
                                                        assigningPreviousHandler (null);                                                    }
                                                    else {
                                                        if (tscErr == null) {
                                                            updateFileContent (targetShadeFullPath, shadesCache, tscData);
                                                        }
                                                        let targetShadeID = tscData.split (":")[1];
                                                        let sourceShadeFileFullPath = path.join (tsRoot, ".Data", "Shades", optionsSourceRoot, optionsSourceFile);
                                                        let sourceShadeContent = getFileContent (sourceShadeFileFullPath, shadesCache);
                                                        function sourceShadeContentHandler (sscErr, sscData) {
                                                            if (sscErr) {
                                                            }
                                                            else {
                                                                let sourceShadeID = sscData.split (":")[1];
                                                                let previousRecordFileFullPath = path.join(tsRoot, ".Data", "IDs", targetShadeID, "Previous ID");
                                                                addFileContent (previousRecordFileFullPath, previousCache, sourceShadeID);
                                                                fs.writeFile(previousRecordFileFullPath, sourceShadeID, function (err) {
                                                                    if (err) throw err;
                                                                });
                                                            }
                                                            assigningPreviousHandler (null);
                                                        }
                                                        if (sourceShadeContent) {
                                                            sourceShadeContentHandler (false, sourceShadeContent);
                                                        }
                                                        else {
                                                            fs.readFile (sourceShadeFileFullPath, 'UTF-8', sourceShadeContentHandler);
                                                        }
                                                    }
                                                }
                                                if (targetShadeContent) {
                                                    targetShadeContentHandler (false, targetShadeContent);
                                                }
                                                else {
                                                    fs.readFile (targetShadeFullPath, 'UTF-8', targetShadeContentHandler);
                                                }
                                            }
                                            else {
                                                fs.copyFile(path.join (tsRoot, "Workshop", optionsSourceRoot, thumbPortion1, optionsSourceFile), optionTargetShadeFile, assigningPreviousHandler);
                                            }

                                        }
                                    });
                                });
                            }
                        }
                    }
                    else {
                        infoObj.postObj.formFields[fl].isDone = true;
                    }
                }
                else {
                    //textSnippets old location
                    fs.mkdir(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath), { recursive: true }, (err) => {
                        if (err) {
                            infoObj.postObj.formFields[fl].isDone = true;
                        }
                        else {
                            if (infoObj.postObj.formFields[fl].newName != '') {
                                infoObj.postObj.formFields[fl].oldFileName = infoObj.postObj.formFields[fl].fileName; 
                                let newNameWithoutExt = infoObj.postObj.formFields[fl].fileName;
                                let nameExtension = '';
                                if (newNameWithoutExt.indexOf ('.') != -1) {
                                    nameExtension = newNameWithoutExt.slice (newNameWithoutExt.lastIndexOf ('.'));
                                    newNameWithoutExt = newNameWithoutExt.slice (0, newNameWithoutExt.lastIndexOf ('.'));
                                }
                                if (newNameWithoutExt.search (/(?<!^)\[[^\[\]]+\]$/) != -1) {
                                    newNameWithoutExt = newNameWithoutExt.replace (/(?<!^)\[[^\[\]]+\]$/, '[' + infoObj.postObj.formFields[fl].newName + ']');
                                }
                                else {
                                    newNameWithoutExt += ' [' + infoObj.postObj.formFields[fl].newName + ']';
                                }
                                infoObj.postObj.formFields[fl].fileName = newNameWithoutExt + nameExtension;
                            }
                            if (infoObj.postObj.formFields[fl].fieldContent == "") {
                                infoObj.postObj.formFields[fl].fieldContent = "no_text";
                            }
                            else {
                                infoObj.postObj.formFields[fl].fieldContent = resolveTags (infoObj.postObj.formFields[fl].fieldContent);
                            }
                            infoObj.postObj.formFields[fl].toWritePath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, infoObj.postObj.formFields[fl].fileName);
                            updateFileContent (infoObj.postObj.formFields[fl].toWritePath, filesCache, infoObj.postObj.formFields[fl].fieldContent);
                            fs.writeFile(infoObj.postObj.formFields[fl].toWritePath, infoObj.postObj.formFields[fl].fieldContent, function (err) {
                                if (err) {
                                    infoObj.postObj.formFields[fl].isDone = true;
                                }
                                else {
                                    if (infoObj.postObj.formFields[fl].newName != '') {
                                        fs.unlink(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, infoObj.postObj.formFields[fl].oldFileName), function (err) {
                                            if (err) {
                                                //console.log('There is no file to delete: ' + err);
                                            }
                                            fs.copyFile(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, thumbPortion1, infoObj.postObj.formFields[fl].oldFileName), 
                                                        path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[fl].subPath, thumbPortion1, infoObj.postObj.formFields[fl].fileName), (err) => {
                                                if (err) {
                                                    //may the file is Creative Cloud file and has no shade id, so ignore
                                                }
                                                infoObj.postObj.formFields[fl].isDone = true;
                                                //update file id
                                                let markFullName = path.relative(path.join (tsRoot, "Workshop"), infoObj.postObj.formFields[fl].toWritePath);
                                                markFullName = markFullName.split (path.sep).join ("  ");
                                                let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                                                fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                                                    if (err) throw err;
                                                });
                                            });
                                        });
                                    }
                                    else {  
                                        infoObj.postObj.formFields[fl].isDone = true;
                                    }
                                }
                            });
                        }
                    });
                }
            }
        }
        if (infoObj.postObj.isFieldsDone) {
            for (let fl = 0; fl < infoObj.postObj.formFiles.length; fl++) {
                if (infoObj.postObj.formFiles[fl].isRequested) {
                    continue;
                }
                infoObj.postObj.formFiles[fl].isRequested = true;
                let fileToDeletePath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFiles[fl].subPath, infoObj.postObj.formFiles[fl].fileName);
                fs.unlink(fileToDeletePath, function (err) {
                    if (err) {
                        //console.log('There is no file to delete: ' + err);
                    }
                    fs.mkdir(path.join (infoObj.postObj.mainPath, infoObj.postObj.formFiles[fl].subPath), { recursive: true }, (err) => {
                        if (err) {
                            throw err;
                        }
                        let originalNameWithoutExt = infoObj.postObj.formFiles[fl].fileName;
                        if (originalNameWithoutExt.indexOf (".") != -1) {
                            originalNameWithoutExt = originalNameWithoutExt.slice (0, originalNameWithoutExt.lastIndexOf ("."));
                        }
                        if (infoObj.postObj.formFiles[fl].newName != '') {
                            if (originalNameWithoutExt.search (/(?<!^)\[[^\[\]]+\]$/) != -1) {
                                originalNameWithoutExt = originalNameWithoutExt.replace (/(?<!^)\[[^\[\]]+\]$/, '[' + infoObj.postObj.formFiles[fl].newName + ']');
                            }
                            else {
                                originalNameWithoutExt += '[' + infoObj.postObj.formFiles[fl].newName + ']';
                            }
                        }
                        let uploadedExt = infoObj.postObj.formFiles[fl].uploadedName;
                        if (uploadedExt.indexOf (".") != -1) {
                            uploadedExt = uploadedExt.slice (uploadedExt.lastIndexOf ("."));
                        }
                        else {
                            uploadedExt = '';
                        }
                        let toRenameOldPath = infoObj.postObj.formFiles[fl].uploadedPath;
                        let toRenameNewPath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFiles[fl].subPath, originalNameWithoutExt + uploadedExt);
                        fs.rename(toRenameOldPath, toRenameNewPath, function (err) {
                            if (err) throw err;
                            infoObj.postObj.formFiles[fl].isDone = true;
                        });
                    }); 
                });
            }
        }
    }
    if (infoObj.postObj.isFieldsDone && infoObj.postObj.isFilesDone && !infoObj.postObj.isFieldsOutputted) {
        //lists creating
        if (!infoObj.postObj.isTextSnippetsCreated) {
            for (let ffd = 0; ffd < infoObj.postObj.formFields.length; ffd++) {
                if (!infoObj.postObj.formFields[ffd].isToDelete && infoObj.postObj.formFields[ffd].fieldContent.indexOf ("op_") != 0) {
                    if (/<(Output|Download|Function|Email|Whatsapp|QR)>/i.test(infoObj.postObj.formFields[ffd].fieldContent)) {
                        infoObj.postObj.formFields[ffd].textSnippets = {loopingCount: 0, list: [], isDeadEnd: false, isReadyToOutput: false, outputtedCount: 0};
                        let fileFullPath = path.join (infoObj.postObj.mainPath, infoObj.postObj.formFields[ffd].subPath, infoObj.postObj.formFields[ffd].fileName);
                        infoObj.postObj.formFields[ffd].textSnippets.list = createList (infoObj.postObj.formFields[ffd].fieldContent, fileFullPath, infoObj, []);
                    }
                    else {
                        infoObj.postObj.formFields[ffd].textSnippets = false;
                    }
                }
            }
            infoObj.postObj.isTextSnippetsCreated = true;
        }
        //textSnippets {loopingCount: 0, list: [], isDeadEnd: false, isReadyToOutput: false}
        //list item {fileFullPath: fileFullPath, isSnippet: false, text: solvedText[st], pathsMap: null}
        //pathMap {hostName: infoObj.hostName, sourcePath: infoObj.postObj.mainPath, fork: [], isDone: false, isEmail: false, isWhatsapp: false, snippetType: false, isQR: false, isFunction: false, isDownload: false, isFakePlace: false, descendingDeep: 0, isURLWithoutWorkshop: false, separator: ""}
        //fork item {root: null, portion: null, isPathSolved: false, filesFound: null}
        //filesFound item {name: '', result: ''}
        infoObj.postObj.isFieldsOutputted = true;
        for (let fl = 0; fl < infoObj.postObj.formFields.length; fl++) {
            if (!infoObj.postObj.formFields[fl].textSnippets) {
                continue;
            }
            if (!infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput) {
                infoObj.postObj.isFieldsOutputted = false;
                infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput = true;
                infoObj.postObj.formFields[fl].textSnippets.loopingCount++;
                for (let tss = infoObj.postObj.formFields[fl].textSnippets.list.length - 1; tss >= 0; tss--) {
                    let listItem = infoObj.postObj.formFields[fl].textSnippets.list[tss];
                    if (listItem.isSnippet) {
                        if (!listItem.pathsMap.isDone) {
                            infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput = false;
                            listItem.pathsMap.isDone = true;
                            let fk = 0;
                            outloop:
                            for (fk = 0; fk < listItem.pathsMap.fork.length; fk++) {
                                if (!listItem.pathsMap.fork[fk].isPathSolved) {
                                    listItem.pathsMap.isDone = false;
                                    break;
                                }
                                else if (listItem.pathsMap.snippetType == "Place") {
                                    if (listItem.pathsMap.fork[fk].filesFound) {
                                        for (let ff = listItem.pathsMap.fork[fk].filesFound.length - 1; ff >= 0; ff--) {
                                            if (listItem.pathsMap.fork[fk].filesFound[ff].result == null || listItem.pathsMap.fork[fk].filesFound[ff].result === false) {
                                                if (listItem.pathsMap.fork[fk].filesFound[ff].result == null) {
                                                    let fileNameAndResult = listItem.pathsMap.fork[fk].filesFound[ff];
                                                    let readFullPath = path.join(listItem.pathsMap.fork[fk].root, listItem.pathsMap.fork[fk].filesFound[ff].name);
                                                    function textHandler (err, data) {
                                                        if(err) {
                                                            fileNameAndResult.result = "";
                                                        }
                                                        else {
                                                            if (err == null) {
                                                                addFileContent (readFullPath, filesCache, data);
                                                            }
                                                            let pureData = data;
                                                            if (pureData.indexOf (lsSnippetDynamicTag) == 0) {
                                                                if (pureData.search (/(:[\n\r])|(\r\n)/) != -1) {
                                                                    pureData = pureData.slice (pureData.search (/(:[\n\r])|(\r\n)/) + pureData.match (/(:[\n\r])|(\r\n)/)[0].length);
                                                                }
                                                            }
                                                            if (pureData == "no_text") {
                                                                pureData = "";
                                                            }
                                                            fileNameAndResult.result = pureData;
                                                        }
                                                    }
                                                    listItem.pathsMap.fork[fk].filesFound[ff].result = false;
                                                    let testedContent = getFileContent (readFullPath, filesCache);
                                                    if (testedContent != null) {
                                                        textHandler (false, testedContent);
                                                    }
                                                    else {
                                                        fs.readFile (readFullPath, 'UTF-8', textHandler);
                                                    }
                                                }
                                                listItem.pathsMap.isDone = false;
                                                break outloop;
                                            }
                                        }
                                    }
                                }
                            }
                            if (listItem.pathsMap.isDone) {
                                if (listItem.pathsMap.snippetType != "Output") {
                                    infoObj.postObj.formFields[fl].textSnippets.list.splice (tss, 1);
                                    let isFirstInserted = false;
                                    let shellSource = '';
                                    let shellSplit = null;
                                    let isRegExpSplit = false;
                                    let shellID = '';
                                    if (listItem.ids.length > 0 && listItem.ids[listItem.ids.length - 1][0] == '!') {
                                        shellID = listItem.ids[listItem.ids.length - 1];
                                        listItem.pathsMap.snippetType = "Place";
                                        listItem.pathsMap.isFakePlace = true;
                                        listItem.ids[listItem.ids.length - 1] = '~' + shellID.slice (1);
                                        for (let tsin = 0; tsin < infoObj.postObj.formFields[fl].textSnippets.list.length; tsin++) {
                                            if (tsin == tss) {
                                                continue;
                                            }
                                            let testedItem = infoObj.postObj.formFields[fl].textSnippets.list[tsin];
                                            if (testedItem.text.search (new RegExp ("<[iI][dD]#" + shellID)) != -1) {
                                                shellSource = testedItem.text;
                                                if (shellSource.search (/<Split\/[^<>]+>/i) != -1) {
                                                    shellSplit = shellSource.match (/<Split\/[^<>]+>/i)[0];
                                                    shellSplit = shellSplit.slice (7, -1);
                                                    shellSource = shellSource.replace (/<Split\/[^<>]+>/ig, "");
                                                    if (shellSplit.length > 0 && shellSplit[shellSplit.length - 1] == "/") {
                                                        shellSplit = shellSplit.slice (0, -1);
                                                        isRegExpSplit = true;
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    let totalFilesCount = 0;
                                    for (fk = listItem.pathsMap.fork.length - 1; fk >= 0; fk--) {
                                        if (listItem.pathsMap.fork[fk].filesFound != null) {
                                            for (let ff = listItem.pathsMap.fork[fk].filesFound.length - 1; ff >= 0; ff--) {
                                                if (listItem.pathsMap.fork[fk].filesFound[ff].result !== false) {
                                                    if (shellSplit != null) {
                                                        let toBeSplitted = listItem.pathsMap.fork[fk].filesFound[ff].result;
                                                        if (isRegExpSplit) {
                                                            toBeSplitted = toBeSplitted.split (new RegExp(shellSplit, ''));
                                                        }
                                                        else {
                                                            toBeSplitted = toBeSplitted.split (shellSplit);
                                                        }
                                                        totalFilesCount += toBeSplitted.length - 1;
                                                        listItem.pathsMap.fork[fk].filesFound[ff].result = toBeSplitted[0];
                                                        for (let ffl = toBeSplitted.length - 1; ffl > 0; ffl--) {
                                                            listItem.pathsMap.fork[fk].filesFound.splice (ff + 1, 0, {name: listItem.pathsMap.fork[fk].filesFound[ff].name,
                                                                                                                      result: toBeSplitted[ffl]});
                                                        }
                                                    }
                                                    totalFilesCount++;
                                                }
                                            }
                                        }
                                    }
                                    for (fk = listItem.pathsMap.fork.length - 1; fk >= 0; fk--) {
                                        if (listItem.pathsMap.fork[fk].filesFound != null) {
                                            for (let ff = listItem.pathsMap.fork[fk].filesFound.length - 1; ff >= 0; ff--) {
                                                if (listItem.pathsMap.fork[fk].filesFound[ff].result !== false) {
                                                    let theResult = listItem.pathsMap.fork[fk].filesFound[ff].result;
                                                    if (shellSource != '') {
                                                        theResult = shellSource.replace (/<Row#>/ig, totalFilesCount).replace (new RegExp ("<[iI][dD]#" + shellID + ">", "g"), theResult);
                                                    }
                                                    if (isFirstInserted) {
                                                        let sepClonedIDs = listItem.ids.slice();
                                                        for (let cid = 0; cid < sepClonedIDs.length; cid++) {
                                                            sepClonedIDs[cid] = sepClonedIDs[cid].replace ("*", totalFilesCount + "s");
                                                        }
                                                        let sepItem = {fileFullPath: null, isSnippet: false, text: listItem.pathsMap.separator, pathsMap: null, ids: sepClonedIDs, idGettingAttempts: 0, initTime: new Date ().getTime ()};
                                                        infoObj.postObj.formFields[fl].textSnippets.list.splice (tss, 0, sepItem);
                                                    }
                                                    let clonedIDs = listItem.ids.slice();
                                                    for (let cid = 0; cid < clonedIDs.length; cid++) {
                                                        clonedIDs[cid] = clonedIDs[cid].replace ("*", totalFilesCount);
                                                    }
                                                    if (listItem.pathsMap.snippetType == "Place" && (listItem.pathsMap.fork[fk].filesFound[ff].name.search (/\.html$/) == -1 || listItem.pathsMap.isFakePlace)) {
                                                        let newList = createList (theResult, path.join (listItem.pathsMap.fork[fk].root, listItem.pathsMap.fork[fk].filesFound[ff].name), infoObj, clonedIDs);
                                                        if (newList.length > 0) {
                                                            for (let nl = newList.length - 1; nl >= 0; nl--) {
                                                                if (newList[nl].isSnippet) {
                                                                    infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput = false;
                                                                }
                                                                infoObj.postObj.formFields[fl].textSnippets.list.splice (tss, 0, newList[nl]);
                                                            }
                                                            isFirstInserted = true;
                                                        }
                                                    }
                                                    else {
                                                        let newItem = {fileFullPath: null, isSnippet: false, text: theResult, pathsMap: null, ids: clonedIDs, idGettingAttempts: 0, initTime: new Date ().getTime ()};
                                                        infoObj.postObj.formFields[fl].textSnippets.list.splice (tss, 0, newItem);
                                                        isFirstInserted = true;
                                                    }
                                                    totalFilesCount--;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput) {
                    let tss = 0;
                    let testedIsDeadEnd = true;
                    for (tss = infoObj.postObj.formFields[fl].textSnippets.list.length - 1; tss >= 0; tss--) {
                        let listItem = infoObj.postObj.formFields[fl].textSnippets.list[tss];
                        if (listItem.isSnippet) {
                            if (!listItem.pathsMap.isDone)
                                testedIsDeadEnd = false;
                            continue;
                        }
                        if (listItem.idGettingAttempts > 0 && listItem.text.search (/<id#![^<>]+>/i) == -1) {
                            infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput = false;
                            listItem.idGettingAttempts++;
                            
                            let allMatches = listItem.text.match (/<id#[^<>]+>/ig);
                            let isRowsSolved = false;
                            let ams = 0;
                            for (ams = 0; ams < allMatches.length; ams++) {
                                if (allMatches[ams].search (/<id#.+\/.+/i) != -1) {
                                    let extractedObject = extractNestedTags (listItem.text);
                                    if (extractedObject.returnedText == "TS_TEMP_PLACEHOLDER") {
                                        extractedObject = extractNestedTags (listItem.text.replace (/^<ts>/i, "").replace (/<\/ts>$/i, ""));
                                    }
                                    if (extractedObject.returnedText.match (/<id#[^<>]+>/ig).length > 1) {
                                        break;
                                    }
                                    
                                    let idTarget = allMatches[ams].slice (allMatches[ams].indexOf ("#") + 1, allMatches[ams].search (/\//));
                                    if (idTarget) {
                                        if (!idTarget.startsWith('@')) {
                                            let hashBranch = path.relative(path.join (tsRoot, "Workshop"), listItem.fileFullPath);
                                            let hashBranchSplitted = hashBranch.split (path.sep);
                                            hashBranchSplitted[hashBranchSplitted.length - 1] = getPureName (hashBranchSplitted[hashBranchSplitted.length - 1], false);
                                            idTarget = generateNumericHash("/" + hashBranchSplitted.join ("/")) + idTarget;
                                        }
                                        let splitChain = allMatches[ams].slice (allMatches[ams].search (/\//) + 1, -1).split (/(?<!\\)\//);
                                        let sourceSplitted = "";
                                        for (let tsin = 0; tsin < infoObj.postObj.formFields[fl].textSnippets.list.length; tsin++) {
                                            let testedItem = infoObj.postObj.formFields[fl].textSnippets.list[tsin];
                                            if (!testedItem.isSnippet && testedItem.idGettingAttempts == 0) {
                                                for (let idt = testedItem.ids.length - 1; idt >= 0; idt--) {
                                                    if (testedItem.ids[idt] == idTarget) {
                                                        sourceSplitted += testedItem.text;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (sourceSplitted != "") {
                                            sourceSplitted = sourceSplitted.split (new RegExp(splitChain[0], ''));
                                        }
                                        else {
                                            sourceSplitted = [];
                                        }
                                        if (sourceSplitted.length > 0) {
                                            isRowsSolved = true;
                                            //change to Place so it will be solved there
                                            listItem.isSnippet = true;
                                            listItem.pathsMap.snippetType = "Place";
                                            listItem.pathsMap.isFakePlace = true;
                                            testedIsDeadEnd = false;
                                            listItem.text = extractedObject.returnedText;
                                            if (listItem.text.search (/<Separator\/(([^<>]+)|(<[^<>]+>))+>/i) != -1) {
                                                listItem.pathsMap.separator = listItem.text.match (/<Separator\/(([^<>]+)|(<[^<>]+>))+>/i)[0];
                                                listItem.pathsMap.separator = listItem.pathsMap.separator.slice (11, -1).replace(/\\n|\\t|\\r|\\b|\\f|\\v/g, match => {
                                                                                                                                                                return {
                                                                                                                                                                '\\n': '\n',
                                                                                                                                                                '\\t': '\t',
                                                                                                                                                                '\\r': '\r',
                                                                                                                                                                '\\b': '\b',
                                                                                                                                                                '\\f': '\f',
                                                                                                                                                                '\\v': '\v'
                                                                                                                                                                }[match];
                                                                                                                                                            });
                                                listItem.text = listItem.text.replace (/<Separator\/(([^<>]+)|(<[^<>]+>))+>/i, "");
                                            }
                                            if (listItem.text.search (/<id_[^<>]+>/i) != -1) {
                                                let idsNew = listItem.text.match (/<id_[^<>]+>/ig);
                                                listItem.text = listItem.text.replace (/<id_[^<>]+>/ig, '');
                                                for (let inw = 0; inw < idsNew.length; inw++) {
                                                    let extractedId = idsNew[inw].slice (4, -1);
                                                    if (!extractedId.startsWith('@')) {
                                                        let hashBranch = path.relative(path.join (tsRoot, "Workshop"), listItem.fileFullPath);
                                                        let hashBranchSplitted = hashBranch.split (path.sep);
                                                        hashBranchSplitted[hashBranchSplitted.length - 1] = getPureName (hashBranchSplitted[hashBranchSplitted.length - 1], false);
                                                        extractedId = generateNumericHash("/" + hashBranchSplitted.join ("/")) + extractedId;
                                                    }
                                                    listItem.ids.push (extractedId);
                                                }
                                            }
                                            extractedObject.returnedText = listItem.text;
                                            listItem.text = reconstructNestedTags (extractedObject);
                                            let textTemplate = listItem.text;
                                            textTemplate = textTemplate.replace (allMatches[ams], "");
                                            textTemplate = textTemplate.replace (/<#>/g, "<Row#>").replace(/(<\^*)\^#>/g, "$1#>");
                                            let containerFileName = listItem.pathsMap.fork[0].filesFound[0].name;
                                            let cellAndHeadMatch = textTemplate.match (/<(And_|Or_|Must_)*(Cell|Head)\//i);
                                            while (cellAndHeadMatch && cellAndHeadMatch.length > 0) {
                                                let replaceWith = "Row/#<Row#>/";
                                                if (cellAndHeadMatch[0].slice (-5, -1).toLowerCase () == "head") {
                                                    replaceWith = "Row/#1/";
                                                }
                                                textTemplate = textTemplate.replace (cellAndHeadMatch[0], cellAndHeadMatch[0].slice (0, -5) + replaceWith);
                                                cellAndHeadMatch = textTemplate.match (/<(And_|Or_|Must_)*(Cell|Head)\//i);
                                            }
                                            listItem.pathsMap.fork[0].filesFound = [];
                                            for (let ffr = 0; ffr < sourceSplitted.length; ffr++) {
                                                let rowNum = ffr + 1;
                                                let textToSetup = textTemplate;
                                                textToSetup = textToSetup.replace (/<Row>/ig, "<Row/#" + rowNum + ">").replace (/<Row#>/ig, rowNum);
                                                let isSuccess = null;
                                                let isAtLeastOrSuccess = null;
                                                if (textToSetup.search (/<(And_|Or_|Must_)*Row[^<>]+>/i) != -1) {
                                                    let cellsMatches = textToSetup.match (/<(And_|Or_|Must_)*Row[^<>]+>/i);
                                                    while (cellsMatches && cellsMatches.length > 0) {
                                                        let conditionText = "";
                                                        if (cellsMatches[0].search (/<And_/i) == 0) {
                                                            conditionText = "And";
                                                        }
                                                        else if (cellsMatches[0].search (/<Or_/i) == 0) {
                                                            conditionText = "Or";
                                                        }
                                                        else if (cellsMatches[0].search (/<Must_/i) == 0) {
                                                            conditionText = "Must";
                                                        }
                                                        let matchParts = cellsMatches[0].split (/(?<!\\)\//);
                                                        matchParts.splice (0, 1);
                                                        let isForOrder = false;
                                                        if (matchParts.length > 0) {
                                                            matchParts[matchParts.length - 1] = matchParts[matchParts.length - 1].slice (0, -1);
                                                            if (matchParts[matchParts.length - 1].slice (-1) == "#") {
                                                                isForOrder = true;
                                                            }
                                                        }
                                                        let splitChainIndex = 0;
                                                        let miningSource = sourceSplitted;
                                                        let miningResult = null;
                                                        let miningIndexes = [];
                                                        while (matchParts.length > 0) { 
                                                            miningIndexes.unshift (-1);
                                                            if (matchParts[0].length == 0) {
                                                                matchParts[0] = ".+";
                                                            }
                                                            if (matchParts[0].search (/#/) == 0) {
                                                                let expectedIndex = parseInt (matchParts[0].slice (1), 10);
                                                                if (isNaN(expectedIndex)) {
                                                                    miningIndexes[0] = miningSource.length - 1;
                                                                }
                                                                else {
                                                                    if (expectedIndex > 0 && expectedIndex <= miningSource.length) {
                                                                        miningIndexes[0] = expectedIndex - 1;
                                                                    }
                                                                }
                                                            }
                                                            else {
                                                                for (let ms = 0; ms < miningSource.length; ms++) {
                                                                    if (miningSource[ms].search (new RegExp (matchParts[0], "i")) != -1) {
                                                                        miningIndexes[0] = ms;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            if (miningIndexes[0] != -1) {
                                                                if (matchParts.length == 1) {
                                                                    if (isForOrder) {
                                                                        miningResult = (miningIndexes[0] + 1).toString ();
                                                                    }
                                                                    else {
                                                                        miningResult = miningSource[miningIndexes[0]];
                                                                    }
                                                                    break;
                                                                }
                                                                splitChainIndex++;
                                                                if (splitChainIndex >= splitChain.length) {
                                                                    splitChainIndex--;
                                                                    miningSource = [miningSource[miningIndexes[0]]];
                                                                }
                                                                else {
                                                                    miningSource = miningSource[miningIndexes[0]].split (new RegExp (splitChain[splitChainIndex], ''));
                                                                }
                                                            }
                                                            else {
                                                                break;
                                                            }
                                                            matchParts.splice (0, 1);
                                                        }
                                                        if (miningResult == null) {
                                                            if (conditionText == "And" || conditionText == "Must") {
                                                                isSuccess = false;
                                                                break;
                                                            }
                                                            else if (conditionText == "Or" && isAtLeastOrSuccess == null) {
                                                                isAtLeastOrSuccess = false;
                                                            }
                                                            miningResult = "";
                                                        }
                                                        else {
                                                            if (conditionText == "Or") {
                                                                isAtLeastOrSuccess = true;
                                                                isSuccess = true;
                                                            }
                                                        }
                                                        if (conditionText == "And" || conditionText == "Or") {
                                                            miningResult = "";
                                                        }
                                                        textToSetup = textToSetup.replace (cellsMatches[0], miningResult);
                                                        cellsMatches = textToSetup.match (/<(And_|Or_|Must_)*Row[^<>]+>/i);
                                                    }
                                                    textToSetup = textToSetup.replace (allMatches[ams], "");
                                                }
                                                else {
                                                    isSuccess = true;
                                                    textToSetup = textToSetup.replace (allMatches[ams], sourceSplitted[ffr]);
                                                }
                                                if (isSuccess == null && isAtLeastOrSuccess == null) {
                                                    isSuccess = true;
                                                }
                                                if (isSuccess) {
                                                    listItem.pathsMap.fork[0].filesFound.push ({name: containerFileName, result: textToSetup});
                                                }
                                            }
                                        }
                                        if (isRowsSolved) {
                                            break;
                                        }
                                    }
                                    else {
                                        listItem.text = listItem.text.replace (allMatches[ams], "");
                                    }
                                }
                            }
                            if (!isRowsSolved) {
                                let idTargets = [];
                                outerloop:
                                for (ams = 0; ams < allMatches.length; ams++) {
                                    let idTarget = allMatches[ams].slice (4, -1);
                                    let idCollectedText = '';
                                    let isCollected = false;
                                    if (idTarget == "TSFAKEFORNESTED") {
                                        isCollected = true;
                                    }
                                    else {
                                        if (!idTarget.startsWith('@')) {
                                            let hashBranch = path.relative(path.join (tsRoot, "Workshop"), listItem.fileFullPath);
                                            let hashBranchSplitted = hashBranch.split (path.sep);
                                            hashBranchSplitted[hashBranchSplitted.length - 1] = getPureName (hashBranchSplitted[hashBranchSplitted.length - 1], false);
                                            idTarget = generateNumericHash("/" + hashBranchSplitted.join ("/")) + idTarget;
                                        }
                                        for (let idta = idTargets.length - 1; idta >= 0; idta--) {
                                            if (idTargets[idta] == idTarget) {
                                                continue outerloop;
                                            }
                                        }
                                        idTargets.push (idTarget);
                                        for (let tsin = 0; tsin < infoObj.postObj.formFields[fl].textSnippets.list.length; tsin++) {
                                            let testedItem = infoObj.postObj.formFields[fl].textSnippets.list[tsin];
                                            if (!testedItem.isSnippet && testedItem.idGettingAttempts == 0) {
                                                for (let idt = testedItem.ids.length - 1; idt >= 0; idt--) {
                                                    if (testedItem.ids[idt] == idTarget) {
                                                        idCollectedText += testedItem.text;
                                                        isCollected = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (isCollected) {
                                        listItem.text = listItem.text.replace (new RegExp (allMatches[ams], "g"), idCollectedText);
                                    }
                                }
                                if (listItem.text.search (/<id#[^<>]+>/i) == -1) {
                                    //change to Place so it will be solved there
                                    listItem.isSnippet = true;
                                    listItem.pathsMap.snippetType = "Place";
                                    listItem.pathsMap.isFakePlace = true;
                                    testedIsDeadEnd = false;
                                    listItem.pathsMap.fork[0].filesFound[0].result = listItem.text;
                                }
                                else {
                                    if (infoObj.postObj.formFields[fl].textSnippets.isDeadEnd || (((new Date ().getTime ()) - listItem.initTime) > idGettingtolerance)) {
                                        infoObj.postObj.formFields[fl].textSnippets.list.splice (tss, 1);
                                    }
                                }
                            }
                        }
                    }
                    if (testedIsDeadEnd)
                        infoObj.postObj.formFields[fl].textSnippets.isDeadEnd = testedIsDeadEnd;
                    if (infoObj.postObj.formFields[fl].textSnippets.isReadyToOutput) {
                        //keyid
                        for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                            if (infoObj.postObj.tsKey.code[isc].length > 1) {
                                let idTargets = [];
                                let allMatches = infoObj.postObj.tsKey.code[isc][1].match (/<id#[^<>]+>/ig);
                                if (allMatches) {
                                    outerloop:
                                    for (let ams = 0; ams < allMatches.length; ams++) {
                                        let idTarget = allMatches[ams].slice (4, -1);
                                        for (let idta = idTargets.length - 1; idta >= 0; idta--) {
                                            if (idTargets[idta] == idTarget) {
                                                continue outerloop;
                                            }
                                        }
                                        idTargets.push (idTarget);
                                        let idCollectedText = '';
                                        let isCollected = false;
                                        for (let tsin = 0; tsin < infoObj.postObj.formFields[fl].textSnippets.list.length; tsin++) {
                                            let testedItem = infoObj.postObj.formFields[fl].textSnippets.list[tsin];
                                            if (!testedItem.isSnippet && testedItem.idGettingAttempts == 0) {
                                                for (let idt = testedItem.ids.length - 1; idt >= 0; idt--) {
                                                    if (testedItem.ids[idt] == idTarget) {
                                                        idCollectedText += testedItem.text;
                                                        isCollected = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (isCollected) {
                                            infoObj.postObj.tsKey.code[isc][1] = infoObj.postObj.tsKey.code[isc][1].replace (new RegExp (allMatches[ams], "g"), idCollectedText);
                                        }
                                    }
                                }
                            }
                        }
                        let toOutputIDsMap = {};
                        for (tss = 0; tss < infoObj.postObj.formFields[fl].textSnippets.list.length; tss++) {
                            let listItem = infoObj.postObj.formFields[fl].textSnippets.list[tss];
                            if (listItem.isSnippet && listItem.pathsMap.snippetType == "Output") {
                                let outputID = "";
                                if (listItem.ids.length == 0) {
                                    listItem.ids.push ("");
                                }
                                for (let lii = listItem.ids.length - 1; lii >= 0; lii--) {
                                    let thisID = listItem.ids[lii];
                                    if (!(thisID in toOutputIDsMap)) {
                                        let toOutputContent = '';
                                        for (let tsin = 0; tsin < infoObj.postObj.formFields[fl].textSnippets.list.length; tsin++) {
                                            let testedItem = infoObj.postObj.formFields[fl].textSnippets.list[tsin];
                                            let isOKToAdd = true;
                                            if (thisID != '') {
                                                isOKToAdd = false;
                                            }
                                            for (let tii = 0; tii < testedItem.ids.length; tii++) {
                                                if (thisID == '') {
                                                    if (testedItem.ids[tii].length > 0 && testedItem.ids[tii][0] != '~') {
                                                        isOKToAdd = false;
                                                        break;
                                                    }
                                                }
                                                else if (thisID == testedItem.ids[tii]) {
                                                    isOKToAdd = true;
                                                    break;
                                                }
                                            }
                                            if (!testedItem.isSnippet && isOKToAdd && testedItem.text.search (/<id#![^<>]+>/i) == -1) {
                                                toOutputContent += testedItem.text;
                                            }
                                        }
                                        toOutputIDsMap[thisID] = toOutputContent;
                                    }
                                    if (lii == listItem.ids.length - 1) {
                                        outputID = thisID;
                                    }
                                }
                                //infoObj.postObj.htmlFileContent
                                if (listItem.pathsMap.isEmail) {
                                    let emailTransport = null;
                                    let transportMatch = listItem.pathsMap.fork[0].filesFound[0].result.match(/<Transport\/[\s\S]+?>/i);
                                    if (transportMatch && transportMatch.length > 0) {
                                        try {
                                            const jsonText = transportMatch[0].slice(11, -1); // remove <Transport/ and >
                                            emailTransport = JSON.parse(jsonText);
                                            listItem.pathsMap.fork[0].filesFound[0].result =
                                                listItem.pathsMap.fork[0].filesFound[0].result.replace(/<Transport\/[\s\S]+?>/ig, "");
                                        } catch (e) {
                                            console.log("Invalid JSON in <Transport/> tag", e);
                                        }
                                    }
                                    if (emailTransport) {
                                        let emailTo = null;
                                        let toMatch = listItem.pathsMap.fork[0].filesFound[0].result.match(/<To\/[^<>]+>/i);
                                        if (toMatch && toMatch.length > 0) {
                                            emailTo = toMatch[0].slice(4, -1);
                                            listItem.pathsMap.fork[0].filesFound[0].result =
                                                listItem.pathsMap.fork[0].filesFound[0].result.replace(/<To\/[^<>]+>/ig, "");
                                        }

                                        if (emailTo) {
                                            let emailSubject = "No Title";
                                            let subjectMatch = listItem.pathsMap.fork[0].filesFound[0].result.match(/<Subject\/[^<>]+>/i);
                                            if (subjectMatch && subjectMatch.length > 0) {
                                                emailSubject = subjectMatch[0].slice(9, -1);
                                                listItem.pathsMap.fork[0].filesFound[0].result =
                                                    listItem.pathsMap.fork[0].filesFound[0].result.replace(/<Subject\/[^<>]+>/ig, "");
                                            }

                                            let emailBody = toOutputIDsMap[outputID];
                                            let mailOptions = {
                                                from: emailTransport.auth?.user || "unknown@domain.com",
                                                to: emailTo,
                                                subject: emailSubject,
                                                html: emailBody
                                            };

                                            let transporter = nodemailer.createTransport(emailTransport);
                                            transporter.sendMail(mailOptions, function (error, info) {
                                                if (error) {
                                                    console.log(error);
                                                } else {
                                                    console.log('Email sent: ' + info.response);
                                                }
                                            });
                                        }
                                    }
                                }
                                else if (listItem.pathsMap.isWhatsapp) {
                                    let whatsappTo = null;
                                    let toMatch = listItem.pathsMap.fork[0].filesFound[0].result.match (/<To\/[^<>]+>/i);
                                    if (toMatch && toMatch.length > 0) {
                                        whatsappTo = toMatch[0].slice (4, -1);
                                        listItem.pathsMap.fork[0].filesFound[0].result = listItem.pathsMap.fork[0].filesFound[0].result.replace (/<To\/[^<>]+>/ig, "");
                                    }
                                    if (whatsappTo != null) {
                                        let whatsappMessage = toOutputIDsMap[outputID];
                                        sendMessageWhatsapp (whatsappTo, whatsappMessage);
                                    }
                                }
                                else if (listItem.pathsMap.fork[0].filesFound == null) {
                                    if (listItem.pathsMap.fork[0].root.toLowerCase() == "index") {
                                        infoObj.postObj.htmlFileContent = toOutputIDsMap[outputID];
                                    }
                                }
                                else {
                                    function outputHandler (err, data) {
                                        if(err) {
                                            data = 'Error Output';
                                            console.log ("err=" + err);
                                        }
                                        updateFileContent (listItem.pathsMap.fork[0].filesFound[listItem.pathsMap.fork[0].filesFound.length-1].result, filesCache, data);
                                        fs.writeFile(listItem.pathsMap.fork[0].filesFound[listItem.pathsMap.fork[0].filesFound.length-1].result, data, function (err) {
                                            if (err) throw err;
                                            infoObj.postObj.formFields[fl].textSnippets.outputtedCount++;
                                        });
                                    }
                                    if (listItem.pathsMap.isQR) {
                                        QRCode.toString(toOutputIDsMap[outputID], { type: 'svg' }, outputHandler);
                                    }
                                    else if (listItem.pathsMap.isDownload) {
                                        downloadFile (toOutputIDsMap[outputID], listItem.pathsMap.fork[0].filesFound[listItem.pathsMap.fork[0].filesFound.length-1].result);
                                    }
                                    else if (listItem.pathsMap.isFunction) {
                                        if (listItem.ids.length > 0 && toOutputIDsMap) {
                                            function escapeForEval(text) {
                                                return text
                                                    .replace(/\\/g, "\\\\")
                                                    .replace(/"/g, '\\"')
                                                    .replace(/'/g, "\\'")
                                                    .replace(/\n/g, '\\n')
                                                    .replace(/\r/g, '\\r');
                                            }

                                            let codeText = toOutputIDsMap[listItem.ids[0]];
                                            // Handle outputPath formatting
                                            let rawPath = listItem.pathsMap.fork[0].filesFound[0].result;
                                            let formattedPath = rawPath.replace(/\\/g, "\\\\");

                                            // Match the first function definition
                                            const funcMatch = codeText.match(/function\s+([a-zA-Z0-9_]+)\s*\(([^)]*)\)/);
                                            if (funcMatch) {
                                                const funcName = funcMatch[1];
                                                const paramList = funcMatch[2].split(',').map(p => p.trim());

                                                let argValues = paramList.map(param => {
                                                    if (/outputPath/i.test(param)) {
                                                        return `"${formattedPath}"`;
                                                    }

                                                    for (let lii = 1; lii < listItem.ids.length; lii++) {
                                                        let id = listItem.ids[lii];
                                                        if (id.search(new RegExp(param + '$', 'i')) !== -1) {
                                                            let val = toOutputIDsMap[id];
                                                            return `"${escapeForEval(val)}"`;
                                                        }
                                                    }

                                                    return 'undefined'; // fallback
                                                });

                                                codeText += `\n${funcName}(${argValues.join(', ')});`;
                                            }

                                            try {
                                                eval(codeText);
                                            } catch (error) {
                                                console.error(" Function Execution Error:", error);
                                            }
                                        }
                                    }
                                    else {
                                        outputHandler (false, toOutputIDsMap[outputID]);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    var isAllFieldsRequested = true;
    var isAllFilesRequested = true;
    if (!infoObj.postObj.isFieldsDone) {
        infoObj.postObj.isFieldsNonRenamedDone = true;
        infoObj.postObj.isFieldsNonDeletedDone = true;
        infoObj.postObj.isFieldsDone = true;
        infoObj.postObj.isFieldsCleanDone = true;
        for (let fl = 0; fl < infoObj.postObj.formFields.length; fl++) {
            if (!infoObj.postObj.formFields[fl].isDone) {
                infoObj.postObj.isFieldsDone = false;
                if (!infoObj.postObj.formFields[fl].isToRename) {
                    infoObj.postObj.isFieldsNonRenamedDone = false;
                }
                if (!infoObj.postObj.formFields[fl].isToDelete) {
                    infoObj.postObj.isFieldsNonDeletedDone = false;
                }
                if (infoObj.postObj.formFields[fl].isToClean) {
                    infoObj.postObj.isFieldsCleanDone = false;
                }
            }
            if (!infoObj.postObj.formFields[fl].isRequested) {
                isAllFieldsRequested = false;
            }
        }
    }
    if (!infoObj.postObj.isFilesDone) {
        infoObj.postObj.isFilesDone = true;
        for (let fl = 0; fl < infoObj.postObj.formFiles.length; fl++) {
            if (!infoObj.postObj.formFiles[fl].isDone) {
                infoObj.postObj.isFilesDone = false;
            }
            if (!infoObj.postObj.formFiles[fl].isRequested) {
                isAllFilesRequested = false;
            }
        }
    }
    if (isAllFieldsRequested && isAllFilesRequested) {
        infoObj.postObj.isFieldsAndFilesRequested = true;
    }
    if (infoObj.postObj.isPost && infoObj.postObj.isBtnStatic == null) {

    }
    else if (!docsObj.isOutputDirRequest) {
        fs.readdir(docsObj.outputPath, { withFileTypes: true }, function (err, dirents) {
            //handling error
            if (err) {
                docsObj.docsList = [];
            }
            else {
                docsObj.docsList = [];
                let foldersNames = dirents
                .filter(dirent => dirent.isDirectory())
                .map(dirent => dirent.name);
                for (let fdn = foldersNames.length - 1; fdn >= 0; fdn--) {
                    if (foldersNames[fdn].search(/ver\d\d/i) == 0) {
                        docsObj.docsList.push ({docName: foldersNames[fdn], docThumbs: null});
                        if (isToShowOnlyLastVersion) {
                            break; //to show only the last version
                        }
                    }
                }
                for (let dl = 0; dl < docsObj.docsList.length; dl++) {
                    fs.readdir(path.join (docsObj.outputPath, docsObj.docsList[dl].docName), function (err, files) {
                        //handling error
                        if (err) {
                            console.log('Unable to scan directory3: ' + err);
                        }
                        else {
                            let filesNames = [];
                            //listing all files using forEach
                            files.forEach(function (file) {
                                // Do whatever you want to do with the file
                                filesNames.push (file); 
                            });
                            for (let fln = filesNames.length - 1; fln >= 0; fln--) {
                                if (filesNames[fln][0] == '.') {
                                    filesNames.splice(fln, 1);
                                }
                            }
                            docsObj.docsList[dl].docThumbs = filesNames;
                        }
                    });
                }
            }
        });
        docsObj.isOutputDirRequest = true;
    }
    else if (docsObj.docsList != null) {
        if (!docsObj.isReadDone) {
            let isThumbsRequested = true;
            for (let dl = 0; dl < docsObj.docsList.length; dl++) {
                if (docsObj.docsList[dl].docThumbs == null) {
                    isThumbsRequested = false;
                    break;
                }
            }
            if (isThumbsRequested) {
                docsObj.isReadDone = true;
            }
        }
    }
    if (docsObj.isReadDone) {
        if (infoObj.urlEndMark.search (/Produced/i) == 0 && !infoObj.postObj.isPost && (docsObj.docsList.length == 0 || docsObj.docsList[0].docThumbs.length == 0)) {
            docsObj.isOutputDirRequest = false;
            docsObj.docsList = null;
            docsObj.isReadDone = false;
        }
        else if (infoObj.postObj.isPost) {
            if (infoObj.postObj.postType == "<Void>") {
                infoObj.postObj.isPostDone = true;
            }
            else if (infoObj.postObj.isRemoveDone && (docsObj.docsList.length == 0 || docsObj.docsList[0].docThumbs.length == 0)) {
                infoObj.postObj.isPostDone = true;
            }
            else {
                if (infoObj.postObj.isRemoveRequested === false) {
                    let isThereThumbsToRemove = false;
                    if (docsObj.docsList.length > 0) {
                        if (docsObj.docsList[0].docThumbs.length > 0) {
                            isThereThumbsToRemove = true;
                            for (let rr = 0; rr < docsObj.docsList[0].docThumbs.length; rr++) {
                                fs.unlink(path.join (docsObj.outputPath, docsObj.docsList[0].docName, docsObj.docsList[0].docThumbs[rr]), function (err) {
                                    if (err) throw err;
                                    infoObj.postObj.removedCount++;
                                });
                            }
                        }
                    }
                    if (isThereThumbsToRemove) {
                        infoObj.postObj.isRemoveRequested = true;
                    }
                    else {
                        infoObj.postObj.isRemoveRequested = null;
                    }
                }
                else if (infoObj.postObj.isRemoveRequested == null || infoObj.postObj.removedCount == docsObj.docsList[0].docThumbs.length) {
                    docsObj.isOutputDirRequest = false;
                    docsObj.docsList = null;
                    docsObj.isReadDone = false;
                    infoObj.postObj.isRemoveDone = true;
                    //trigger auto check in by renaming the file ts_key_..

                    let tsKeyNewFullName = infoObj.tsKeyFileName;
                    let tsKeyPhrase = infoObj.tsKeyFileName.match (/ts_key(_\w+)*/)[0];
                    tsKeyPhrase = tsKeyPhrase.split ("_");
                    let newNum = 0;
                    if (tsKeyPhrase.length > 2) {
                        let oldNum = parseInt (tsKeyPhrase[2], 10);
                        if (!isNaN(oldNum)) {
                            newNum = oldNum + 1;
                        }
                        tsKeyPhrase[2] = newNum;
                    }
                    else {
                        tsKeyPhrase.push (newNum);
                    }
                    tsKeyNewFullName = infoObj.tsKeyFileName.replace (/ts_key(_\w+)*/, tsKeyPhrase.join ("_"));

                    if (!infoObj.postObj.tsKey.isFact) {
                        fs.rename(path.join (infoObj.tsKeyFilePath, infoObj.tsKeyFileName), path.join (infoObj.postObj.mainPath, tsKeyNewFullName), function (err) {
                            if (err) throw err;
                            fs.rename(path.join (infoObj.tsKeyFilePath, thumbPortion1, infoObj.tsKeyFileName), path.join (infoObj.postObj.mainPath, thumbPortion1, tsKeyNewFullName), function (err) {
                                if (err) throw err;
                                let markFullName = path.relative(path.join (tsRoot, "Workshop"), path.join (infoObj.postObj.mainPath, tsKeyNewFullName));
                                markFullName = markFullName.split (path.sep).join ("  ");
                                let updateFileFullPath = path.join (tsRoot, ".Data", "Messages", "To Update", markFullName);
                                fs.writeFile(updateFileFullPath, "TS_Mark", function (err) {
                                    if (err) throw err;
                                });
                            });
                        });
                    }
                }
            }
        }
    }
    if (HTMLPage && docsObj.isReadDone && infoObj.postObj.isPostDone && infoObj.postObj.isFieldsDone && infoObj.postObj.isFieldsOutputted && infoObj.postObj.isFilesDone) {
        let removeWorkshop = infoObj.requrl;
        if (removeWorkshop.indexOf ("/Workshop/") == 0) {
            removeWorkshop = removeWorkshop.slice (9);
        }
        if (infoObj.postObj.isPost) { //docsObj.docsList.length != 0
            let reloadURL = "https://" + infoObj.hostName + removeWorkshop;
            let producingPart = '';
            if (!infoObj.postObj.isBtnStatic && infoObj.isThereInDesign) {
                producingPart = "Producing" ;
            }
            else if (infoObj.postObj.postType == "<Void>" && !infoObj.postObj.isBtnStatic && infoObj.isThereInDesign) {
                producingPart = "Done";
            }
            let urlEndMarkPart = "";
            if (infoObj.urlEndMark) {
                infoObj.urlEndMark = infoObj.urlEndMark.replace (/^(Producing|Produced|Done)/i, "");
                urlEndMarkPart = infoObj.urlEndMark;
                if (producingPart != '') {
                    urlEndMarkPart = producingPart + "&" + urlEndMarkPart;
                }
            }
            else {
                urlEndMarkPart = producingPart;
            }
            if (urlEndMarkPart != '') {
                reloadURL += "?" + urlEndMarkPart;
            }
            let reloadCall = locationReplaceHTML.replace ("***", reloadURL);
            res.writeHead(200, {'Content-Type' : 'text/html'});
            res.write(reloadCall);
            res.end();
            return true;
        }
        let htmlElements = '';
        let wholePage = '';
        wholePage = HTMLPage;
        if (infoObj.postObj.htmlFileContent != null) {
            wholePage = infoObj.postObj.htmlFileContent;
        }
        let pageThumbsElements = '<TS_Thumbs>';
        let previewTHumb = '';
        let previewMockupTHumb = '';
        for (let dl = 0; dl < docsObj.docsList.length; dl++) {
            let docCls = '';
            let tsDocParams = docsObj.docsList[dl].docName.match (/(\s?)(ts)(_\w+)+/g);
            if (tsDocParams) {
                for (let tsp = 0; tsp < tsDocParams.length; tsp++) {
                    tsDocParams[tsp] = tsDocParams[tsp].split ("_");
                }
                for (let tsp = 0; tsp < tsDocParams.length; tsp++) {
                    if (tsDocParams[tsp].length > 1) {
                        if (tsDocParams[tsp][1] == "col" && tsDocParams[tsp].length > 2) {
                            docCls = parseInt (tsDocParams[tsp][2], 10);
                            if (docCls != null && docCls > 0) {
                                docCls = ' style="grid-template-columns: repeat(' + docCls + ', 1fr)"';
                            }
                            else {
                                docCls = '';
                            }
                        }
                    }
                }
            }
            
            if (docsObj.docsList[dl].docThumbs.length) {
                pageThumbsElements += '<div class="docCon">';
                pageThumbsElements += '<div class="docTitleCon">';
                let flagsIndex = -1;
                for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                    if (infoObj.postObj.tsKey.code[isc].length == 1 && infoObj.postObj.tsKey.code[isc][0] != "") {
                        flagsIndex = isc;
                        break;
                    }
                }
                if (flagsIndex == -1 || infoObj.postObj.tsKey.code[flagsIndex][0].search (/<No_PDF>/i) == -1) {
                    let pdfURL = getPDFURL (infoObj.hostName, docsObj.outputPath, docsObj.docsList[dl].docName);
                    pageThumbsElements += '<div class="w3-teal w3-padding-16 w3-margin-bottom"><a href="' + pdfURL + '" class="fa fa-file-pdf-o" style="width: 100%; font-size:36px; margin:auto;">';
                    pageThumbsElements += '</a></div>'; //end of doc name div
                }
                pageThumbsElements += '<div class="w3-row w3-text-teal"><b style="font-size:16px; writing-mode: vertical-lr; transform: rotate(360deg);">' + getPureDisplayName (docsObj.docsList[dl].docName.slice (6) + ".indd") + '</b></div>';      
                pageThumbsElements += '<div class="w3-center w3-padding-16"></div>';
                pageThumbsElements += '</div>';
                pageThumbsElements += '<div class="pagesCon"' + docCls + '>';
                for (let dt = 0; dt < docsObj.docsList[dl].docThumbs.length; dt++) {
                    if (docsObj.docsList[dl].docThumbs[dt].slice (-4) == '.psd') {
                        continue;
                    }
                    if (flagsIndex != -1) {
                        if (docsObj.docsList[dl].docThumbs[dt].slice (-4) == '.png' && infoObj.postObj.tsKey.code[flagsIndex][0].search (/<No_PNG>/i) != -1) {
                            continue;
                        }
                        if (docsObj.docsList[dl].docThumbs[dt].slice (-4) == '.gif' && infoObj.postObj.tsKey.code[flagsIndex][0].search (/<No_GIF>/i) != -1) {
                            continue;
                        }
                        if (docsObj.docsList[dl].docThumbs[dt].slice (-4) == '.jpg' && infoObj.postObj.tsKey.code[flagsIndex][0].search (/<No_JPG>/i) != -1) {
                            continue;
                        }
                    }
                    let imageFileURL = getImageFileURL (infoObj.hostName, path.join (docsObj.outputPath, docsObj.docsList[dl].docName, docsObj.docsList[dl].docThumbs[dt]));
                    if (previewTHumb == '') {
                        previewTHumb = imageFileURL;
                    }
                    if (previewMockupTHumb == '' && docsObj.docsList[dl].docThumbs[dt].search (/Mockup/i) != -1) {
                        previewMockupTHumb = imageFileURL;
                    }
                    let toDownloadImageName = docsObj.docsList[dl].docName.slice (6) + '.' + docsObj.docsList[dl].docThumbs[dt];
                    pageThumbsElements += '<div class="pageThumb" onclick="openPageModel(this)"><img class="pageImage" src="' + imageFileURL + '" data-downname="' + toDownloadImageName + '"></div>';
                }
                pageThumbsElements += '</div>'; //end of pages div
                pageThumbsElements += '</div>'; //end of docCon
            }
        }
        if (previewMockupTHumb) {
            wholePage = wholePage.replace (/<TS_Preview>/i, previewMockupTHumb);
        }
        else if (previewTHumb) {
            wholePage = wholePage.replace (/<TS_Preview>/i, previewTHumb);
        }
        if (pageThumbsElements != '<TS_Thumbs>') {
            pageThumbsElements = pageThumbsElements.replace (/<TS_Thumbs>/i, '');
            let topThumbs = '<div class="docsCon">';
            pageThumbsElements = topThumbs + pageThumbsElements;
            let bottomThumbs = '</div>';
            pageThumbsElements += bottomThumbs;
        }
        wholePage = wholePage.replace (/<TS_Thumbs>/i, pageThumbsElements);
        let isThereEditBtn = true;
        if (pageThumbsElements || infoObj.urlEndMark.search (/Producing/i) != 0) {
            let btns = '';
            let currentBasicMainOption = basicMainOption;
            for (let isc = 0; isc < infoObj.postObj.tsKey.code.length; isc++) {
                if (infoObj.postObj.tsKey.code[isc][0] == "")
                    continue;
                if (infoObj.postObj.tsKey.code[isc].length == 1) {
                    if (infoObj.postObj.tsKey.code[isc][0].length > 0) {
                        currentBasicMainOption = currentBasicMainOption.replace ("<TS_FLAGS>", infoObj.postObj.tsKey.code[isc][0].replace(/</g, '_trsd_sep_').replace(/>/g, ''));
                    }
                    else {
                        currentBasicMainOption = currentBasicMainOption.replace ("<TS_FLAGS>", "");
                    }
                    continue;
                }
                if (infoObj.postObj.tsKey.code[isc].length > 2 && (infoObj.postObj.tsKey.code[isc][2] == '0' || infoObj.postObj.tsKey.code[isc][2].indexOf ('?') != -1)) {
                    continue;
                }
                if (infoObj.postObj.tsKey.code[isc].length > 1 && infoObj.postObj.tsKey.code[isc][1].search (/<a>/i) != -1) {
                    let href = "https://" + solveRelative (infoObj.postObj.tsKey.code[isc][1].replace (/<a>/i, ''), infoObj.hostName + removeWorkshop);
                    let btnVal = infoObj.postObj.tsKey.code[isc][0];
                    btns +=  '<a href="' + href + '" style="text-decoration:none">' + '<div class="w3-button w3-teal" style="margin-left: 16px;" target="_blank">' + btnVal + '</div></a>';
                }
                else if (infoObj.postObj.tsKey.code[isc].length > 1 && infoObj.postObj.tsKey.code[isc][1].search (/<Whatsapp>/i) == 0) {
                    let phoneNumber = infoObj.postObj.tsKey.code[isc][1].replace (/<Whatsapp>/i, '');
                    let whatsappProductURL = "https://" + infoObj.hostName + removeWorkshop;
                    let whatsappurl = 'https://wa.me/' + phoneNumber + '/?text=' + whatsappProductURL;
                    let btnVal = infoObj.postObj.tsKey.code[isc][0];
                    btns +=  '<a href="' + whatsappurl + '" style="text-decoration:none">' + '<div class="w3-button w3-teal" style="margin-left: 16px;" target="_blank">' + btnVal + '</div></a>';
                }
                else {
                    let dataVoidPart = '';
                    if (infoObj.postObj.tsKey.code[isc].length > 1 && infoObj.postObj.tsKey.code[isc][1].indexOf ("<Void>") != -1) {
                        dataVoidPart = ' data-void="yes"';
                    }
                    else {
                        isThereEditBtn = true;
                    }
                    let btnVal = infoObj.postObj.tsKey.code[isc][0];
                    btns +=  '<div class="w3-button w3-teal downButton" onclick="goSubmit(this)" style="margin-left: 16px;"' + dataVoidPart + '>' + btnVal + '</div>';  
                }
            }
            if (isThereEditBtn) {
                htmlElements += currentBasicMainOption;
            }
            wholePage = wholePage.replace ("<TS_Buttons>", btns);
        }
        else {
            wholePage = wholePage.replace ("<TS_Buttons>", '');
        }
        wholePage = wholePage.replace ("<TS_Fields>", htmlElements);
        if (infoObj.postObj.tsKey.keyFileID != null) {
            let thePara = infoObj.urlEndMark;
            if (thePara) {
                thePara = "?" + thePara;
            }
            let theCommandStr = "history.replaceState ( {} , " + "'" + infoObj.requrl.replace (/\//g, " ") + "', '" + infoObj.requrl.replace ("/Workshop/", "/") + thePara + "');";
            wholePage = wholePage.replace ("//<TS_KEYPATH_REPLACESTATE>", theCommandStr);
        }
        res.writeHead(200, {'Content-Type' : 'text/html'});
        res.write(wholePage);
        res.end();
        return true;
    }
    else {
        let intervalTime = 100;
        if (infoObj.postObj.isPostDone) {
            intervalTime = 100;
        }
        setTimeout (getLooping, intervalTime, res, docsObj, infoObj);
        return false;
    }
}

function solveRelative (toSolvePath, rootPath) {
    let extraDotsCount = -1;
    while (toSolvePath.length > 0 && toSolvePath[0] == '.') {
        extraDotsCount++;
        toSolvePath = toSolvePath.slice (1);
    }
    if (extraDotsCount != -1) {
        if (rootPath.length > 0 && rootPath[rootPath.length - 1] == '/') {
            rootPath = rootPath.slice (0, -1);
        }
        for (let c = 0; c < extraDotsCount; c++) {
            if (rootPath.indexOf ('/') != -1) {
                rootPath = rootPath.slice (0, rootPath.lastIndexOf ('/'));
            }
        }
        toSolvePath = rootPath + toSolvePath;
    }
    return toSolvePath;
}

function generateNumericHash(str) {
  let hash = 0;
  
  // Iterate over each character in the string
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i); // Get the Unicode value of the character
    hash = (hash * 31 + char) % 10000000000; // Modulo keeps it within a reasonable range (10 digits)
  }

  // Ensure the hash is positive and return as a numeric string
  return Math.abs(hash).toString();
}

function getPDFURL (hostName, portion, fileName) {
    if (isOutputToWorkshop) {
        if (fileName.indexOf ("ver00") == 0) {
            fileName.replace ("ver00", "ver01");
        }
    }
    let relativePath = path.relative (tsRoot, portion);
    let slashPortion = relativePath.split (path.sep).join ("/");
    if (slashPortion.indexOf ("D:/") == 0) {
        slashPortion = slashPortion.slice (2);
    }
    let pdfURL = "";
    if (isOutputToWorkshop) {
        slashPortion = slashPortion.replace ("Pages/Versions/", "Workshop/");
    }
    else {
        slashPortion = slashPortion.replace ("Pages/Versions/", "Versions PDFs/");
    }
    pdfURL = "https://" + hostName + "/" + slashPortion + "/" + fileName + ".pdf";
    return pdfURL;
}

function getThumb (filePath, fileName, fileExtension) {
    if (isOutputToWorkshop && fileExtension == '.txt') {
        return path.join(filePath, fileName + fileExtension + '.jpg');
    }
    else {
        return path.join(filePath, thumbPortion1, thumbPortion2, fileName + fileExtension + '.jpg');
    }
}

function getThumbURL (hostName, filePath, fileName, fileExtension) {
    let relativePath = path.relative (tsRoot, filePath);
    let slashPortion = relativePath.split (path.sep).join ("/");
    if (isOutputToWorkshop && fileExtension == '.txt') {
        return "https://" + hostName + "/" + slashPortion + '/' + fileName + fileExtension + '.jpg';
    }
    else {
        return "https://" + hostName + "/" + slashPortion + '/' + thumbPortion1 + '/' + thumbPortion2 + '/' + fileName + fileExtension + '.jpg';
    }
}

function getImageFileURL (hostName, filePath) {
    let relativePath = path.relative (tsRoot, filePath);
    let slashPortion = relativePath.split (path.sep).join ("/");
    let returned = "https://" + hostName + "/" + slashPortion;
    returned = encodeURI (returned);
    return returned;
}

function getOutputPath (requrl) {
    if (isOutputToWorkshop) {
        return path.join(tsRoot , requrl);
    }
    else {
        let returnedVal = requrl.replace ("Workshop", "Pages" + path.sep + "Versions");
        return path.join(tsRoot , returnedVal);
    }
}

function sendForm (mainPath, requrl, urlEndMark, hostName, res, postData) {
    if (!HTMLPage) {
        fs.readFile(path.join(tsRoot, "Interface", "http-form.html"), 'UTF-8', (err, data) => {
            if(err) throw err;
            HTMLPage = data;
            fs.writeFile (path.join(tsRoot, ".Data", "HOSTNAME.txt"), hostName, function (err) {
                if (err) console.log('Error in writing hostname2: ' + err);;
            });
        });
    }
    fs.readdir(mainPath, { withFileTypes: true }, function (err, dirents) {
        //handling error
        if (err) {
            let requrlSplitted = (requrl.indexOf ("/Workshop/") == 0)? requrl.replace ("/Workshop/", "/") : requrl;
            requrlSplitted = requrlSplitted.split ("/");
            if (requrlSplitted[requrlSplitted.length-1] == '') {
                requrlSplitted.splice (requrlSplitted.length - 1, 1);
            }
            if (requrlSplitted.length > 1) {
                requrlSplitted.splice (requrlSplitted.length - 1, 1);
            }
            let stepBackRequrl = requrlSplitted.join ("/");
            let domainURL = "https://" + hostName + stepBackRequrl;
            domainURL += urlEndMark ? ('?' + urlEndMark) : '';
            let reloadCall = locationReplaceHTML.replace ("***", domainURL);
            res.write(reloadCall);
            res.end();
        }
        else {
            let filesNames = dirents
            .filter(dirent => dirent.isFile())
            .map(dirent => dirent.name);

            let docsObj = [];

            let infoObj = {treeShadeSortFilePath: null, treeShadeSortContent: null, tsKeyFilePath: null, tsKeyFileName: null, isThereInDesign: false, postObj: postData, hostName: hostName, requrl: requrl, urlEndMark: urlEndMark};
            if (infoObj.requrl != "/favicon.ico" && infoObj.requrl.indexOf ("/Workshop/") != 0 && infoObj.requrl.indexOf ("/Pages/Versions/") != 0) {
                infoObj.requrl = "/Workshop" + infoObj.requrl;
            }

            let isTSKeyFileExist = false;
            let localFormName = "";
            let indexName = "";
            let urlEndMarkSplitted = urlEndMark.split ("&");
            let keyPass = '';
            let firstKeyFileWithoutPass = null;
            for (let uem = 0; uem < urlEndMarkSplitted.length; uem++) {
                let keyValue = urlEndMarkSplitted[uem].split ("=");
                if (keyValue.length > 1 && keyValue[0].search (/^pass$/i) == 0) {
                    keyPass = keyValue[1];
                    break;
                }
            }
            for (let fln = filesNames.length - 1; fln >= 0; fln--) {
                if (filesNames[fln].slice (-5) == ".indd") {
                    if (filesNames[fln].search (/ts_hdn/i) == -1) {
                        infoObj.isThereInDesign = true;
                    }
                }
                if (filesNames[fln].indexOf ("ts_key") != -1) {
                    let isPassed = false;
                    let filePass = filesNames[fln].match (/ts_key(_\w+)*/)[0];
                    filePass = filePass.split ("_");
                    if (keyPass != '') {
                        if (filePass.length > 3) {
                            if (filePass[3] == keyPass) {
                                isPassed = true;
                            }
                        }
                        else {
                            firstKeyFileWithoutPass = filesNames[fln];
                        }
                    } else if (filePass.length <= 3) {
                        isPassed = true;
                    }
                    if (isPassed) {
                        infoObj.tsKeyFilePath = mainPath;
                        infoObj.tsKeyFileName = filesNames[fln];
                        isTSKeyFileExist = true;
                        infoObj.postObj.tsKey.isFact = true;
                    }
                }
                else if (filesNames[fln] == "http-form.html") {
                    localFormName = filesNames[fln];
                }
                else if (filesNames[fln].search (/index/i) != -1) {
                    indexName = filesNames[fln];
                }
            }
            if (!infoObj.postObj.tsKey.isFact && firstKeyFileWithoutPass) {
                infoObj.tsKeyFilePath = mainPath;
                infoObj.tsKeyFileName = firstKeyFileWithoutPass;
                isTSKeyFileExist = true;
                infoObj.postObj.tsKey.isFact = true;
            }
            let isToRespond = false;
            if (infoObj.postObj.htmlFileName == null) {
                if (localFormName != "") {
                    infoObj.postObj.htmlFileName = localFormName;
                }
                if (!isTSKeyFileExist) {
                    if (indexName != "") {
                        let requrlWithIndexFile = requrl;
                        if (requrl.search (/\/$/) == -1) {
                            requrlWithIndexFile += "/";
                        }
                        requrlWithIndexFile = requrlWithIndexFile + indexName;
                        let domainURL = "https://" + infoObj.hostName + requrlWithIndexFile.replace ("/Workshop/", "/");
                        domainURL += urlEndMark ? ('?' + urlEndMark) : '';
                        let reloadCall = locationReplaceHTML.replace ("***", domainURL);
                        res.writeHead(200, {'Content-Type' : 'text/html'});
                        res.write(reloadCall);
                        res.end();
                        return false;
                    }
                }
            }
            if (isTSKeyFileExist) {
                isToRespond = true;
            }
            else if (infoObj.postObj.htmlFileName != null) {
                isToRespond = true;
            }
            let actualPath = getActualCasePath(mainPath);
            let isRightURLCase = true;
            if (actualPath !== mainPath) {
                let relativePath = path.relative(tsRoot, actualPath)
                    .split(path.sep)
                    .join('/');
                isRightURLCase = false;
                requrl = '/' + relativePath;
            }
            if (isToRespond && isRightURLCase) {
                let theOutPath = getOutputPath (infoObj.requrl);
                docsObj = {outputPath: theOutPath, isOutputDirRequest: false, docsList: null, isReadDone: false};
                setTimeout(getLooping, 100, res, docsObj, infoObj);
            }
            else {
                if (requrl != "/Workshop/" && requrl != "/Workshop") {
                    let requrlSplitted = (requrl.indexOf ("/Workshop/") == 0)? requrl.replace ("/Workshop/", "/") : requrl;
                    requrlSplitted = requrlSplitted.split ("/");
                    if (requrlSplitted[requrlSplitted.length-1] == '') {
                        requrlSplitted.splice (requrlSplitted.length - 1, 1);
                    }
                    if (requrlSplitted.length > 1 && !isToRespond) {
                        requrlSplitted.splice (requrlSplitted.length - 1, 1);
                    }
                    let stepBackRequrl = requrlSplitted.join ("/");
                    let domainURL = "https://" + infoObj.hostName + stepBackRequrl;
                    domainURL += urlEndMark ? ('?' + urlEndMark) : '';
                    let reloadCall = locationReplaceHTML.replace ("***", domainURL);
                    res.writeHead(200, {'Content-Type' : 'text/html'});
                    res.write(reloadCall);
                    res.end();
                }
                else {
                    res.writeHead(400, {'Content-Type' : 'text/html'});
                    res.end();
                }
            }
        }
    });
}

function getActualCasePath (fullPath) {
    if (!fullPath.startsWith(tsRoot)) return null;

    let relPath = path.relative(tsRoot, fullPath);
    let parts = relPath.split(path.sep);
    let currentPath = tsRoot;

    for (let part of parts) {
        if (!fs.existsSync(currentPath)) return null;
        let dirents = fs.readdirSync(currentPath, { withFileTypes: true });
        let match = dirents.find(d => d.name.toLowerCase() === part.toLowerCase());
        if (!match) return null;
        currentPath = path.join(currentPath, match.name);
    }

    return currentPath;
}

function getPureName (pureName, isToRemoveID) {
    if (pureName.indexOf (".") != -1) {
        pureName = pureName.slice (0, pureName.lastIndexOf ("."));
    }
    let testName = pureName;
    testName = pureName.replace (/\s*\[[^\]]*\]\s*/g, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    testName = pureName.replace (/(\s?)(ts)(_\w+)+/g, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    if (isToRemoveID) {
        testName = pureName.replace (/^ID[A-Z0-9]+\s*/, "");
        if (testName == '') {
            return pureName;
        }
        else {
            pureName = testName;
        }
    }
    testName = pureName.replace (/^-\s*/, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    return pureName;
}

function getPureDisplayName (pureName) {
    if (pureName.indexOf (".") != -1) {
        pureName = pureName.slice (0, pureName.lastIndexOf ("."));
    }
    let testName = pureName;
    testName = pureName.replace (/(\s?)(ts)(_\w+)+/g, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    testName = pureName.replace (/^ID[A-Z0-9]+\s*/, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    if (testName.search (/\[[^\[\]]+\]$/) != -1) {
        testName = testName.match (/\[[^\[\]]+\]$/)[0].slice (1, -1);
        if (testName != '') {
            return testName;
        }
        else {
            testName = pureName;
        }
    }
    testName = pureName.replace (/\s*\[[^\]]*\]\s*/g, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    testName = pureName.replace (/^-\s*/, "");
    if (testName == '') {
        return pureName;
    }
    else {
        pureName = testName;
    }
    return pureName;
}

function solveTags (HTMLText) {
    HTMLText = HTMLText.replace (/>/g, "&gt;");
    HTMLText = HTMLText.replace (/</g, "&lt;");
    return HTMLText;
}

function resolveTags (HTMLText) {
    HTMLText = HTMLText.replace (/&gt;/g, ">");
    HTMLText = HTMLText.replace (/&lt;/g, "<");
    return HTMLText;
}

function regexToNormalText(regexStr) {
    let isEscaped = false;
    let stack = [[]];
    const regexShorthandMap = {
        'w': 'a', 'd': '0', 's': ' ', 'W': '#', 'D': 'X', 'S': '_',
        't': ' ', 'n': ' ', 'r': ' ', 'b': ''
    };
    for (let i = 0; i < regexStr.length; i++) {
        let char = regexStr[i];
        if (char === '\\') {
            isEscaped = true;
            continue;
        }
        if (isEscaped) {
            stack[stack.length - 1].push(regexShorthandMap[char] || char);
            isEscaped = false;
            continue;
        }
        if (char === '(') {
            stack.push([]);
            continue;
        }
        if (char === '|') {
            continue;
        }
        if (char === ')') {
            let groupContent = stack.pop().join('');
            groupContent = groupContent.split('|')[0]; // Keep first option
            stack[stack.length - 1].push(groupContent);
            continue;
        }
        if (char === '[') {
            let closing = regexStr.indexOf(']', i);
            if (closing !== -1) {
                i = closing; // Skip group
            }
            continue;
        }
        if (char === '{') {
            let closing = regexStr.indexOf('}', i);
            if (closing !== -1) {
                i = closing; // Skip quantifier
            }
            continue;
        }
        if (char === '?' || char === '*') {
            let group = stack[stack.length - 1];
            if (group.length > 0) group.pop();
            continue;
        }
        if (char === '.') {
            let nextChar = regexStr[i + 1];
            if (nextChar === '*' || nextChar === '+') {
                stack[stack.length - 1].push('_');
                continue;
            } else {
                stack[stack.length - 1].push('.');
                continue;
            }
        }
        if (/[{}^$]/.test(char)) {
            continue;
        }
        stack[stack.length - 1].push(char);
    }
    return stack[0].join('');
}


function removeQueryParameter (url, parameter) {
    const urlObj = new URL(url);
    urlObj.searchParams.delete(parameter);
    return urlObj.toString();
}

function filterOut(flags, fileName) {
    const parts = flags.split('_trsd_sep_');
    for (const part of parts) {
        if (part.search (/filter\//i) === 0) {
            const regexStr = part.slice(7);
            const regex = new RegExp(regexStr, 'i');
            if (!regex.test(fileName)) {
                return true;
            }
        }
    }
    return false;
}

function isThereFilter (flags) {
    const parts = flags.split('_trsd_sep_');
    for (const part of parts) {
        if (part.search (/filter\//i) === 0) {
            return true;
        }
    }
    return false;
}

function sendOptionData (res, optionSubmit) {
    if (optionSubmit.isAllReadDone) {
        return false;
    }
    optionSubmit.counter++;
    if (optionSubmit.filesList == null) {
        if (!optionSubmit.isReadDirRequest) {
            optionSubmit.isReadDirRequest = true;
            let optionPathSplitted = optionSubmit.code.split ("_trsd_option_sep_");
            if (optionPathSplitted.length > 2) {
                let callerSplitted = optionPathSplitted[0].slice (3).replace (/_space_/g, " ").replace(/_dot_/g, '.').split ("_slash_");
                if (callerSplitted.length > 0) {
                    callerSplitted[callerSplitted.length - 1] = getPureName (callerSplitted[callerSplitted.length - 1], false);
                }
                optionSubmit.callerName = callerSplitted.join (path.sep);
                optionSubmit.optionName = optionPathSplitted[2].replace (/_space_/g, " ").replace(/_dot_/g, '.');
                if (optionSubmit.optionName.indexOf (".") != -1) {
                    optionSubmit.optionName = optionSubmit.optionName.slice (0, optionSubmit.optionName.lastIndexOf ("."));
                }
                optionSubmit.optionRealPath = optionPathSplitted[1].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                if (!optionSubmit.isFakePaired) {
                    if (optionSubmit.optionPath == "") {
                        optionSubmit.optionPath = optionSubmit.optionRealPath;
                    }
                    else {
                        optionSubmit.optionPath = path.join (optionSubmit.optionPath, optionSubmit.pairedFolder);
                        optionSubmit.pairedFolder = optionSubmit.optionName;
                    }
                }
            }
            let pairedIsWithOptions = false;
            if (optionSubmit.pairedFolder == "" && !optionSubmit.isFakePaired) {
                optionSubmit.pairedFolder = optionSubmit.optionName;
            }
            if (!pairedIsWithOptions) {
                fs.readdir(path.join (tsRoot, "Workshop", optionSubmit.optionPath, optionSubmit.pairedFolder), { withFileTypes: true }, function (err, filesAndFolders) {
                    //handling error
                    if (err) {
                        optionSubmit.filesList = [];
                        optionSubmit.treeShadeSortContent = '';
                    }
                    else {
                        //listing all files using forEach
                        optionSubmit.plainList = [];
                        let filesNames = filesAndFolders
                        .filter(filesAndFolders => filesAndFolders.isFile())
                        .map(filesAndFolders => filesAndFolders.name);
                        let foldersNames = filesAndFolders
                        .filter(filesAndFolders => filesAndFolders.isDirectory())
                        .map(filesAndFolders => filesAndFolders.name);
                        let isTreeShadeSort = false;
                        for (let fln = 0; fln < filesNames.length; fln++) {
                            if (filesNames[fln] == 'ts_sort.txt') {
                                isTreeShadeSort = true;
                            }
                            else if (filesNames[fln][0] == '.' || filesNames[fln].slice(-8) == ".txt.jpg" || 
                                     filesNames[fln].slice (-5) == ".idlk" || filesNames[fln].slice (-4) == ".tmp" || 
                                     filesNames[fln].slice (-4) == ".lst" || filesNames[fln].slice(0, 2) == "~$") {
                            }
                            else if (filesNames[fln].slice (-5) == ".indd" && filesNames[fln].search (/^ID[A-Z0-9]+/) == -1 && filesNames[fln].indexOf ("ts_opt") == -1 && filesNames[fln].indexOf ("ts_shw") == -1) {
                            }
                            else {
                                optionSubmit.plainList.push ({isFolder: false, folderType: '', name: filesNames[fln], pairedName: '', pairedOptions: ''});
                            }
                        }
                        for (let fdn = 0; fdn < foldersNames.length; fdn++) {
                            if (foldersNames[fdn].search(/ver\d\d /i) == 0 || foldersNames[fdn].indexOf ("untitled folder") == 0 || foldersNames[fdn][0] == '.') {
                            }
                            else {
                                optionSubmit.plainList.push ({isFolder: true, folderType: '', name: foldersNames[fdn], pairedName: '', pairedOptions: ''});
                            }
                        }
                        if (isTreeShadeSort) {
                            let readFullPath = path.join (tsRoot, "Workshop", optionSubmit.optionPath, optionSubmit.pairedFolder, 'ts_sort.txt');
                            function textHandler (err, data) {
                                if(err) {
                                    optionSubmit.treeShadeSortContent = '';
                                    console.log ("err=" + err);
                                }
                                else {
                                    if (err == null) {
                                        addFileContent (readFullPath, filesCache, data);
                                    }
                                    optionSubmit.treeShadeSortContent = data;
                                }
                            }
                            let testedContent = getFileContent (readFullPath, filesCache);
                            if (testedContent != null) {
                                textHandler (false, testedContent);
                            }
                            else {
                                fs.readFile (readFullPath, 'UTF-8', textHandler);
                            }
                        }
                        else {
                            optionSubmit.treeShadeSortContent = '';
                        }
                    }
                });
            }  
        }
        else if (optionSubmit.plainList != null && optionSubmit.treeShadeSortContent != null) {
            optionSubmit.filesList = [];
            //building optionSubmit.filesList
            //sort
            if (optionSubmit.treeShadeSortContent != '') {
                let sortList = '';
                if (optionSubmit.treeShadeSortContent.indexOf ('\r\n') != -1) {
                    sortList = optionSubmit.treeShadeSortContent.split ('\r\n');
                }
                else {
                    sortList = optionSubmit.treeShadeSortContent.split ('\n');
                }
                if (sortList) {
                    let sortIndex = 0;
                    for (let sl = 0; sl < sortList.length; sl++) {
                        let pureFileName = sortList[sl];
                        for (let aui = sortIndex; aui < optionSubmit.plainList.length; aui++) {
                            /*if (optionSubmit.plainList[aui].isFolder) {
                                continue;
                            }*/
                            let toCompareName = optionSubmit.plainList[aui].name;
                            if (!optionSubmit.plainList[aui].isFolder) {
                                toCompareName = getPureName (toCompareName, false);
                            }
                            if (toCompareName == pureFileName) {
                                if (aui != sortIndex) {
                                    let swapCell = optionSubmit.plainList[aui];
                                    optionSubmit.plainList[aui] = optionSubmit.plainList[sortIndex];
                                    optionSubmit.plainList[sortIndex] = swapCell;
                                }
                                sortIndex++;
                                break;
                            }
                        }
                    }
                }
            }
            for (let cc = optionSubmit.plainList.length - 1; cc >= 0; cc--) {
                if (!optionSubmit.plainList[cc].isFolder) {
                    let targetName = optionSubmit.plainList[cc].name;
                    targetName = getPureName (targetName, false);
                    for (let c = optionSubmit.plainList.length - 1; c >= 0; c--) {
                        if (optionSubmit.plainList[c].isFolder) {
                            let folderPureName = getPureName (optionSubmit.plainList[c].name, false);
                            if (optionSubmit.plainList[c].name.search (/Options$/i) != -1) {
                                optionSubmit.plainList[c].folderType = 'options';
                                if (targetName.indexOf (optionSubmit.plainList[c].name.replace (/[\s\.\-\]\)_]*Options$/i, '')) != -1) {
                                    optionSubmit.plainList[cc].pairedOptions = optionSubmit.plainList[c].name;
                                }
                            }
                            else if (targetName.indexOf (folderPureName) != -1) {
                                optionSubmit.plainList[cc].pairedName = optionSubmit.plainList[c].name;
                                optionSubmit.plainList[c].pairedName = optionSubmit.plainList[cc].name;
                                optionSubmit.plainList[c].folderType = 'paired';
                            }
                        }
                    }
                }
            }
            for (let c = optionSubmit.plainList.length - 1; c >= 0; c--) {
                if (optionSubmit.plainList[c].isFolder && optionSubmit.plainList[c].folderType == 'options') {
                    optionSubmit.plainList.splice (c, 1);
                }
            }
            for (let c = 0; c < optionSubmit.plainList.length; c++) {
                let ext = path.extname(optionSubmit.plainList[c].name);
                let baseName = path.basename(optionSubmit.plainList[c].name, ext);
                let fileObj = {filePath: path.join (tsRoot, "Workshop", optionSubmit.optionPath), 
                                subKeyIndex: -1, 
                                subPreviewTHumb: '', docThumb: '',
                                folderKeyName: '', 
                                fileParent: optionSubmit.pairedFolder, 
                                fileName: baseName, 
                                fileExtension: ext, 
                                textContent: '', 
                                needToBeRead: false, 
                                readIsDone: false, 
                                optionsStage: 0, 
                                optionsRoot: "", 
                                optionsRoots: [], 
                                optionsDefault: "", 
                                pairedName: optionSubmit.plainList[c].pairedName, 
                                defaultPaired: '', 
                                pairedOptions: optionSubmit.plainList[c].pairedOptions, 
                                optionsList: [], 
                                isFolder: optionSubmit.plainList[c].isFolder, 
                                isHidden: false,
                                isReadOnly: false,
                                isReadOnlyAlone: false,
                                isConditionalShow: false,
                                isHTMLOutput: false,
                                subDocsList: null, optionsPaireds: [], 
                                pairedFolder: "", 
                                isVirtual: false, 
                                treeShadeSortContent: null, 
                                optionsTxtContents: [],
                                fileID: null,
                                invalidPreviousID: null,
                                docsPlacesList: null,
                                docsPlacesListRequestStage: 0};
                if (fileObj.isFolder || (fileObj.fileExtension == '.txt' && fileObj.fileName.search (/ts_upld/) == -1) || fileObj.fileName.search (/ts_txt/) != -1) {
                    fileObj.needToBeRead = true;
                }
                else {
                    fileObj.readIsDone = true;
                }
                if (optionSubmit.plainList[c].pairedName) {
                    let defaultForge = path.join (optionSubmit.optionPath, optionSubmit.pairedFolder);
                    defaultForge = defaultForge.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_");
                    fileObj.defaultPaired = defaultForge + "_trsd_sep_" + optionSubmit.plainList[c].pairedName.replace(/ /g, '_space_').replace(/\./g, '_dot_');
                }
                //!fileObj.isFolder, not remove folders for now 
                let isFilteredOut = filterOut (optionSubmit.flags, optionSubmit.plainList[c].name);
                if (!isFilteredOut) {
                    optionSubmit.filesList.push (fileObj);
                }
            }
            //settings for options files
            for (let fsl = 0; fsl < optionSubmit.filesList.length; fsl++) {
                if (!optionSubmit.filesList[fsl].isFolder && optionSubmit.filesList[fsl].fileName.match (/ts_opt/)) { //may in future we include folders as an options entries
                    optionSubmit.filesList[fsl].optionsStage = 1;
                    optionSubmit.filesList[fsl].readIsDone = false;
                }
            }
        }
        setTimeout(sendOptionData, 300, res, optionSubmit);
    }
    if (optionSubmit.filesList != null) {
        for (let i = 0; i < optionSubmit.filesList.length; i++) {
            if (!optionSubmit.filesList[i].isFolder) {
                if (optionSubmit.filesList[i].fileID == null) {
                    optionSubmit.filesList[i].fileID = '';
                    let shadeFullPath = path.join(optionSubmit.filesList[i].filePath.replace ("Workshop", ".Data" + path.sep + "Shades") , optionSubmit.filesList[i].fileParent, optionSubmit.filesList[i].fileName + optionSubmit.filesList[i].fileExtension);
                    function shadeHandler (err, idFileContent) {
                        if(err) {
                            optionSubmit.filesList[i].fileID = false;
                        }
                        else {
                            if (err == null) {
                                addFileContent (shadeFullPath, shadesCache, idFileContent);
                            }
                            let idFileContentSplitted = idFileContent.split (":");
                            if (idFileContentSplitted.length > 1) {
                                optionSubmit.filesList[i].fileID = idFileContentSplitted[1];
                                optionSubmit.filesList[i].invalidPreviousID = idFileContentSplitted[1];
                            }
                            else {
                                optionSubmit.filesList[i].fileID = false;
                            }
                        }
                    }
                    let shadeContent = getFileContent (shadeFullPath, shadesCache);
                    if (shadeContent != null) {
                        shadeHandler (false, shadeContent);
                    }
                    else {
                        fs.readFile(shadeFullPath, 'UTF-8', shadeHandler);
                    }
                }
                else if (optionSubmit.filesList[i].fileID) {
                    if (optionSubmit.filesList[i].docsPlacesListRequestStage == 0) {
                        optionSubmit.filesList[i].docsPlacesListRequestStage = 1;
                        //read folderContent
                        fs.readdir(path.join (tsRoot, ".Data", "IDs", optionSubmit.filesList[i].fileID.slice (1), "Workshop", "Places"), { withFileTypes: true }, function (err, dirents) {
                            //handling error
                            if (err) {
                                optionSubmit.filesList[i].docsPlacesListRequestStage = 2;
                                optionSubmit.filesList[i].docsPlacesList = [];
                            }
                            else {
                                optionSubmit.filesList[i].docsPlacesListRequestStage = 2;
                                optionSubmit.filesList[i].docsPlacesList = [];
                                let filesNames = dirents
                                .filter(dirent => dirent.isFile())
                                .map(dirent => dirent.name);
                                for (let fln = 0; fln < filesNames.length; fln++) {
                                    let docPlaceObj = {name: filesNames[fln], content: null};
                                    optionSubmit.filesList[i].docsPlacesList.push (docPlaceObj);
                                    let docPlaceFullPath = path.join(tsRoot, ".Data", "IDs", optionSubmit.filesList[i].fileID.slice (1), "Workshop", "Places", docPlaceObj.name);
                                    function docPlaceHandler (err, docPlaceContent) {
                                        if (err) {
                                            docPlaceObj.content = '';
                                        }
                                        else {
                                            if (err == null) {
                                                addFileContent (docPlaceFullPath, docsPlacesCache, docPlaceContent);
                                            }
                                            docPlaceObj.content = docPlaceContent;
                                        }
                                    }
                                    let docPlaceContent = getFileContent (docPlaceFullPath, docsPlacesCache);
                                    if (docPlaceContent != null) {
                                        docPlaceHandler (false, docPlaceContent);
                                    }
                                    else {
                                        fs.readFile(docPlaceFullPath, 'UTF-8', docPlaceHandler);
                                    }
                                }
                            }
                        });
                    }
                    else if (optionSubmit.filesList[i].docsPlacesListRequestStage == 2) {
                        optionSubmit.filesList[i].docsPlacesListRequestStage = 3;
                        for (let dpl = 0; dpl < optionSubmit.filesList[i].docsPlacesList.length; dpl++) {
                            if (optionSubmit.filesList[i].docsPlacesList[dpl].content == null) {
                                optionSubmit.filesList[i].docsPlacesListRequestStage = 2;
                                break;
                            }
                        }
                    }
                }
                else if (optionSubmit.filesList[i].fileID === false) {
                    optionSubmit.filesList[i].docsPlacesList = [];
                    optionSubmit.filesList[i].docsPlacesListRequestStage = 3;
                }
            }
            if (!optionSubmit.filesList[i].readIsDone) {
                if (optionSubmit.filesList[i].isFolder) {
                    optionSubmit.filesList[i].readIsDone = true;
                    if (optionSubmit.filesList[i].subDocsList != null) {
                        for (let flf = 0; flf < optionSubmit.filesList[i].subDocsList.length; flf++) {
                            if (optionSubmit.filesList[i].subDocsList[flf].docThumbs == null) {
                                optionSubmit.filesList[i].readIsDone = false;
                                break;
                            }
                        }
                    }
                    else {
                        optionSubmit.filesList[i].readIsDone = false;
                    }
                    if (optionSubmit.filesList[i].folderContent == null) {
                        optionSubmit.filesList[i].readIsDone = false;
                    }
                    if (optionSubmit.filesList[i].needToBeRead) {
                        optionSubmit.filesList[i].needToBeRead = false;
                        //read folderContent
                        fs.readdir(path.join(optionSubmit.filesList[i].filePath , optionSubmit.filesList[i].fileParent, optionSubmit.filesList[i].fileName + optionSubmit.filesList[i].fileExtension), { withFileTypes: true }, function (err, dirents) {
                            //handling error
                            if (err) {
                                optionSubmit.filesList[i].folderContent = [];
                            }
                            else {
                                optionSubmit.filesList[i].folderContent = [];
                                let filesNames = dirents
                                .filter(dirent => dirent.isFile())
                                .map(dirent => dirent.name);
                                let foldersNames = dirents
                                .filter(dirent => dirent.isDirectory())
                                .map(dirent => dirent.name);
                                for (let fln = 0; fln < filesNames.length; fln++) {
                                    optionSubmit.filesList[i].folderContent.push ({name: filesNames[fln], isFile: true});
                                }
                                for (let fdn = 0; fdn < foldersNames.length; fdn++) {
                                    optionSubmit.filesList[i].folderContent.push ({name: foldersNames[fdn], isFile: false});
                                }
                            }
                        });
                        let subFolderOutput = getOutputPath (path.relative(tsRoot, path.join(optionSubmit.filesList[i].filePath , optionSubmit.filesList[i].fileParent, optionSubmit.filesList[i].fileName + optionSubmit.filesList[i].fileExtension)));
                        fs.readdir(subFolderOutput, { withFileTypes: true }, function (err, dirents) {
                            //handling error
                            if (err) {
                                optionSubmit.filesList[i].subDocsList = [];
                            }
                            else {
                                optionSubmit.filesList[i].subDocsList = [];
                                let foldersNames = dirents
                                .filter(dirent => dirent.isDirectory())
                                .map(dirent => dirent.name);
                                for (let fdn = foldersNames.length - 1; fdn >= 0; fdn--) {
                                    if (foldersNames[fdn].search(/ver\d\d/i) == 0) {
                                        optionSubmit.filesList[i].subDocsList.push ({docName: foldersNames[fdn], docThumbs: null});
                                    }
                                }
                                for (let dl = 0; dl < optionSubmit.filesList[i].subDocsList.length; dl++) {
                                    fs.readdir(path.join (subFolderOutput, optionSubmit.filesList[i].subDocsList[dl].docName), function (err, files) {
                                        //handling error
                                        if (err) {
                                            console.log('Unable to scan directory4: ' + err);
                                        }
                                        else {
                                            let filesNames = [];
                                            //listing all files using forEach
                                            files.forEach(function (file) {
                                                // Do whatever you want to do with the file
                                                filesNames.push (file); 
                                            });
                                            for (let fln = filesNames.length - 1; fln >= 0; fln--) {
                                                if (filesNames[fln][0] == '.') {
                                                    filesNames.splice(fln, 1);
                                                }
                                            }
                                            optionSubmit.filesList[i].subDocsList[dl].docThumbs = filesNames;
                                        }
                                    });
                                }
                            }
                        });
                    }
                } 
                else if (optionSubmit.filesList[i].optionsStage != 0) {
                    if (optionSubmit.filesList[i].optionsStage == 1 && optionSubmit.filesList[i].pairedOptions != '') {
                        optionSubmit.filesList[i].optionsStage = 3;
                        optionSubmit.filesList[i].optionsRoot = path.relative (path.join (tsRoot, "Workshop"), path.join (optionSubmit.filesList[i].filePath, optionSubmit.filesList[i].fileParent, optionSubmit.filesList[i].pairedOptions));
                    }
                    if (optionSubmit.filesList[i].optionsStage == 1) {
                        if (optionSubmit.filesList[i].fileID) {
                            optionSubmit.filesList[i].optionsStage = 2;
                            let previousFullPath = path.join(tsRoot, ".Data", "IDs", optionSubmit.filesList[i].invalidPreviousID.slice (1), "Original ID");
                            function previousHandler (err, previousFileID) {
                                if (err) {
                                    optionSubmit.filesList[i].readIsDone = true;
                                }
                                else {
                                    if (err == null) {
                                        addFileContent (previousFullPath, previousCache, previousFileID);
                                    }
                                    let pathTimeFullPath = path.join(tsRoot, ".Data", "IDs", previousFileID.slice (1), "Path", "Change Time");
                                    function pathTimeHandler (err, changeTime) {
                                        if (err) {
                                            optionSubmit.filesList[i].readIsDone = true;
                                        }
                                        else {
                                            if (err == null) {
                                                addFileContent (pathTimeFullPath, pathTimeCache, changeTime);
                                            }
                                            let pathValueFullPath = path.join(tsRoot, ".Data", "IDs", previousFileID.slice (1), "Path", "V", changeTime, "Value");
                                            function pathValueHandler (err, optionSourcePath) {
                                                if (err) {
                                                    optionSubmit.filesList[i].readIsDone = true;
                                                }
                                                else {
                                                    if (err == null) {
                                                        addFileContent (pathValueFullPath, pathValueCache, optionSourcePath);
                                                    }
                                                    let previousFileName = optionSourcePath.slice (optionSourcePath.lastIndexOf ("/") + 1);
                                                    try {previousFileName = decodeURI (previousFileName);} catch {}
                                                    optionSourcePath = optionSourcePath.slice (0, optionSourcePath.lastIndexOf ("/"));
                                                    optionSourcePath = optionSourcePath.slice (1).split ("/").join (path.sep);
                                                    try {optionSourcePath = decodeURI (optionSourcePath);} catch {}
                                                    if (false) { //put this for Previous ID: path.join(tsRoot, "Workshop", optionSourcePath) == path.join (optionSubmit.filesList[i].filePath, optionSubmit.filesList[i].fileParent) || previousFileName.match (/ts_up/)
                                                        optionSubmit.filesList[i].invalidPreviousID = previousFileID;
                                                        optionSubmit.filesList[i].optionsStage = 1;
                                                    }
                                                    else {
                                                        optionSubmit.filesList[i].optionsDefault = previousFileName;
                                                        optionSubmit.filesList[i].optionsRoot = optionSourcePath;
                                                        optionSubmit.filesList[i].optionsStage = 3;
                                                    }
                                                }
                                            }
                                            let pathValueContent = getFileContent (pathValueFullPath, pathValueCache);
                                            if (pathValueContent != null) {
                                                pathValueHandler (false, pathValueContent);
                                            }
                                            else {
                                                fs.readFile(pathValueFullPath, 'UTF-8', pathValueHandler);
                                            }
                                        }
                                    }
                                    let pathTimeContent = getFileContent (pathTimeFullPath, pathTimeCache);
                                    if (pathTimeContent != null) {
                                        pathTimeHandler (false, pathTimeContent);
                                    }
                                    else {
                                        fs.readFile(pathTimeFullPath, 'UTF-8', pathTimeHandler);
                                    }
                                }
                            }
                            let previousContent = getFileContent (previousFullPath, previousCache);
                            if (previousContent != null) {
                                previousHandler (false, previousContent);
                            }
                            else {
                                fs.readFile(previousFullPath, 'UTF-8', previousHandler);
                            }
    
                        }
                        else if (optionSubmit.filesList[i].fileID === false) {
                            optionSubmit.filesList[i].readIsDone = true;
                        }
                    }
                    if (optionSubmit.filesList[i].optionsStage == 3) {
                        optionSubmit.filesList[i].optionsStage = 4;
                        fs.readdir(path.join(tsRoot, "Workshop", optionSubmit.filesList[i].optionsRoot), { withFileTypes: true }, function (err, allFolAndOptions) {
                            //handling error
                            if (err) {
                                optionSubmit.filesList[i].readIsDone = true;
                            }
                            else {
                                optionSubmit.filesList[i].optionsList = allFolAndOptions
                                .filter(allFolAndOptions => allFolAndOptions.isFile())
                                .map(allFolAndOptions => allFolAndOptions.name);
                                optionSubmit.filesList[i].optionsPaireds = allFolAndOptions
                                .filter(allFolAndOptions => allFolAndOptions.isDirectory())
                                .map(allFolAndOptions => allFolAndOptions.name);
                                optionSubmit.filesList[i].optionsStage = 5;
                                for (let ofn = optionSubmit.filesList[i].optionsList.length - 1; ofn >= 0; ofn--) {
                                    if (optionSubmit.filesList[i].optionsList[ofn] == 'ts_sort.txt') {
                                        optionSubmit.filesList[i].treeShadeSortContent = "";
                                        optionSubmit.filesList[i].optionsList.splice(ofn, 1);
                                    }
                                    else if (optionSubmit.filesList[i].optionsList[ofn][0] == '.' || optionSubmit.filesList[i].optionsList[ofn].slice(-8) == ".txt.jpg" || 
                                             optionSubmit.filesList[i].optionsList[ofn].slice (-5) == ".idlk" || optionSubmit.filesList[i].optionsList[ofn].slice (-4) == ".tmp" || 
                                             optionSubmit.filesList[i].optionsList[ofn].slice (-4) == ".lst" || optionSubmit.filesList[i].optionsList[ofn].slice(0, 2) == "~$") {
                                        optionSubmit.filesList[i].optionsList.splice(ofn, 1);
                                    }
                                    else if (optionSubmit.filesList[i].fileExtension != ".indd" && optionSubmit.filesList[i].optionsList[ofn].slice(-5) == ".indd" && optionSubmit.filesList[i].optionsList[ofn].indexOf ("ts_shw") == -1) {
                                        optionSubmit.filesList[i].optionsList.splice(ofn, 1);
                                    }
                                }
                                if (optionSubmit.filesList[i].treeShadeSortContent == null) {
                                    optionSubmit.filesList[i].optionsStage = 7;
                                }
                            }
                        });
                    }
                    if (optionSubmit.filesList[i].optionsStage == 5) {
                        optionSubmit.filesList[i].optionsStage = 6;
                        let optionsFullPath = path.join(tsRoot, "Workshop", optionSubmit.filesList[i].optionsRoot , 'ts_sort.txt');
                        function optionsSortHandler (err, optionsTSSortContent) {
                            if(err) {
                                optionSubmit.filesList[i].optionsStage = 7;
                            }
                            else {
                                if (err == null) {
                                    addFileContent (optionsFullPath, filesCache, optionsTSSortContent);
                                }
                                let optionsSortList = '';
                                if (optionsTSSortContent.indexOf ('\r\n') != -1) {
                                    optionsSortList = optionsTSSortContent.split ('\r\n');
                                }
                                else {
                                    optionsSortList = optionsTSSortContent.split ('\n');
                                }
                                if (optionsSortList) {
                                    let sortIndex = 0;
                                    for (let sl = 0; sl < optionsSortList.length; sl++) {
                                        let pureFileName = optionsSortList[sl];
                                        for (let aui = sortIndex; aui < optionSubmit.filesList[i].optionsList.length; aui++) {
                                            if (getPureName (optionSubmit.filesList[i].optionsList[aui], false) == pureFileName) {
                                                if (aui != sortIndex) {
                                                    let swapCell = optionSubmit.filesList[i].optionsList[aui];
                                                    optionSubmit.filesList[i].optionsList[aui] = optionSubmit.filesList[i].optionsList[sortIndex];
                                                    optionSubmit.filesList[i].optionsList[sortIndex] = swapCell;
                                                }
                                                sortIndex++;
                                                break;
                                            }
                                        }
                                    }
                                }
                                optionSubmit.filesList[i].optionsStage = 7;
                            }
                        }
                        let optionsSortContent = getFileContent (optionsFullPath, filesCache);
                        if (optionsSortContent != null) {
                            optionsSortHandler (false, optionsSortContent);
                        }
                        else {
                            fs.readFile (optionsFullPath, 'UTF-8', optionsSortHandler);
                        }
                    }
                    if (optionSubmit.filesList[i].optionsStage == 7) {
                        //pairedFolder
                        optionSubmit.filesList[i].optionsStage = 8;
                        let optionFolNames = optionSubmit.filesList[i].optionsPaireds;
                        optionSubmit.filesList[i].optionsPaireds = [];
                        let optionsListIndexes = [];
                        for (let ol = 0; ol < optionSubmit.filesList[i].optionsList.length; ol++) {
                            optionsListIndexes.push (ol);
                            optionSubmit.filesList[i].optionsPaireds.push ("no_paired");
                        }
                        for (let oli = optionsListIndexes.length - 1; oli >= 0; oli--) {
                            for (let odn = optionFolNames.length - 1; odn >= 0; odn--) {
                                if (getPureName (optionSubmit.filesList[i].optionsList[optionsListIndexes[oli]], false) == getPureName (optionFolNames[odn] + ".ext", false)) {
                                    optionSubmit.filesList[i].optionsPaireds[optionsListIndexes[oli]] = optionFolNames[odn];
                                    optionsListIndexes.splice (oli, 1);
                                    optionFolNames.splice (odn, 1);
                                    break;
                                }
                            }
                        }
                        for (let ol = 0; ol < optionSubmit.filesList[i].optionsList.length; ol++) {
                            optionSubmit.filesList[i].optionsTxtContents.push (null);
                            optionSubmit.filesList[i].optionsRoots.push (optionSubmit.filesList[i].optionsRoot);
                        }
                        for (let ol = 0; ol < optionSubmit.filesList[i].optionsList.length; ol++) {
                            if (optionSubmit.filesList[i].optionsList[ol].slice (-4) == ".txt") {
                                let optionFullPath = path.join(tsRoot, "Workshop", optionSubmit.filesList[i].optionsRoots[ol] , optionSubmit.filesList[i].optionsList[ol]);
                                function optionFileHandler (err, optionContent) {
                                    if(err) {
                                        optionSubmit.filesList[i].optionsTxtContents[ol] = false;
                                    }
                                    else {
                                        if (err == null) {
                                            addFileContent (optionFullPath, filesCache, optionContent);
                                        }
                                        optionSubmit.filesList[i].optionsTxtContents[ol] = optionContent;
                                    }
                                }
                                let optionFileContent = getFileContent (optionFullPath, filesCache);
                                if (optionFileContent != null) {
                                    optionFileHandler (false, optionFileContent);
                                }
                                else {
                                    fs.readFile (optionFullPath, 'UTF-8', optionFileHandler);
                                }
                            }
                            else {
                                optionSubmit.filesList[i].optionsTxtContents[ol] = false;
                            }
                        }
                    }
                    if (optionSubmit.filesList[i].optionsStage == 8) {
                        let isAllContentDone = true;
                        for (let otc = 0; otc < optionSubmit.filesList[i].optionsTxtContents.length; otc++) {
                            if (optionSubmit.filesList[i].optionsTxtContents[otc] == null) {
                                isAllContentDone = false;
                                break;
                            }
                        }
                        if (isAllContentDone) {
                            optionSubmit.filesList[i].readIsDone = true;
                            optionSubmit.filesList[i].optionsStage = 9;
                        }
                    }
                }
                else if (optionSubmit.filesList[i].needToBeRead) {
                    optionSubmit.filesList[i].needToBeRead = false;
                    let readFullPath = path.join(optionSubmit.filesList[i].filePath , optionSubmit.filesList[i].fileParent, optionSubmit.filesList[i].fileName + optionSubmit.filesList[i].fileExtension);
                    function textHandler (err, data) {
                        if(err) throw err;
                        if (err == null) {
                            addFileContent (readFullPath, filesCache, data);
                        }
                        optionSubmit.filesList[i].textContent = data;
                        optionSubmit.filesList[i].readIsDone = true;
                    }
                    let testedContent = getFileContent (readFullPath, filesCache);
                    if (testedContent != null) {
                        textHandler (false, testedContent);
                    }
                    else {
                        fs.readFile (readFullPath, 'UTF-8', textHandler);
                    }
                }
            }
        }
        let testAllReadDone = true;
        for (let c = 0; c < optionSubmit.filesList.length; c++) {
            if (!optionSubmit.filesList[c].readIsDone) {
                testAllReadDone = false;
                break;
            }
            if (!optionSubmit.filesList[c].isFolder && optionSubmit.filesList[c].docsPlacesListRequestStage != 3) {
                testAllReadDone = false;
                break;
            }
        }
        if (testAllReadDone) {
            optionSubmit.isAllReadDone = true;
            let newOptionsPage = "<!DOCTYPE html><html><body>THE_OPTIONS</body></html>";
            let htmlElements = '';

            let repArrangeRows = [];
            let repMatrix = [];
            let isAllOneList = true;
            let isAllListItems = true;
            let tsroAloneGroups = [];
            for (let b = 0; b < optionSubmit.filesList.length; b++) {
                repMatrix.push ([null, null]);
                if (optionSubmit.filesList[b].isFolder) {
                    continue;
                }
                if (optionSubmit.filesList[b].fileName.search (/^ID[A-Z0-9]+/) != -1) {
                    let repListUniqueID = "";
                    let repListNetName = getPureName (optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension, true).replace(/ /g, '_space_').replace(/\./g, '_dot_');
                    if (repListNetName == optionSubmit.filesList[b].fileName.match (/^ID[A-Z0-9]+/)[0]) {
                        repListNetName = "";
                    }
                    let parentPortion = '';
                    if (optionSubmit.filesList[b].fileParent != '') {
                        parentPortion = optionSubmit.filesList[b].fileParent.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_") + '_slash_';
                    }
                    if (optionSubmit.callerName != "") {
                        repListUniqueID = optionSubmit.callerName.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_") + '_slash_' + parentPortion + repListNetName;
                    }
                    else {
                        repListUniqueID = repListNetName;
                    }
                    let repGroupIndex = -1;
                    for (let rar = 0; rar < repArrangeRows.length; rar++) {
                        if (repListUniqueID == repArrangeRows[rar][0]) {
                            repGroupIndex = rar;
                            break;
                        }
                    }
                    if (repGroupIndex == -1) {
                        repGroupIndex = repArrangeRows.length;
                        repArrangeRows.push ([repListUniqueID, []]);
                    }
                    repMatrix[b][0] = repGroupIndex;
                    repMatrix[b][1] = repArrangeRows[repGroupIndex][1].length;
                    repArrangeRows[repGroupIndex][1].push ([repListUniqueID, b]);
                    if (repArrangeRows[repGroupIndex][1].length > 1) {
                        let rowIndex = repArrangeRows[repGroupIndex][1].length - 1;
                        if (repArrangeRows[repGroupIndex][1][rowIndex - 1][1] + 1 < repArrangeRows[repGroupIndex][1][rowIndex][1]) {
                            let shiftIndex = repArrangeRows[repGroupIndex][1][rowIndex - 1][1] + 1;
                            optionSubmit.filesList.splice (shiftIndex, 0, optionSubmit.filesList[b]);
                            optionSubmit.filesList.splice (b + 1, 1);
                            repMatrix.splice (shiftIndex, 0, repMatrix[b]);
                            repMatrix.splice (b + 1, 1);
                            for (let rar = 0; rar < repArrangeRows.length; rar++) {
                                for (let s = 0; s < repArrangeRows[rar][1].length; s++) {
                                    if (repArrangeRows[rar][1][s][1] > shiftIndex) {
                                        repArrangeRows[rar][1][s][1]++;
                                    }
                                }
                            }
                        }
                    }
                    if (optionSubmit.filesList[b].fileName.search (/\[[^\[\]]+\]$/) != -1) {
                        isAllOneList = false;
                    }
                }
                else {
                    isAllOneList = false;
                    isAllListItems = false;
                }
            }
            let queryString = "";
            let queryStringWithQuestion = "";
            if (optionSubmit.locationhref) {
                queryString = optionSubmit.locationhref.includes('?') ? optionSubmit.locationhref.slice(optionSubmit.locationhref.indexOf('?') + 1) : '';
                if (queryString != '') {
                    queryStringWithQuestion = "?" + queryString;
                }
            }
            let displayedCount = 0;
            let isAllConditionalShowFailed = true;
            for (let b = 0; b < optionSubmit.filesList.length; b++) {
                if (optionSubmit.filesList[b].isFolder) {
                    let folderKeyName = '';
                    for (let fc = 0; fc < optionSubmit.filesList[b].folderContent.length; fc++) {
                        if (!optionSubmit.filesList[b].folderContent[fc].isFile) {
                            break;
                        }
                        if (optionSubmit.filesList[b].folderContent[fc].name.indexOf ("ts_key") != -1) {
                            folderKeyName = optionSubmit.filesList[b].folderContent[fc].name;
                            folderKeyName = folderKeyName.slice (0, folderKeyName.lastIndexOf ("."));
                            break;
                        }
                    }
                    let isThumbFileExist = false;
                    if (folderKeyName != '') {
                        displayedCount++;
                        optionSubmit.filesList[b].folderKeyName = folderKeyName;
                        try {
                            let thumbPath = getThumb (path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent, optionSubmit.filesList[b].fileName, optionSubmit.filesList[b].fileExtension), folderKeyName, ".txt");
                            if (fs.existsSync(thumbPath)) {
                                isThumbFileExist = true;
                            }
                        } catch(err) {
                            isThumbFileExist = false;
                        }
                    }
                    for (let sdl = 0; sdl < optionSubmit.filesList[b].subDocsList.length; sdl++) {
                        if (optionSubmit.filesList[b].subDocsList[sdl].docThumbs.length) {
                            for (let dt = 0; dt < optionSubmit.filesList[b].subDocsList[sdl].docThumbs.length; dt++) {
                                let subFolderOutput = getOutputPath (path.relative(tsRoot, path.join(optionSubmit.filesList[b].filePath , optionSubmit.filesList[b].fileParent, optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension)));
                                optionSubmit.filesList[b].docThumb = getImageFileURL (optionSubmit.hostName, path.join (subFolderOutput, optionSubmit.filesList[b].subDocsList[sdl].docName, optionSubmit.filesList[b].subDocsList[sdl].docThumbs[dt]));
                                if (dt == 0) {
                                    break;
                                }
                            }
                            if (sdl == 0) {
                                break;
                            }
                        }
                    }
                    if (isThumbFileExist) {
                        let thumbURL = getThumbURL (optionSubmit.hostName, path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent), optionSubmit.filesList[b].fileName, optionSubmit.filesList[b].fileExtension);
                        optionSubmit.filesList[b].subPreviewTHumb = thumbURL;
                    }
                    if (optionSubmit.filesList[b].folderKeyName != '' && optionSubmit.filesList[b].pairedName != '') {
                        let bfIndex = -1;
                        for (let ssu = 0; ssu < optionSubmit.filesList.length; ssu++) {
                            if (!optionSubmit.filesList[ssu].isFolder && optionSubmit.filesList[b].pairedName == (optionSubmit.filesList[ssu].fileName + optionSubmit.filesList[ssu].fileExtension)) {
                                bfIndex = ssu;
                                break;
                            }
                        }
                        if (bfIndex != -1 && !isThereFilter (optionSubmit.flags)) {
                            optionSubmit.filesList[bfIndex].subKeyIndex = b;
                            optionSubmit.filesList[b].pairedName = null;
                        }
                    }
                }
                else {
                    if (optionSubmit.filesList[b].fileExtension == '.htm' || optionSubmit.filesList[b].fileExtension == '.html') {
                        if (optionSubmit.filesList[b].fileName.indexOf ('ts_upld') == -1 && optionSubmit.filesList[b].fileName.indexOf ('ts_txt') == -1) {
                            optionSubmit.filesList[b].isHTMLOutput = true;
                            optionSubmit.filesList[b].isHidden = 1; //by default html file has two faces hidden and output
                        }
                        else {
                            displayedCount++;
                        }
                    }
                    else {
                        displayedCount++;
                    }
                    if (optionSubmit.filesList[b].defaultPaired == '' && optionSubmit.filesList[b].fileName.indexOf ('ts_key') != -1) {
                        isToDisplay = false;
                    }
                    let tsParams = optionSubmit.filesList[b].fileName.match (/(\s?)(ts)(_\w+)+/g);

                    if (tsParams) {
                        for (let tsp = 0; tsp < tsParams.length; tsp++) {
                            tsParams[tsp] = tsParams[tsp].split ("_");
                        }
                        for (let tsp = 0; tsp < tsParams.length; tsp++) {
                            if (tsParams[tsp].length > 1) {
                                if (tsParams[tsp][1] == "hdn") {
                                    let isThereException = false;
                                    if (tsParams[tsp].length > 2) {
                                        optionSubmit.filesList[b].isConditionalShow = true;
                                        if (queryString != '') {
                                            let queryStringSplitted = queryString.split ("&");
                                            for (let qss = 0; qss < queryStringSplitted.length; qss++) {
                                                let keyValue = queryStringSplitted[qss].split ("=");
                                                if (keyValue.length > 1) {
                                                    keyValue.splice (0, 1);
                                                }
                                                if (keyValue[0] == tsParams[tsp][2]) {
                                                    isThereException = true;
                                                    isAllConditionalShowFailed = false;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (!isThereException) {
                                        optionSubmit.filesList[b].isHidden = true;
                                        displayedCount--;
                                    }
                                    break;
                                }
                                else if (tsParams[tsp][1] == "ro") {
                                    optionSubmit.filesList[b].isReadOnly = true;
                                    if (tsParams[tsp].length > 2) {
                                        if (tsParams[tsp][2] == "a") {
                                            if (repMatrix[b][0] != null) {
                                                tsroAloneGroups.push (repMatrix[b][0]);
                                                optionSubmit.filesList[b].isReadOnlyAlone = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            for (let b = 0; b < optionSubmit.filesList.length; b++) {
                if (optionSubmit.filesList[b].isFolder) {
                    //if (optionSubmit.filesList[b].pairedName == null || (optionSubmit.filesList[b].folderKeyName == '' && optionSubmit.filesList[b].subPreviewTHumb == '')) {
                        continue;
                    //}
                }
                if (isAllConditionalShowFailed) {
                    if (optionSubmit.filesList[b].isConditionalShow) {
                        optionSubmit.filesList[b].isHidden = false;
                        displayedCount++;
                        isAllConditionalShowFailed = false;
                    }
                }
                if (optionSubmit.filesList[b].fileName == "http-form") {
                    optionSubmit.filesList[b].isHidden = true;
                    displayedCount--;
                }
                let itemUniqueID = "";
                let itemUniqueIDRename = "";
                let listClassName = "";
                let inputName = "";
                let inputID = "";
                let nameOrIDExt = "";
                let relativeParentPath = path.relative (path.join (tsRoot, "Workshop"), path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent)).split (path.sep).join ("/");
                let filePureName = '';
                if (optionSubmit.filesList[b].isFolder) {
                    filePureName = optionSubmit.filesList[b].fileName;
                }
                else {
                    filePureName = getPureName (optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension, false);
                }
                if (optionSubmit.filesList[b].fileExtension) {
                    nameOrIDExt = "_dot_" + optionSubmit.filesList[b].fileExtension.slice (1);
                }
                else if (optionSubmit.filesList[b].isVirtual) {
                    nameOrIDExt = "_dot_virtual";
                }
                let tsParams = optionSubmit.filesList[b].fileName.match (/(\s?)(ts)(_\w+)+/g);
                let isStatic = false;
                let isCallerLabel = false;
                let isToUpload = null;
                let isMarkdown = false;
                let isInput = false;
                let isGoal = false;
                let optionImageDisplay = ' style="display: block"';
                let optionTitleDisplay = '';
                let optionContentDisplay = '';
                let optionsCls = ' style="grid-template-columns: repeat(auto-fit, 32px)"';
                let verticalTextClass = ' verticalText';
                let attributesStr = '';
                let extraMainClasses = "w3-col mainCon w3-animate-top toDeleteBeforeSubmit";
                let isColCon = false;
                if (tsParams) {
                    for (let tsp = 0; tsp < tsParams.length; tsp++) {
                        tsParams[tsp] = tsParams[tsp].split ("_");
                    }
                    for (let tsp = 0; tsp < tsParams.length; tsp++) {
                        if (tsParams[tsp].length > 1) {
                            if (tsParams[tsp][1] == "cls" && tsParams[tsp].length > 2) {
                                for (let tsps = 2; tsps < tsParams[tsp].length; tsps++) {
                                    if (tsParams[tsp][tsps].search (/^[sml]\d+$/) != -1) {
                                        isColCon = true;
                                    }
                                    extraMainClasses += " " + tsParams[tsp][tsps];
                                }
                                if (isColCon) {
                                    extraMainClasses += " mainColCon";
                                }
                            }
                            else if (tsParams[tsp][1] == "tp" && tsParams[tsp].length > 2) {
                                isInput = true;
                                attributesStr += ' type="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "mn" && tsParams[tsp].length > 2) {
                                attributesStr += ' min="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "mx" && tsParams[tsp].length > 2) {
                                attributesStr += ' max="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "mxl" && tsParams[tsp].length > 2) {
                                attributesStr += ' maxlength="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "mnl" && tsParams[tsp].length > 2) {
                                attributesStr += ' minlength="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "stp" && tsParams[tsp].length > 2) {
                                attributesStr += ' step="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "vlu" && tsParams[tsp].length > 2) {
                                if (tsParams[tsp][2] == "no") {
                                    tsParams[tsp][2] = "";
                                }
                                attributesStr += ' value="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "row" && tsParams[tsp].length > 2) {
                                attributesStr += ' rows="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "col" && tsParams[tsp].length > 2) {
                                attributesStr += ' cols="' + tsParams[tsp][2] + '"';
                            }
                            else if (tsParams[tsp][1] == "stc") {
                                isStatic = true;
                            }
                            else if (tsParams[tsp][1] == "lbl") {
                                isCallerLabel = true;
                            }
                            else if (tsParams[tsp][1] == "upld") {
                                isToUpload = true;
                            }
                            else if (tsParams[tsp][1] == "txt") {
                                isToUpload = false;
                            }
                            else if (tsParams[tsp][1] == "md") {
                                isMarkdown = true;
                            }
                            else if (tsParams[tsp][1] == "goal") {
                                isGoal = true;
                            }
                            else if (tsParams[tsp][1] == "opt") {
                                if (tsParams[tsp].length > 2) {
                                    let flags = tsParams[tsp][2];
                                    if (flags.length > 0) {
                                        if (flags[0] == '0') {
                                            optionImageDisplay = ' style="display: none"';
                                        }
                                        else if (flags[0] == '1') {
                                            optionImageDisplay = ' style="display: block"';
                                        }
                                        if (flags.length > 1) {
                                            if (flags[1] == '0') {
                                                optionTitleDisplay = ' style="display: none"';
                                            }
                                            else if (flags[1] == '1') {
                                                optionTitleDisplay = ' style="display: block"';
                                            }
                                            if (flags.length > 2) {
                                                if (flags[2] == '0') {
                                                    optionContentDisplay = ' style="display: none"';
                                                }
                                                else if (flags[2] == '1') {
                                                    optionContentDisplay = ' style="display: block"';
                                                }
                                            }
                                        }
                                    }
                                    if (tsParams[tsp].length > 3) {
                                        if (tsParams[tsp][3].search(/\d+[a-zA-Z%]+$/) !== -1) {
                                            optionsCls = ' style="grid-template-columns: repeat(auto-fit, ' + tsParams[tsp][3] + ')"';
                                        }
                                        else {
                                            optionsCls = parseInt (tsParams[tsp][3], 10);
                                            if (optionsCls != null && optionsCls > 0) {
                                                optionsCls = ' style="grid-template-columns: repeat(' + optionsCls + ', 1fr); direction: ltr;"';
                                                verticalTextClass = '';
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                let theDataVal = 'yes';
                                if (tsParams[tsp].length > 2) {
                                    theDataVal = tsParams[tsp][2];
                                }
                                attributesStr += ' data-' + tsParams[tsp][1] + '="' + theDataVal + '"';
                            }
                        }
                    }
                }
                let staticHeadClass = '';
                if (isStatic) {
                    staticHeadClass = ' staticHead';
                }
                let isRenameable = false;
                if (optionSubmit.filesList[b].fileName.search (/\[[^\[\]]+\]$/) != -1) {
                    isRenameable = true;
                }
                let parentPortion = '';
                let isOriginal = false;
                itemUniqueID = ":" + optionSubmit.optionName.replace(/ /g, '_space_').replace(/\./g, '_dot_') + ":" + optionSubmit.callerName.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_") + '_slash_' + parentPortion + optionSubmit.filesList[b].fileName.replace (/\[[^\[\]]+\]$/, "[LABEL]").replace(/ /g, '_space_').replace(/\./g, '_dot_') + nameOrIDExt;
                listClassName = ":" + optionSubmit.optionName.replace(/ /g, '_space_').replace(/\./g, '_dot_') + ":" + optionSubmit.callerName.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_") + '_slash_' + parentPortion + optionSubmit.filesList[b].fileName.replace (/\[[^\[\]]+\]$/, "[LABEL]").replace (/^ID[A-Z0-9]+\s*/, "").replace(/ /g, '_space_').replace(/\./g, '_dot_') + nameOrIDExt;
                itemUniqueIDRename = ":" + optionSubmit.optionName.replace(/ /g, '_space_').replace(/\./g, '_dot_') + ":" + optionSubmit.callerName.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_") + '_slash_' + parentPortion + optionSubmit.filesList[b].fileName.replace(/ /g, '_space_').replace(/\./g, '_dot_') + nameOrIDExt;
                if (optionSubmit.callerName != "") {
                }
                else {
                    isOriginal = true;
                }
                inputID = 'in_' + itemUniqueID;
                inputName = 'in_' + itemUniqueIDRename;
                let defaultIndex = -1;
                if (optionSubmit.filesList[b].optionsDefault != "") {
                    for (let fop = 0; fop < optionSubmit.filesList[b].optionsList.length; fop++) {
                        if (optionSubmit.filesList[b].optionsList[fop] == optionSubmit.filesList[b].optionsDefault) {
                            defaultIndex = fop;
                            break;
                        }
                    }
                }
                if (!optionSubmit.filesList[b].isFolder) { // && (optionSubmit.filesList[b].fileExtension == '.txt' || optionSubmit.filesList[b].fileExtension == '.IDMS')
                    let dynamicLiveSnippetPhrase = '';
                    if (optionSubmit.filesList[b].textContent.indexOf (lsSnippetDynamicTag) == 0) {
                        dynamicLiveSnippetPhrase = optionSubmit.filesList[b].textContent.slice (lsSnippetDynamicTag.length);
                    }
                    if (optionSubmit.filesList[b].defaultPaired == '' && optionSubmit.filesList[b].fileName.indexOf ('ts_key') == -1) {
                        if (dynamicLiveSnippetPhrase != '' && optionSubmit.filesList[b].fileName.indexOf ('ts_shw') == -1) {
                            if (optionSubmit.filesList[b].textContent.search (/(:[\n\r])|(\r\n)/) != -1) {
                                let dynamicPart = optionSubmit.filesList[b].textContent.slice (0, optionSubmit.filesList[b].textContent.search (/(:[\n\r])|(\r\n)/));
                                attributesStr += ' data-dynamic="' + dynamicPart + '"';
                                optionSubmit.filesList[b].textContent = optionSubmit.filesList[b].textContent.slice (optionSubmit.filesList[b].textContent.search (/(:[\n\r])|(\r\n)/) + optionSubmit.filesList[b].textContent.match (/(:[\n\r])|(\r\n)/)[0].length);
                            }
                            else {
                                extraMainClasses += " dynamicLiveSnippetMain";
                            }
                        }
                    }
                    else {
                        let requiredPart = '';
                        if (dynamicLiveSnippetPhrase.indexOf ("./<FC>/") == 0) {
                            requiredPart = dynamicLiveSnippetPhrase;
                            if (requiredPart.indexOf (":") != -1) {
                                requiredPart = requiredPart.slice (0, requiredPart.indexOf (":"));
                            }
                            requiredPart = requiredPart.slice (7);
                            if (requiredPart.indexOf ("/") != -1) {
                                requiredPart = requiredPart.slice (0, requiredPart.lastIndexOf ("/"));
                            }
                            else {
                                requiredPart = '';
                            }
                        }
                        requiredPart = requiredPart.replace(/ /g, '_space_').replace(/\./g, '_dot_').replace(/\//g, '_slash_');
                        optionSubmit.filesList[b].optionsRoot = path.relative (path.join (tsRoot, "Workshop"), path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent));
                        optionSubmit.filesList[b].optionsRoots.push (optionSubmit.filesList[b].optionsRoot);
                        optionSubmit.filesList[b].optionsList.push (optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension);
                        optionSubmit.filesList[b].optionsTxtContents.push (optionSubmit.filesList[b].textContent);
                        optionSubmit.filesList[b].optionsDefault = optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension;
                        if (optionSubmit.filesList[b].defaultPaired != '') {
                            optionSubmit.filesList[b].optionsPaireds.push ('');
                            optionSubmit.filesList[b].defaultPaired = optionSubmit.filesList[b].defaultPaired.replace ("_trsd_sep_", "_slash_");
                            optionSubmit.filesList[b].defaultPaired += "_trsd_sep_" + requiredPart;
                        }
                        else {
                            optionSubmit.filesList[b].isHidden = true;
                        }
                        if (optionSubmit.filesList[b].treeShadeSortContent == null)
                            optionSubmit.filesList[b].treeShadeSortContent = '';
                        optionSubmit.filesList[b].optionsStage = 10;
                    }
                }
                if (optionSubmit.filesList[b].isHidden) {
                    extraMainClasses += " toBeHidden";
                }
                else if (optionSubmit.filesList[b].optionsStage == 0 && optionSubmit.filesList[b].fileName.indexOf ('ts_key') != -1) {
                    extraMainClasses += " toBeHidden";
                }
                if (isOriginal) {
                    extraMainClasses += " mainOriginal";
                }
                if (isGoal) {
                    extraMainClasses += " goalMain";
                }
                if (optionSubmit.filesList[b].fileName.search (/^ID[A-Z0-9]+/) != -1) {
                    extraMainClasses += " repeatedMain";
                }
                if (optionSubmit.callerName == '') {
                    extraMainClasses += " rootMain";
                }
                if (optionSubmit.filesList[b].isReadOnly) {
                    extraMainClasses += " tsroItem";
                    if (optionSubmit.filesList[b].isReadOnlyAlone) {
                        extraMainClasses += " tsroAloneItem";
                    }
                }
                if (optionSubmit.filesList[b].isHTMLOutput && !optionSubmit.filesList[b].isHidden) {
                    extraMainClasses += " mainHTML";
                    if (!isOriginal) {
                        extraMainClasses += " subHTMLCon";
                    }
                }
                if (optionSubmit.filesList[b].optionsStage == 0 && optionSubmit.filesList[b].fileExtension == '.indd' && optionSubmit.filesList[b].fileName.indexOf ('ts_shw') == -1) {
                    if (optionSubmit.filesList[b].isHidden) {
                        extraMainClasses = extraMainClasses.replace (" toBeHidden", "");
                    }
                    else {
                        continue;
                    }
                }
                let  lonelyListConClass = '';
                if (isAllListItems) {
                    lonelyListConClass = ' lonelyListCon';
                }
                if (repMatrix[b][0] != null) {
                    if (repMatrix[b][1] == 0) {
                        htmlElements += '<div id="list_' + repArrangeRows[repMatrix[b][0]][0] + '" class="listCon' +  lonelyListConClass + '">';
                    }
                }
                if (optionSubmit.filesList[b].fileName.indexOf ('ts_key') != -1 && isOriginal) {
                    attributesStr += ' data-key="yes"';
                }
                let lonelyHidden = "";
                if (optionSubmit.filesList[b].optionsStage != 0) {
                    isAllOneList = false;
                }
                if (displayedCount == 1 && !isRenameable && optionSubmit.filesList[b].fileName.search (/^ID[A-Z0-9]+/) == -1 && optionSubmit.filesList[b].optionsList.length < 2) {
                    lonelyHidden = " lonelyHidden";
                    extraMainClasses += " lonelyCon";
                }
                else if (isAllOneList) {
                    lonelyHidden = " lonelyHidden";
                    extraMainClasses += " listItemCon";
                }
                if (optionSubmit.filesList[b].subKeyIndex != -1) {
                    extraMainClasses += " subKeyMain";
                }
                htmlElements += '<div id="main_' + itemUniqueID + '" class="' + extraMainClasses + '" data-identifier="/' + relativeParentPath + "/" + filePureName + '">';
                if (lonelyHidden == "") {
                    if (isAllOneList) {
                        htmlElements += '<div class="w3-display-middle listItemFrame"></div>';
                    }
                    else if (isColCon) {
                        htmlElements += '<div class="w3-display-middle theColFrame"></div>';
                    }
                    else {
                        htmlElements += '<div class="w3-display-middle theFrame"></div>';
                    }
                }
                let oneOptionClass = '';
                if (optionSubmit.filesList[b].optionsStage != 0 && optionSubmit.filesList[b].optionsList.length == 1) {
                    oneOptionClass = ' oneOption';
                }
                let hidem1andm3 = '';
                let colItemCon = "";
                let mainItemDownCol = ' mainItem1';
                let lonelyHidden1 = lonelyHidden;
                let multiplePart = "";
                if (isAllOneList) {
                    if (isColCon) {
                        mainItemDownCol = ' mainItemDownCol';
                    }
                    else {
                        mainItemDownCol = ' mainItemDown';
                    }
                    lonelyHidden1 = '';
                }
                else if (isColCon) {
                    hidem1andm3 = ' style="display:none"';
                    colItemCon = " colItemCon";
                }
                htmlElements += '<div id="mi1_' + itemUniqueID + '" class="' + lonelyHidden1 + mainItemDownCol + staticHeadClass + '"' + hidem1andm3 + '>';
                if (optionSubmit.filesList[b].fileName.search (/^ID[A-Z0-9]+/) != -1) {
                    multiplePart = " multiple";
                    if (repMatrix[b][0] != null && tsroAloneGroups.includes (repMatrix[b][0])) {
                        if (optionSubmit.filesList[b].isReadOnly) {
                            htmlElements += '<div class="fa fa-plus-circle w3-text-green awesomeIcon tsroAlone" onclick="cloneField (this)"></div>';
                        }
                        else {
                            htmlElements += '<div></div>';
                        }
                    }
                    else if (optionSubmit.filesList[b].subKeyIndex != -1) {
                        htmlElements += '<div class="fa fa-plus-circle w3-text-green awesomeIcon" onclick="cloneField (this)"></div>';
                    }
                    else {
                        htmlElements += '<div class="fa fa-plus-circle w3-text-green awesomeIcon" onclick="duplicateField (this)"></div>';
                    }
                    htmlElements += '<div class="fa fa-arrows-v w3-text-gray awesomeIcon" onclick="changeOrder (this, null, null)"></div>';
                    htmlElements += '<div class="fa fa-times w3-text-gray awesomeIcon" onclick="removeMain (this)"></div>';
                }
                else {
                    htmlElements += '<div></div>';
                    htmlElements += '<div></div>';
                    htmlElements += '<div></div>';
                }
                let collapseClass = 'fa fa-caret-down';
                if (isAllOneList) {
                    collapseClass += 'noCollapse fa fa-caret-down';
                }
                else if (optionSubmit.filesList[b].subKeyIndex != -1) {
                    collapseClass = 'loadCollapse fa fa-caret-right';
                }
                htmlElements += '<div class="' + collapseClass + ' w3-text-teal awesomeArrow' + '" onclick="collapse (this, null)"></div>';
                htmlElements += '</div>';

                let greenStrip = '';
                let onClickCollapse = ' onclick="mi2Collapse (this)"';
                htmlElements += '<div id="mi2_' + itemUniqueID + '" class="w3-cell-row mainItem2 w3-text-teal' + lonelyHidden + greenStrip + colItemCon + staticHeadClass + '"' + onClickCollapse + '>';
                let disName = getPureDisplayName (optionSubmit.filesList[b].fileName + ".ext");
                let labelPrefix = '';
                if (optionSubmit.filesList[b].subKeyIndex != -1) {
                    if (!optionSubmit.filesList[b].isReadOnly) {
                        let subKeyPureURL = path.relative (path.join (tsRoot, "Workshop"), optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].filePath).split (path.sep).join ("/");
                        let subParentPart = optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].fileParent;
                        let sproutClass = '';
                        if (!optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].docThumb) {
                            sproutClass = ' newSubKey';
                            if (optionSubmit.flags.search (/Sprout/i) != -1) {
                                sproutClass += ' sprout';
                                queryStringWithQuestion = (queryStringWithQuestion == "")? "?Producing" : "?Producing&" + queryStringWithQuestion.slice (1);
                            }
                        }
                        htmlElements += '<div class="w3-cell"><a class="subKey' + sproutClass + '" href="' + "https://" + optionSubmit.hostName + "/" + subKeyPureURL + "/" + subParentPart + optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].fileName + queryStringWithQuestion + '" target="_blank">';
                    }
                }
                if (optionSubmit.filesList[b].fileName.search (/^ID[A-Z0-9]+/) != -1) {
                    labelPrefix = '<div class="w3-cell"><label id="prefix_' + itemUniqueID + '">' + tsFillZeros (repMatrix[b][1] + 1, 2) + '.&nbsp;</label></div>';
                }
                else if (optionSubmit.filesList[b].subKeyIndex != -1) {
                    labelPrefix = '<div class="w3-cell"><label id="prefix_' + itemUniqueID + '"><i class="fa fa-external-link"></i></label></div>';
                }
                if (optionSubmit.filesList[b].isFolder) {
                    let pureURL = path.relative (path.join (tsRoot, "Workshop"), optionSubmit.filesList[b].filePath).split (path.sep).join ("/");
                    let fileParentPart = optionSubmit.filesList[b].fileParent;
                    if (optionSubmit.filesList[b].fileParent != '') {
                        let parentParts = optionSubmit.filesList[b].fileParent.split (path.sep);
                        if (parentParts.length > 1) {
                            fileParentPart = parentParts.join ("/") + "/";
                        }
                    }
                    htmlElements += labelPrefix + '<div class="w3-cell"><label><a href="' + "https://" + optionSubmit.hostName + "/" + pureURL + "/" + fileParentPart + optionSubmit.filesList[b].fileName + queryStringWithQuestion + '" target="_blank">' + disName + '</a></label></div>';
                }
                else {
                    if (isRenameable) {
                        let endExternalLink = '';
                        if (optionSubmit.filesList[b].subKeyIndex != -1 && !optionSubmit.filesList[b].isReadOnly) {
                            endExternalLink = '</a></div>';
                        }
                        let readOnlyPart = '';
                        if (optionSubmit.filesList[b].subKeyIndex != -1 && optionSubmit.filesList[b].isReadOnly) {
                            readOnlyPart = ' readonly';
                        }
                        htmlElements += '<div class="w3-cell">' + labelPrefix + '<label>' + '</label>' + endExternalLink + '</div><div class="w3-cell" style="width: 100%"><input class="w3-input renamable w3-light-gray w3-text-teal" id="rnm_'+ inputID + '" name="rnm_'+ inputName + '" data-original="' + disName + '" onclick="renamableClicked(this)" oninput="renamableChanging(this)" onfocus="renamableFocus(this)" onblur="renamableBlur(this)" value="' + disName + '"' + readOnlyPart + '></div>';
                    }
                    else {
                        htmlElements += labelPrefix + '<div class="w3-cell"><label class="mainLabel" onclick="labelClicked(this)">' + disName + ':</label></div>';
                    }
                }
                if (optionSubmit.filesList[b].subKeyIndex != -1 && !isRenameable && !optionSubmit.filesList[b].isReadOnly) {
                    htmlElements += '</a></div>';
                }
                htmlElements += '<div class="tinyThumb"></div>';
                htmlElements += '<div class="w3-cell topSelectedOption topHidden" onclick="topSelectedOptionClicked(this)"></div>';
                htmlElements += '</div>';
                let coordinates = '';
                if (optionSubmit.filesList[b].docsPlacesList) {
                    if (optionSubmit.filesList[b].docsPlacesList.length > 0) {
                        if (optionSubmit.filesList[b].docsPlacesList[0].content) {
                            coordinates = ' data-coordinates="' + optionSubmit.filesList[b].docsPlacesList[0].content.replace (/\n/g, '|') + '"';
                        }
                    }
                }
                let hereWithoutThumb = true;
                if (optionSubmit.flags.search (/Thumb/i) != -1) {
                    hereWithoutThumb = false;
                }
                htmlElements += '<div id="mi3_' + itemUniqueID + '" class="w3-display-container mainItem3' + oneOptionClass + '"' + hidem1andm3 + coordinates + '>';
                if (isWithoutThumb || hereWithoutThumb || (optionSubmit.filesList[b].optionsStage != 0 && oneOptionClass == '')) { //  || optionSubmit.filesList[b].fileParent == ''
                    htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round withoutThumb" width="100%"><br>';
                }
                else if (optionSubmit.filesList[b].isFolder) {
                    if (optionSubmit.filesList[b].subPreviewTHumb) {
                        htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round subPreviewTHumb" src="' + optionSubmit.filesList[b].subPreviewTHumb + '" width="100%"><br>';
                    }
                    else if (optionSubmit.filesList[b].docThumb) {
                        htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round docThumb" src="' + optionSubmit.filesList[b].docThumb + '" width="100%"><br>';
                    }
                }
                else {
                    if (optionSubmit.filesList[b].subKeyIndex != -1 && (optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].subPreviewTHumb || optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].docThumb)) {
                        if (optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].subPreviewTHumb) {
                            htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round subPreviewTHumb" src="' + optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].subPreviewTHumb + '" width="100%"><br>';
                        }
                        else if (optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].docThumb) {
                            htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round docThumb" src="' + optionSubmit.filesList[optionSubmit.filesList[b].subKeyIndex].docThumb + '" width="100%"><br>';
                        }
                    }
                    else {
                        let isThumbFileExist = false;
                        try {
                            let thumbPath = getThumb (path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent), optionSubmit.filesList[b].fileName, optionSubmit.filesList[b].fileExtension);
                            if (fs.existsSync(thumbPath)) {
                                isThumbFileExist = true;
                            }
                        } catch(err) {
                            isThumbFileExist = false;
                        }
                        if (isThumbFileExist) {
                            let thumbURL = getThumbURL (optionSubmit.hostName, path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent), optionSubmit.filesList[b].fileName, optionSubmit.filesList[b].fileExtension);
                            htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round ' + listClassName + '" src="' + thumbURL + '" width="100%"><br>';
                        }
                        else {
                            if (oneOptionClass != '') {
                                htmlElements = htmlElements.slice (0, htmlElements.lastIndexOf ("mainItem3")) + "collapsed " + htmlElements.slice (htmlElements.lastIndexOf ("mainItem3"));
                            }
                            htmlElements += '<img id="thumb_' + itemUniqueID + '" class="w3-round noThumb" width="100%"><br>';
                        }
                    }
                }
                htmlElements += '</div>';

                htmlElements += '<div id="mi4_' + itemUniqueID + '" class="mainItem4' + oneOptionClass + colItemCon + '">';
                if (optionSubmit.filesList[b].isFolder) {
                    
                }
                else if (optionSubmit.filesList[b].optionsStage != 0) {
                    htmlElements += '<input type="hidden" id="'+ inputID + '" name="'+ inputName + '" onchange="inputChanged(this)"' + attributesStr + ' value="op_empty">';
                    htmlElements += '<div class="optionsCon"' + optionsCls + '>';
                    for (let fop = 0; fop < optionSubmit.filesList[b].optionsList.length; fop++) {
                        let optionsRootPhrase = optionSubmit.filesList[b].optionsRoots[fop].replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_");
                        let optionNameCode = optionSubmit.filesList[b].optionsList[fop].replace(/ /g, '_space_').replace(/\./g, '_dot_');
                        let optionPaired = 'no_paired';
                        if (optionSubmit.filesList[b].optionsPaireds[fop]) {
                            optionPaired = optionSubmit.filesList[b].optionsPaireds[fop].replace(/ /g, '_space_').replace(/\./g, '_dot_');
                        }
                        let optionMarks = '';
                        let optionClasses = '';
                        if (defaultIndex == fop) {
                            optionClasses = ' isDefault';
                        }
                        if (optionSubmit.filesList[b].optionsList[fop] == optionSubmit.filesList[b].optionsDefault) {
                            optionMarks += ' data-chosen="yes"';
                            if (optionSubmit.filesList[b].subKeyIndex != -1) {
                                optionMarks += ' data-subkey="yes"';
                            }
                            if (optionSubmit.filesList[b].defaultPaired) {
                                if (optionSubmit.filesList[b].optionsStage == 10) {
                                    optionPaired = 'trsd_paired_fake_' + optionSubmit.filesList[b].defaultPaired;
                                    optionClasses = ' fakeOption';
                                }
                                else {
                                    optionPaired = 'trsd_paired_default_' + optionSubmit.filesList[b].defaultPaired;
                                }
                            }
                        }
                        let optionText = getPureDisplayName (optionSubmit.filesList[b].optionsList[fop]);
                        let optionImageURL = "";
                        let isOptionThumbFileExist = false;
                        try {
                            let optionThumbPath = getThumb (path.join (tsRoot, "Workshop", optionSubmit.filesList[b].optionsRoots[fop]), optionSubmit.filesList[b].optionsList[fop], "");
                            if (fs.existsSync(optionThumbPath)) {
                                isOptionThumbFileExist = true;
                            }
                        } catch(err) {
                            isOptionThumbFileExist = false;
                        }
                        if (isOptionThumbFileExist) {
                            isOptionThumbFileExist = true;
                            optionImageURL = getThumbURL (optionSubmit.hostName, path.join (tsRoot, "Workshop", optionSubmit.filesList[b].optionsRoots[fop]), optionSubmit.filesList[b].optionsList[fop], "");
                        }
                        if (!isOptionThumbFileExist) {
                            if (/\.(jpeg|jpg|webp|svg|png|gif)$/i.test(optionSubmit.filesList[b].optionsList[fop])) {
                                optionImageURL = getImageFileURL (optionSubmit.hostName, path.join (tsRoot, "Workshop", optionSubmit.filesList[b].optionsRoots[fop], optionSubmit.filesList[b].optionsList[fop]));
                            }
                        }
                        if (!isOptionThumbFileExist) {
                            let optionDocOutputPath = path.join (tsRoot, "Pages", "Workshop", optionSubmit.filesList[b].optionsRoots[fop], getPureName (optionSubmit.filesList[b].optionsList[fop]));
                            let docOutputFolderName = "[" + (optionSubmit.filesList[b].optionsRoots[fop] + path.sep + getPureName (optionSubmit.filesList[b].optionsList[fop])).split (path.sep).join (".") + "].indd";
                            let optionThumbPath = null;
                            try {
                                optionThumbPath = path.join (optionDocOutputPath, docOutputFolderName, "0001.jpg");
                                if (fs.existsSync(optionThumbPath)) {
                                    isOptionThumbFileExist = true;
                                }
                                else {
                                    optionThumbPath = path.join (optionDocOutputPath, docOutputFolderName, "0001.png");
                                    if (fs.existsSync(optionThumbPath)) {
                                        isOptionThumbFileExist = true;
                                    }
                                }
                            } catch(err) {
                                isOptionThumbFileExist = false;
                            }
                            if (isOptionThumbFileExist) {
                                optionImageURL = getImageFileURL (optionSubmit.hostName, optionThumbPath);
                            }
                        }
                        htmlElements += '<div class="w3-animate-top optionCon' + optionClasses + '" onclick="optionClicked(this, true)" data-paired="' + optionPaired + '" id="op_' + itemUniqueID + "_trsd_option_sep_" + optionsRootPhrase + "_trsd_option_sep_" + optionNameCode + '"' + optionMarks + '>';
                        htmlElements += '<img class="optionImg" src="' + optionImageURL + '"' + optionImageDisplay + '>';
                        htmlElements += '<p class="optionText' + verticalTextClass + '"' + optionTitleDisplay + '>' + optionText + '</p>';
                        if (optionSubmit.filesList[b].optionsTxtContents[fop] !== false) {
                            let optionContent = '';
                            if (optionSubmit.filesList[b].optionsStage != 10) {
                                optionContent = optionSubmit.filesList[b].optionsTxtContents[fop];
                                if (optionContent.indexOf (lsSnippetDynamicTag) == 0 && optionContentDisplay == ' style="display: block"') {
                                    if (optionContent.search (/(:[\n\r])|(\r\n)/) != -1) {
                                        optionContent = optionContent.slice (optionContent.search (/(:[\n\r])|(\r\n)/) + optionContent.match (/(:[\n\r])|(\r\n)/)[0].length);
                                    }
                                }
                            }
                            let withoutTags = solveTags (optionContent);
                            htmlElements += '<p class="optionContent"' + optionContentDisplay + '>' + withoutTags + '</p>';
                        }
                        htmlElements += '</div>';
                    }
                    htmlElements += '</div>';
                }
                else if (((optionSubmit.filesList[b].fileExtension == '.txt' || optionSubmit.filesList[b].fileExtension == '.md') && isToUpload != true) || isToUpload == false) {
                    let theContent = solveTags (optionSubmit.filesList[b].textContent);
                    let textInputClasses = "w3-input w3-border textInput";
                    if (isCallerLabel) {
                        textInputClasses += " callerLabel";
                    }
                    if (isStatic) {
                        if (theContent == "no_text") {
                            theContent = "";
                        }
                        htmlElements += optionSubmit.filesList[b].textContent;
                    }
                    else if (isInput) {
                        if (attributesStr.indexOf ("value=") == -1) {
                            if (theContent == "no_text") {
                                theContent = "";
                            }
                            attributesStr += ' value="' + theContent + '"';
                        }
                        htmlElements += '<input class="' + textInputClasses + '" id="'+ inputID + '" name="'+ inputName + '" onchange="inputChanged(this)" oninput="inputChanging(this)" onfocus="focusDone(this)" onblur="blurDone(this)" dir="auto"' + attributesStr + '>';    
                    }
                    else {
                        if (optionSubmit.filesList[b].fileExtension == '.md') {
                            isMarkdown = true;
                        }
                        if (isMarkdown) {
                            textInputClasses += " markdownField";
                        }
                        if (attributesStr.indexOf ("value=") != -1) {
                            theContent = attributesStr.match (/value=".+"/);
                            theContent = theContent[0].slice (6, -1);
                            attributesStr = attributesStr.replace (/\s?value=".+"/, "");
                        }
                        else if (theContent == "no_text") {
                            theContent = "";
                        }
                        htmlElements += '<textarea class="' + textInputClasses + ' textareaField" type="text" id="'+ inputID + '" name="'+ inputName + '" onchange="inputChanged(this)" oninput="inputChanging(this)" onfocus="focusDone(this)" onblur="blurDone(this)" dir="auto"' + attributesStr + '>' + theContent + '</textarea>';    
                    }
                }
                else {
                    let isNowPlayHTML = false;
                    let hintMessage = 'To upload click above.';
                    let downloadExt = '?download';
                    let downloadTagEnd = ' download';
                    let downloadBtnText = 'Download';
                    if (optionSubmit.filesList[b].isHTMLOutput && !optionSubmit.filesList[b].isHidden) {
                        isNowPlayHTML = true;
                        hintMessage = '';
                        downloadExt = '';
                        downloadTagEnd = ' target="_blank"';
                        downloadBtnText = 'Open the Web Page';
                    }
                    let relativePath = path.relative (tsRoot, path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent));
                    let slashPortion = relativePath.split (path.sep).join ("/");
                    let toDownloadFileFullPath = "https://" + optionSubmit.hostName + "/" + slashPortion.replace ("Workshop/", "") + '/' + optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension + downloadExt;
                    let htmlPageFullPath = toDownloadFileFullPath + queryStringWithQuestion;
                    htmlPageFullPath = removeQueryParameter (htmlPageFullPath, "pass");
                    let imagePortion = 'middle"><div class="w3-text-teal">Click here... or drag and drop.</div>';
                    if (!isNowPlayHTML) {
                        let optionsRootPhrase = path.relative (path.join (tsRoot, "Workshop"), path.join (optionSubmit.filesList[b].filePath, optionSubmit.filesList[b].fileParent));
                        optionsRootPhrase = optionsRootPhrase.replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_");
                        let optionNameCode = (optionSubmit.filesList[b].fileName + optionSubmit.filesList[b].fileExtension).replace(/ /g, '_space_').replace(/\./g, '_dot_');
                        let fakeCopying = 'op_' + itemUniqueID + "_trsd_option_sep_" + optionsRootPhrase + "_trsd_option_sep_" + optionNameCode;
                        if (optionSubmit.filesList[b].fileExtension == '.webp' || optionSubmit.filesList[b].fileExtension == '.png' || optionSubmit.filesList[b].fileExtension == '.gif' || optionSubmit.filesList[b].fileExtension == '.jpg' || optionSubmit.filesList[b].fileExtension == '.jpeg' || optionSubmit.filesList[b].fileExtension == '.svg') {
                            imagePortion = 'right"><img src="' + toDownloadFileFullPath + '">';
                        }
                        htmlElements += '<div class="fileCon w3-display-container">';
                        htmlElements += '<div class="diagonalStripes w3-display-middle"><div class="uploadName w3-display-topleft w3-text-teal"></div></div>';
                        htmlElements += '<div class="uploadFileCon w3-display-' + imagePortion + '</div>';
                        htmlElements += '<input class="w3-input w3-tiny w3-display-middle" type="file" id="'+ inputID + '" name="'+ inputName + '"data-copying="' + fakeCopying + '" onchange="inputChanged(this)" style="width:100%;"' + attributesStr + multiplePart + '>';
                        htmlElements += '</div>';
                    }
                    htmlElements += '<div class="downloadDiv">';
                    htmlElements += '<div class="w3-text-teal w3-medium" style="margin-top: 15px; float: left;">' + hintMessage + '</div>';
                    if (optionSubmit.filesList[b].isHTMLOutput && !optionSubmit.filesList[b].isHidden) {
                        htmlElements += '<div class="w3-button w3-teal w3-medium" style="margin-top: 15px; margin-right: 15px" data-url="' + htmlPageFullPath + '" onclick="openTheWebPage(this)">' + downloadBtnText + '</div>';
                        htmlElements += '<a href="' + htmlPageFullPath + '" target="_blank">';
                        htmlElements += '<div class="w3-button w3-teal w3-medium" style="margin-top: 15px;">' + "Open in New Window" + '</div>';
                        htmlElements += '</a>';
                    }
                    else {
                        htmlElements += '<a href="' + toDownloadFileFullPath + '" style="float: right;"' + downloadTagEnd + '>';
                        htmlElements += '<div class="w3-button w3-teal w3-medium" style="margin-top: 15px;">' + downloadBtnText + '</div>';
                        htmlElements += '</a>';
                    }
                    htmlElements += '</div>';
                }
                htmlElements += '</div>';
                htmlElements += '<div id="mi5_' + itemUniqueID + '" class="w3-row mainItem5">';
                if (optionSubmit.filesList[b].optionsStage != 0) {
                    for (let fop = 0; fop < optionSubmit.filesList[b].optionsList.length; fop++) {
                        let optionsRootPhrase = optionSubmit.filesList[b].optionsRoots[fop].replace(/ /g, '_space_').replace(/\./g, '_dot_').split (path.sep).join ("_slash_");
                        let optionNameCode = optionSubmit.filesList[b].optionsList[fop].replace(/ /g, '_space_').replace(/\./g, '_dot_');
                        htmlElements += '<div class="optionPocket" id="pocket_' + itemUniqueID + "_trsd_option_sep_" + optionsRootPhrase + "_trsd_option_sep_" + optionNameCode + '">';
                        htmlElements += '</div>';
                    }
                }
                htmlElements += '</div>';
                htmlElements += '</div>';
                if (repMatrix[b][0] != null) {
                    if (repMatrix[b][1] == repArrangeRows[repMatrix[b][0]][1].length - 1) {
                        htmlElements += '</div>';
                    }
                }
                if (optionSubmit.filesList[b].isHidden === 1) {
                    optionSubmit.filesList[b].isHidden = false;
                    b--;
                }
            }
            newOptionsPage = newOptionsPage.replace ("THE_OPTIONS", htmlElements);
            res.writeHead(200, {'Content-Type' : 'text/html'});
            res.write(newOptionsPage);
            res.end();
        }
        else {
            setTimeout(sendOptionData, 300, res, optionSubmit);
        }
    }
    else {
        setTimeout(sendOptionData, 300, res, optionSubmit);
    }
}

let srvr = http.createServer((req, res) => {
    if (req.url == "/submit_new_option") {
        let form = new formidable.IncomingForm();
        form.parse(req, function (err, fields, files) {
            if (err) throw err;
            let optionSubmit = {code: "", optionRealPath: "", isFakePaired: false, optionPath: "", callerName: "", optionName: "", url: "", hostName: req.headers.host, isReadDirRequest: false, treeShadeSortContent: null, plainList: null, filesList: null, counter: 0, isAllReadDone: false, pairedFolder: "", flags: "", locationhref: ""};
            for (let fieldKey of Object.keys(fields)) {
                let fieldValue = Array.isArray(fields[fieldKey]) ? fields[fieldKey][0] : fields[fieldKey];
                if (fieldKey == "submit_option_name") {
                    optionSubmit.code = fieldValue;
                }
                else if (fieldKey == "paired_folder") {
                    if (fieldValue) {
                        if (fieldValue.indexOf ("trsd_paired_") == 0) {
                            if (fieldValue.indexOf ("trsd_paired_fake_") == 0) {
                                fieldValue = fieldValue.replace ("trsd_paired_fake_", "");
                                optionSubmit.isFakePaired = true;
                            }
                            else {
                                fieldValue = fieldValue.replace ("trsd_paired_default_", "");
                            }
                            let pairedSplitted = fieldValue.split ("_trsd_sep_");
                            optionSubmit.optionPath = pairedSplitted[0].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                            if (pairedSplitted.length > 1) {
                                optionSubmit.pairedFolder = pairedSplitted[1].replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                            }
                        }
                        else {
                            optionSubmit.pairedFolder = fieldValue.replace (/_space_/g, " ").replace(/_dot_/g, '.').replace (/_slash_/g, path.sep);
                        }
                    }
                }
                else if (fieldKey == "flags") {
                    optionSubmit.flags = fieldValue;
                }
                else if (fieldKey == "locationhref") {
                    optionSubmit.locationhref = fieldValue;
                }
            }
            if (optionSubmit.code) {
                setTimeout(sendOptionData, 300, res, optionSubmit);
            }
        });
    }
    else {
        let requrl = req.url;
        try {requrl = decodeURI(requrl);} catch {}
        requrl = requrl.replace (/\\/g, "/");
        let urlEndMark = '';
        if (requrl.indexOf ("?") != -1) {
            urlEndMark = requrl.slice (requrl.lastIndexOf ("?") + 1);
            requrl = requrl.slice (0, requrl.lastIndexOf ("?"));
        }
        let keyFileID = null;
        if (requrl.length > 1 && requrl.slice (1).search (/\//) == -1) {
            if (requrl.slice (1).search (/id\./i) == 0) {
                keyFileID = requrl.slice (4);
                keyFileID = "/" + keyFileID.replace (/\./g, "/");
            }
        }
        if (keyFileID == null) {
            if (requrl != "/favicon.ico" && requrl.search (/\/Workshop\//i) != 0 && requrl.indexOf ("/Pages/Workshop/") != 0 && requrl.indexOf ("/Pages/Versions/") != 0 && requrl.indexOf ("/Versions PDFs/") != 0) {
                requrl = "/Workshop" + requrl;
            }
        } 
        let dealDone = false;
        if(req.method === 'GET') {
            if (requrl == '/favicon.ico') {
                dealDone = true;
                function faviconHandler (err, content) {
                    if (err) {
                        res.writeHead(400, {'Content-type':'text/html'});
                        console.log(err);
                        res.end("No such image");    
                    } else {
                        faviconData = content;
                        let contentType = 'image/x-icon';
                        //specify the content type in the response will be an image
                        res.writeHead(200,{'Content-type': contentType});
                        res.end(content);
                    }
                }
                if (faviconData != null) {
                    faviconHandler (null, faviconData);
                }
                else {
                    let imagePath = path.join (tsRoot, "Interface", "favicon.png");
                    fs.readFile(imagePath, faviconHandler);
                }
            }
            else if (urlEndMark == 'download' 
                        || requrl.search (/\.jpeg$/i) != -1
                        || requrl.search (/\.jpg$/i) != -1
                        || requrl.search (/\.webp$/i) != -1 
                        || requrl.search (/\.svg$/i) != -1
                        || requrl.search (/\.png$/i) != -1
                        || requrl.search (/\.gif$/i) != -1
                        || requrl.search (/\.css$/i) != -1
                        || requrl.search (/\.js$/i) != -1
                        || requrl.search (/\.vcf$/i) != -1
                        || requrl.search (/\.pdf$/i) != -1
                        || requrl.search (/\.ttf$/i) != -1) {
                dealDone = true;
                let contentType = 'image/jpeg';
                let cacheSelected = jpgCache;
                if (requrl.slice (-5) == '.webp') {
                    contentType = 'image/webp';
                    cacheSelected = webpCache;
                }
                else if (requrl.slice (-4) == '.svg') {
                    contentType = 'image/svg+xml';
                    cacheSelected = svgCache;
                }
                else if (requrl.slice (-4) == '.png') {
                    contentType = 'image/png';
                    cacheSelected = pngCache;
                }
                else if (requrl.slice (-4) == '.gif') {
                    contentType = 'image/gif';
                    cacheSelected = gifCache;
                }
                else if (requrl.slice (-4) == '.css') {
                    contentType = 'text/css';
                    cacheSelected = cssCache;
                }
                else if (requrl.slice (-3) == '.js') {
                    contentType = 'text/javascript';
                    cacheSelected = jsCache;
                }
                else if (requrl.slice (-4) == '.pdf') {
                    contentType = 'application/pdf';
                    cacheSelected = pdfCache;
                }
                else if (requrl.slice (-4) == '.ttf') {
                    contentType = 'font/ttf';
                    cacheSelected = fontCache;
                }
                else if (requrl.slice (-4) == '.vcf') {
                    contentType = 'text/vcard';
                    cacheSelected = vcardCache;
                }
                else if (urlEndMark == 'download') {
                    contentType = 'download';
                    cacheSelected = downloadCache;
                }
                let resourceFullPath = path.join (tsRoot, requrl);
                let theRes = res;
                function resourceHandler (err, content) {
                    if (err) {
                        theRes.writeHead(400, {'Content-type':'text/html'});
                        theRes.end("No such image");    
                    } else {
                        if (err == null) {
                            addFileContent (resourceFullPath, cacheSelected, content);
                        }
                        theRes.writeHead(200,{'Content-type': contentType});
                        theRes.end(content);
                    }
                }
                let testedContent = null; //getFileContent (resourceFullPath, cacheSelected);
                if (testedContent != null) {
                    resourceHandler (false, testedContent);
                }
                else {
                    fs.readFile (resourceFullPath, resourceHandler);
                }
            }
        }
        if (!dealDone) {
            let keyPathTimeFullPath = null;
            if (keyFileID != null) {
                keyPathTimeFullPath = path.join(tsRoot, ".Data", "IDs", keyFileID.slice (1), "Path", "Change Time");
            }
            function keyPathTimeHandler (err, changeTime) {
                let keyPathValueFullPath = null;
                if (changeTime != null) {
                    keyPathValueFullPath = path.join(tsRoot, ".Data", "IDs", keyFileID.slice (1), "Path", "V", changeTime, "Value");
                }
                function keyPathValueHandler (err, foundKeyPath) {
                    if (err == null) {
                        requrl = foundKeyPath.slice (0, foundKeyPath.lastIndexOf ("/"));
                        try {requrl = decodeURI (requrl);} catch {}
                        requrl = "/Workshop" + requrl;
                    }
                    let htmlFileName = null;
                    if (requrl.slice (-4) == '.htm' || requrl.slice (-5) == '.html') {
                        htmlFileName = requrl.slice (requrl.lastIndexOf ("/") + 1);
                        requrl = requrl.slice (0, requrl.lastIndexOf ("/"));
                    }
                    if (requrl.length > 0 && requrl[requrl.length-1] == '/') {
                        requrl = requrl.slice (0, -1);
                    }
                    let mainPath = path.join(tsRoot , requrl);
                    let ifs = {keyFileID: keyFileID, isFact: false, isCodeRequested: false, submitName: null, code: [], sourcePath: mainPath, sourceName: "", fork: [], isFolderRequested: false, isDone: false, isRedirectingDone: false, isEmail: false, isWhatsapp: false, snippetType: null, isQR: false, isFunction: false, descendingDeep: 0, isURLWithoutWorkshop: false, separator: ""};
                    let postData = {htmlFileName: htmlFileName, 
                                    htmlFileContent: null, 
                                    mainPath: mainPath, 
                                    tsKey: ifs, 
                                    formFields: [], 
                                    formFiles: [], 
                                    isSourceAndDesPathsSolved: false, 
                                    isFieldsAndFilesRequested: false, 
                                    isFieldsCleanDone: false,
                                    isFieldsNonDeletedDone: false, 
                                    isFieldsNonRenamedDone: false, 
                                    isFieldsDone: false, 
                                    isTextSnippetsCreated: false, 
                                    isFieldsOutputted: false, 
                                    isFilesDone: false, 
                                    isPost: false, 
                                    postType: '', 
                                    isBtnStatic: null, 
                                    isRemoveRequested: false, 
                                    isRemoveDone: false, 
                                    removedCount: 0, 
                                    isPostDone: true};
                    postData.tsKey.fork = [{root: null, portion: null, isPathSolved: false, filesFound: false}];
                    if (req.method === 'POST') {
                        postData.isPost = true;
                        postData.isPostDone = false;
                        const contentType = req.headers['content-type'] || '';
                        if (!contentType.includes('multipart/form-data')) {
                            postData.postType = "<Invalid Content-Type>";
                            sendForm(mainPath, requrl, urlEndMark, req.headers.host, res, postData);
                            return;
                        }

                        let form = new formidable.IncomingForm();
                        form.uploadDir = path.join(tsRoot, 'uploads_temp');
                        form.parse(req, function (err, fields, files) {
                            if (err) {
                                postData.postType = "<Form Parse Error>";
                                postData.parseError = err.message;
                                sendForm(mainPath, requrl, urlEndMark, req.headers.host, res, postData);
                                return;
                            }
                            let newNames = [];
                            for (let fieldKey of Object.keys(fields)) {
                                let fieldValue = Array.isArray(fields[fieldKey]) ? fields[fieldKey][0] : fields[fieldKey];
                                if (fieldKey.indexOf ('rnm') == 0) {
                                    newNames.push ({key: fieldKey.slice (4), newName: fieldValue});
                                }
                                else {
                                    continue;
                                }
                            }
                            for (let fieldKey of Object.keys(fields)) {
                                let fieldValue = Array.isArray(fields[fieldKey]) ? fields[fieldKey][0] : fields[fieldKey];
                                let newName = '';
                                if (fieldKey == "submit_btn") {
                                    postData.tsKey.submitName = fieldValue;
                                    continue;
                                }
                                if (fieldKey.indexOf ('rnm') == 0) {
                                    continue;
                                }
                                let isToDelete = false;
                                let isToClean = false;
                                if (fieldKey.indexOf ("_trsd_delete") != -1) {
                                    fieldKey = fieldKey.replace ("_trsd_delete", "");
                                    isToDelete = true;
                                }
                                else if (fieldKey.indexOf ("_trsd_clean") != -1) {
                                    fieldKey = fieldKey.replace ("_trsd_clean", "");
                                    isToDelete = true;
                                    isToClean = true;
                                }
                                else {
                                    for (let nms = 0; nms < newNames.length; nms++) {
                                        if (newNames[nms].key == fieldKey) {
                                            newName = newNames[nms].newName;
                                            newNames.splice (nms, 1);
                                            break;
                                        }
                                    }
                                }
                                let fileName = fieldKey.replace (/_space_/g, " ").replace(/_dot_/g, '.');
                                fileName = fileName.slice (3);
                                fileName = fileName.replace (/:.*:/g, "");
                                let fullFormFile = fileName.split ("_slash_");
                                fileName = fullFormFile[fullFormFile.length - 1];
                                let subPath = '';
                                if (fullFormFile.length > 1) {
                                    fullFormFile.splice (fullFormFile.length - 1, 1);
                                    subPath = fullFormFile.join (path.sep);
                                }
                                postData.formFields.push ({subPath: subPath, 
                                                            fileName: fileName, 
                                                            optionsSourceRoot: null, 
                                                            newName: newName, 
                                                            isToRename: false, 
                                                            isToSkip: false, 
                                                            isToDelete: isToDelete,
                                                            isToClean: isToClean, 
                                                            fieldContent: fieldValue, 
                                                            isRequested: false, isDone: false, 
                                                            textSnippets: null});
                            }
                            for (let fileKey of Object.keys(files)) {
                                let fileValue = Array.isArray(files[fileKey]) ? files[fileKey][0] : files[fileKey];
                                let newName = '';
                                if (fileValue.size == 0)
                                    continue;
                                for (let nms = 0; nms < newNames.length; nms++) {
                                    if (newNames[nms].key == fileKey) {
                                        newName = newNames[nms].newName;
                                        newNames.splice (nms, 1);
                                        break;
                                    }
                                }
                                let fileName = fileKey.replace (/_space_/g, " ").replace(/_dot_/g, '.');
                                fileName = fileName.slice (3);
                                fileName = fileName.replace (/:.*:/g, "");
                                let fullFormFile = fileName.split ("_slash_");
                                fileName = fullFormFile[fullFormFile.length - 1];
                                let subPath = '';
                                if (fullFormFile.length > 1) {
                                    fullFormFile.splice (fullFormFile.length - 1, 1);
                                    subPath = fullFormFile.join (path.sep);
                                }
                                postData.formFiles.push ({subPath: subPath, 
                                                            fileName: fileName, 
                                                            newName: newName,
                                                            uploadedName: fileValue.originalFilename, 
                                                            uploadedPath: fileValue.filepath, 
                                                            isRequested: false, 
                                                            isDone: false});
                            }
                            if (postData.formFields.length == 0 && postData.formFiles.length == 0) {
                                postData.postType = "<Void>";
                                //postData.isBtnStatic = true;
                            }
                            sendForm (mainPath, requrl, urlEndMark, req.headers.host, res, postData);
                        });
                    }
                    if(req.method === 'GET')
                    {

                        sendForm (mainPath, requrl, urlEndMark, req.headers.host, res, postData);
                    }
                }
                if (err) {
                    keyPathValueHandler (true, null);
                }
                else {
                    fs.readFile(keyPathValueFullPath, 'UTF-8', keyPathValueHandler);
                }
            }
            if (keyFileID == null) {
                keyPathTimeHandler (true, null);
            }
            else {
                fs.readFile(keyPathTimeFullPath, 'UTF-8', keyPathTimeHandler);
            }
        }
    }
});
srvr.listen(80);
srvr.timeout = 600000;